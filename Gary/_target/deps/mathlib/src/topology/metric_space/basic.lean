/-
Copyright (c) 2015, 2017 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Robert Y. Lewis, Johannes H√∂lzl, Mario Carneiro, S√©bastien Gou√´zel
-/

import data.int.interval
import topology.algebra.order.compact
import topology.metric_space.emetric_space

/-!
# Metric spaces

This file defines metric spaces. Many definitions and theorems expected
on metric spaces are already introduced on uniform spaces and topological spaces.
For example: open and closed sets, compactness, completeness, continuity and uniform continuity

## Main definitions

* `has_dist Œ±`: Endows a space `Œ±` with a function `dist a b`.
* `pseudo_metric_space Œ±`: A space endowed with a distance function, which can
  be zero even if the two elements are non-equal.
* `metric.ball x Œµ`: The set of all points `y` with `dist y x < Œµ`.
* `metric.bounded s`: Whether a subset of a `pseudo_metric_space` is bounded.
* `metric_space Œ±`: A `pseudo_metric_space` with the guarantee `dist x y = 0 ‚Üí x = y`.

Additional useful definitions:

* `nndist a b`: `dist` as a function to the non-negative reals.
* `metric.closed_ball x Œµ`: The set of all points `y` with `dist y x ‚â§ Œµ`.
* `metric.sphere x Œµ`: The set of all points `y` with `dist y x = Œµ`.
* `proper_space Œ±`: A `pseudo_metric_space` where all closed balls are compact.
* `metric.diam s` : The `supr` of the distances of members of `s`.
  Defined in terms of `emetric.diam`, for better handling of the case when it should be infinite.

TODO (anyone): Add "Main results" section.

## Implementation notes

Since a lot of elementary properties don't require `eq_of_dist_eq_zero` we start setting up the
theory of `pseudo_metric_space`, where we don't require `dist x y = 0 ‚Üí x = y` and we specialize
to `metric_space` at the end.

## Tags

metric, pseudo_metric, dist
-/

open set filter topological_space

open_locale uniformity topological_space big_operators filter nnreal ennreal

universes u v w
variables {Œ± : Type u} {Œ≤ : Type v}

/-- Construct a uniform structure core from a distance function and metric space axioms.
This is a technical construction that can be immediately used to construct a uniform structure
from a distance function and metric space axioms but is also useful when discussing
metrizable topologies, see `pseudo_metric_space.of_metrizable`. -/
def uniform_space.core_of_dist {Œ± : Type*} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)
  (dist_self : ‚àÄ x : Œ±, dist x x = 0)
  (dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
  (dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z) : uniform_space.core Œ± :=
{ uniformity := (‚®Ö Œµ>0, ùìü {p:Œ±√óŒ± | dist p.1 p.2 < Œµ}),
  refl       := le_infi $ assume Œµ, le_infi $
    by simp [set.subset_def, id_rel, dist_self, (>)] {contextual := tt},
  comp       := le_infi $ assume Œµ, le_infi $ assume h, lift'_le
    (mem_infi_of_mem (Œµ / 2) $ mem_infi_of_mem (div_pos h zero_lt_two) (subset.refl _)) $
    have ‚àÄ (a b c : Œ±), dist a c < Œµ / 2 ‚Üí dist c b < Œµ / 2 ‚Üí dist a b < Œµ,
      from assume a b c hac hcb,
      calc dist a b ‚â§ dist a c + dist c b : dist_triangle _ _ _
        ... < Œµ / 2 + Œµ / 2 : add_lt_add hac hcb
        ... = Œµ : by rw [div_add_div_same, add_self_div_two],
    by simpa [comp_rel],
  symm       := tendsto_infi.2 $ assume Œµ, tendsto_infi.2 $ assume h,
    tendsto_infi' Œµ $ tendsto_infi' h $ tendsto_principal_principal.2 $ by simp [dist_comm] }

/-- Construct a uniform structure from a distance function and metric space axioms -/
def uniform_space_of_dist
  (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)
  (dist_self : ‚àÄ x : Œ±, dist x x = 0)
  (dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
  (dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z) : uniform_space Œ± :=
uniform_space.of_core (uniform_space.core_of_dist dist dist_self dist_comm dist_triangle)

/-- The distance function (given an ambient metric space on `Œ±`), which returns
  a nonnegative real number `dist x y` given `x y : Œ±`. -/
class has_dist (Œ± : Type*) := (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)

export has_dist (dist)

-- the uniform structure and the emetric space structure are embedded in the metric space structure
-- to avoid instance diamond issues. See Note [forgetful inheritance].

/-- This is an internal lemma used inside the default of `pseudo_metric_space.edist`. -/
private theorem pseudo_metric_space.dist_nonneg' {Œ±} {x y : Œ±} (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)
  (dist_self : ‚àÄ x : Œ±, dist x x = 0)
  (dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
  (dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z): 0 ‚â§ dist x y :=
have 2 * dist x y ‚â• 0,
  from calc 2 * dist x y = dist x y + dist y x : by rw [dist_comm x y, two_mul]
    ... ‚â• 0 : by rw ‚Üê dist_self x; apply dist_triangle,
nonneg_of_mul_nonneg_left this zero_lt_two

/-- This tactic is used to populate `pseudo_metric_space.edist_dist` when the default `edist` is
used. -/
protected meta def pseudo_metric_space.edist_dist_tac : tactic unit :=
tactic.intros >> `[exact (ennreal.of_real_eq_coe_nnreal _).symm <|> control_laws_tac]

/-- Metric space

Each metric space induces a canonical `uniform_space` and hence a canonical `topological_space`.
This is enforced in the type class definition, by extending the `uniform_space` structure. When
instantiating a `metric_space` structure, the uniformity fields are not necessary, they will be
filled in by default. In the same way, each metric space induces an emetric space structure.
It is included in the structure, but filled in by default.
-/
class pseudo_metric_space (Œ± : Type u) extends has_dist Œ± : Type u :=
(dist_self : ‚àÄ x : Œ±, dist x x = 0)
(dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
(dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z)
(edist : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû := Œª x y,
  @coe (‚Ñù‚â•0) _ _ ‚ü®dist x y, pseudo_metric_space.dist_nonneg' _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫‚ü©)
(edist_dist : ‚àÄ x y : Œ±,
  edist x y = ennreal.of_real (dist x y) . pseudo_metric_space.edist_dist_tac)
(to_uniform_space : uniform_space Œ± := uniform_space_of_dist dist dist_self dist_comm dist_triangle)
(uniformity_dist : ùì§ Œ± = ‚®Ö Œµ>0, ùìü {p:Œ±√óŒ± | dist p.1 p.2 < Œµ} . control_laws_tac)

variables [pseudo_metric_space Œ±]

@[priority 100] -- see Note [lower instance priority]
instance metric_space.to_uniform_space' : uniform_space Œ± :=
pseudo_metric_space.to_uniform_space

@[priority 200] -- see Note [lower instance priority]
instance pseudo_metric_space.to_has_edist : has_edist Œ± := ‚ü®pseudo_metric_space.edist‚ü©

/-- Construct a pseudo-metric space structure whose underlying topological space structure
(definitionally) agrees which a pre-existing topology which is compatible with a given distance
function. -/
def pseudo_metric_space.of_metrizable {Œ± : Type*} [topological_space Œ±] (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)
  (dist_self : ‚àÄ x : Œ±, dist x x = 0)
  (dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
  (dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z)
  (H : ‚àÄ s : set Œ±, is_open s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, ‚àÄ y, dist x y < Œµ ‚Üí y ‚àà s) :
pseudo_metric_space Œ± :=
{ dist := dist,
  dist_self := dist_self,
  dist_comm := dist_comm,
  dist_triangle := dist_triangle,
  to_uniform_space := { is_open_uniformity := begin
    dsimp only [uniform_space.core_of_dist],
    intros s,
    change is_open s ‚Üî _,
    rw H s,
    refine forall‚ÇÇ_congr (Œª x x_in, _),
    erw (has_basis_binfi_principal _ nonempty_Ioi).mem_iff,
    { refine exists‚ÇÇ_congr (Œª Œµ Œµ_pos, _),
      simp only [prod.forall, set_of_subset_set_of],
      split,
      { rintros h _ y H rfl,
        exact h y H },
      { intros h y hxy,
        exact h _ _ hxy rfl } },
    { exact Œª r (hr : 0 < r) p (hp : 0 < p), ‚ü®min r p, lt_min hr hp,
      Œª x (hx : dist _ _ < _), lt_of_lt_of_le hx (min_le_left r p),
      Œª x (hx : dist _ _ < _), lt_of_lt_of_le hx (min_le_right r p)‚ü© },
    { apply_instance }
    end,
    ..uniform_space.core_of_dist dist dist_self dist_comm dist_triangle },
  uniformity_dist := rfl }

@[simp] theorem dist_self (x : Œ±) : dist x x = 0 := pseudo_metric_space.dist_self x

theorem dist_comm (x y : Œ±) : dist x y = dist y x := pseudo_metric_space.dist_comm x y

theorem edist_dist (x y : Œ±) : edist x y = ennreal.of_real (dist x y) :=
pseudo_metric_space.edist_dist x y

theorem dist_triangle (x y z : Œ±) : dist x z ‚â§ dist x y + dist y z :=
pseudo_metric_space.dist_triangle x y z

theorem dist_triangle_left (x y z : Œ±) : dist x y ‚â§ dist z x + dist z y :=
by rw dist_comm z; apply dist_triangle

theorem dist_triangle_right (x y z : Œ±) : dist x y ‚â§ dist x z + dist y z :=
by rw dist_comm y; apply dist_triangle

lemma dist_triangle4 (x y z w : Œ±) :
  dist x w ‚â§ dist x y + dist y z + dist z w :=
calc dist x w ‚â§ dist x z + dist z w : dist_triangle x z w
          ... ‚â§ (dist x y + dist y z) + dist z w : add_le_add_right (dist_triangle x y z) _

lemma dist_triangle4_left (x‚ÇÅ y‚ÇÅ x‚ÇÇ y‚ÇÇ : Œ±) :
  dist x‚ÇÇ y‚ÇÇ ‚â§ dist x‚ÇÅ y‚ÇÅ + (dist x‚ÇÅ x‚ÇÇ + dist y‚ÇÅ y‚ÇÇ) :=
by { rw [add_left_comm, dist_comm x‚ÇÅ, ‚Üê add_assoc], apply dist_triangle4 }

lemma dist_triangle4_right (x‚ÇÅ y‚ÇÅ x‚ÇÇ y‚ÇÇ : Œ±) :
  dist x‚ÇÅ y‚ÇÅ ‚â§ dist x‚ÇÅ x‚ÇÇ + dist y‚ÇÅ y‚ÇÇ + dist x‚ÇÇ y‚ÇÇ :=
by { rw [add_right_comm, dist_comm y‚ÇÅ], apply dist_triangle4 }

/-- The triangle (polygon) inequality for sequences of points; `finset.Ico` version. -/
lemma dist_le_Ico_sum_dist (f : ‚Ñï ‚Üí Œ±) {m n} (h : m ‚â§ n) :
  dist (f m) (f n) ‚â§ ‚àë i in finset.Ico m n, dist (f i) (f (i + 1)) :=
begin
  revert n,
  apply nat.le_induction,
  { simp only [finset.sum_empty, finset.Ico_self, dist_self] },
  { assume n hn hrec,
    calc dist (f m) (f (n+1)) ‚â§ dist (f m) (f n) + dist _ _ : dist_triangle _ _ _
      ... ‚â§ ‚àë i in finset.Ico m n, _ + _ : add_le_add hrec le_rfl
      ... = ‚àë i in finset.Ico m (n+1), _ :
        by rw [nat.Ico_succ_right_eq_insert_Ico hn, finset.sum_insert, add_comm]; simp }
end

/-- The triangle (polygon) inequality for sequences of points; `finset.range` version. -/
lemma dist_le_range_sum_dist (f : ‚Ñï ‚Üí Œ±) (n : ‚Ñï) :
  dist (f 0) (f n) ‚â§ ‚àë i in finset.range n, dist (f i) (f (i + 1)) :=
nat.Ico_zero_eq_range ‚ñ∏ dist_le_Ico_sum_dist f (nat.zero_le n)

/-- A version of `dist_le_Ico_sum_dist` with each intermediate distance replaced
with an upper estimate. -/
lemma dist_le_Ico_sum_of_dist_le {f : ‚Ñï ‚Üí Œ±} {m n} (hmn : m ‚â§ n)
  {d : ‚Ñï ‚Üí ‚Ñù} (hd : ‚àÄ {k}, m ‚â§ k ‚Üí k < n ‚Üí dist (f k) (f (k + 1)) ‚â§ d k) :
  dist (f m) (f n) ‚â§ ‚àë i in finset.Ico m n, d i :=
le_trans (dist_le_Ico_sum_dist f hmn) $
finset.sum_le_sum $ Œª k hk, hd (finset.mem_Ico.1 hk).1 (finset.mem_Ico.1 hk).2

/-- A version of `dist_le_range_sum_dist` with each intermediate distance replaced
with an upper estimate. -/
lemma dist_le_range_sum_of_dist_le {f : ‚Ñï ‚Üí Œ±} (n : ‚Ñï)
  {d : ‚Ñï ‚Üí ‚Ñù} (hd : ‚àÄ {k}, k < n ‚Üí dist (f k) (f (k + 1)) ‚â§ d k) :
  dist (f 0) (f n) ‚â§ ‚àë i in finset.range n, d i :=
nat.Ico_zero_eq_range ‚ñ∏ dist_le_Ico_sum_of_dist_le (zero_le n) (Œª _ _, hd)

theorem swap_dist : function.swap (@dist Œ± _) = dist :=
by funext x y; exact dist_comm _ _

theorem abs_dist_sub_le (x y z : Œ±) : |dist x z - dist y z| ‚â§ dist x y :=
abs_sub_le_iff.2
 ‚ü®sub_le_iff_le_add.2 (dist_triangle _ _ _),
  sub_le_iff_le_add.2 (dist_triangle_left _ _ _)‚ü©

theorem dist_nonneg {x y : Œ±} : 0 ‚â§ dist x y :=
pseudo_metric_space.dist_nonneg' dist dist_self dist_comm dist_triangle

@[simp] theorem abs_dist {a b : Œ±} : |dist a b| = dist a b :=
abs_of_nonneg dist_nonneg

/-- A version of `has_dist` that takes value in `‚Ñù‚â•0`. -/
class has_nndist (Œ± : Type*) := (nndist : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0)

export has_nndist (nndist)

/-- Distance as a nonnegative real number. -/
@[priority 100] -- see Note [lower instance priority]
instance pseudo_metric_space.to_has_nndist : has_nndist Œ± := ‚ü®Œª a b, ‚ü®dist a b, dist_nonneg‚ü©‚ü©

/--Express `nndist` in terms of `edist`-/
lemma nndist_edist (x y : Œ±) : nndist x y = (edist x y).to_nnreal :=
by simp [nndist, edist_dist, real.to_nnreal, max_eq_left dist_nonneg, ennreal.of_real]

/--Express `edist` in terms of `nndist`-/
lemma edist_nndist (x y : Œ±) : edist x y = ‚Üë(nndist x y) :=
by { simpa only [edist_dist, ennreal.of_real_eq_coe_nnreal dist_nonneg] }

@[simp, norm_cast] lemma coe_nnreal_ennreal_nndist (x y : Œ±) : ‚Üë(nndist x y) = edist x y :=
(edist_nndist x y).symm

@[simp, norm_cast] lemma edist_lt_coe {x y : Œ±} {c : ‚Ñù‚â•0} :
  edist x y < c ‚Üî nndist x y < c :=
by rw [edist_nndist, ennreal.coe_lt_coe]

@[simp, norm_cast] lemma edist_le_coe {x y : Œ±} {c : ‚Ñù‚â•0} :
  edist x y ‚â§ c ‚Üî nndist x y ‚â§ c :=
by rw [edist_nndist, ennreal.coe_le_coe]

/--In a pseudometric space, the extended distance is always finite-/
lemma edist_lt_top {Œ± : Type*} [pseudo_metric_space Œ±] (x y : Œ±) : edist x y < ‚ä§ :=
(edist_dist x y).symm ‚ñ∏ ennreal.of_real_lt_top

/--In a pseudometric space, the extended distance is always finite-/
lemma edist_ne_top (x y : Œ±) : edist x y ‚â† ‚ä§ := (edist_lt_top x y).ne

/--`nndist x x` vanishes-/
@[simp] lemma nndist_self (a : Œ±) : nndist a a = 0 := (nnreal.coe_eq_zero _).1 (dist_self a)

/--Express `dist` in terms of `nndist`-/
lemma dist_nndist (x y : Œ±) : dist x y = ‚Üë(nndist x y) := rfl

@[simp, norm_cast] lemma coe_nndist (x y : Œ±) : ‚Üë(nndist x y) = dist x y :=
(dist_nndist x y).symm

@[simp, norm_cast] lemma dist_lt_coe {x y : Œ±} {c : ‚Ñù‚â•0} :
  dist x y < c ‚Üî nndist x y < c :=
iff.rfl

@[simp, norm_cast] lemma dist_le_coe {x y : Œ±} {c : ‚Ñù‚â•0} :
  dist x y ‚â§ c ‚Üî nndist x y ‚â§ c :=
iff.rfl

/--Express `nndist` in terms of `dist`-/
lemma nndist_dist (x y : Œ±) : nndist x y = real.to_nnreal (dist x y) :=
by rw [dist_nndist, real.to_nnreal_coe]

theorem nndist_comm (x y : Œ±) : nndist x y = nndist y x :=
by simpa only [dist_nndist, nnreal.coe_eq] using dist_comm x y

/--Triangle inequality for the nonnegative distance-/
theorem nndist_triangle (x y z : Œ±) : nndist x z ‚â§ nndist x y + nndist y z :=
dist_triangle _ _ _

theorem nndist_triangle_left (x y z : Œ±) : nndist x y ‚â§ nndist z x + nndist z y :=
dist_triangle_left _ _ _

theorem nndist_triangle_right (x y z : Œ±) : nndist x y ‚â§ nndist x z + nndist y z :=
dist_triangle_right _ _ _

/--Express `dist` in terms of `edist`-/
lemma dist_edist (x y : Œ±) : dist x y = (edist x y).to_real :=
by rw [edist_dist, ennreal.to_real_of_real (dist_nonneg)]

namespace metric

/- instantiate pseudometric space as a topology -/
variables {x y z : Œ±} {Œµ Œµ‚ÇÅ Œµ‚ÇÇ : ‚Ñù} {s : set Œ±}

/-- `ball x Œµ` is the set of all points `y` with `dist y x < Œµ` -/
def ball (x : Œ±) (Œµ : ‚Ñù) : set Œ± := {y | dist y x < Œµ}

@[simp] theorem mem_ball : y ‚àà ball x Œµ ‚Üî dist y x < Œµ := iff.rfl

theorem mem_ball' : y ‚àà ball x Œµ ‚Üî dist x y < Œµ := by rw dist_comm; refl

theorem pos_of_mem_ball (hy : y ‚àà ball x Œµ) : 0 < Œµ :=
dist_nonneg.trans_lt hy

theorem mem_ball_self (h : 0 < Œµ) : x ‚àà ball x Œµ :=
show dist x x < Œµ, by rw dist_self; assumption

@[simp] lemma nonempty_ball : (ball x Œµ).nonempty ‚Üî 0 < Œµ :=
‚ü®Œª ‚ü®x, hx‚ü©, pos_of_mem_ball hx, Œª h, ‚ü®x, mem_ball_self h‚ü©‚ü©

@[simp] lemma ball_eq_empty : ball x Œµ = ‚àÖ ‚Üî Œµ ‚â§ 0 :=
by rw [‚Üê not_nonempty_iff_eq_empty, nonempty_ball, not_lt]

@[simp] lemma ball_zero : ball x 0 = ‚àÖ :=
by rw [ball_eq_empty]

lemma ball_eq_ball (Œµ : ‚Ñù) (x : Œ±) :
  uniform_space.ball x {p | dist p.2 p.1 < Œµ} = metric.ball x Œµ := rfl

lemma ball_eq_ball' (Œµ : ‚Ñù) (x : Œ±) :
  uniform_space.ball x {p | dist p.1 p.2 < Œµ} = metric.ball x Œµ :=
by { ext, simp [dist_comm, uniform_space.ball] }

@[simp] lemma Union_ball_nat (x : Œ±) : (‚ãÉ n : ‚Ñï, ball x n) = univ :=
Union_eq_univ_iff.2 $ Œª y, exists_nat_gt (dist y x)

@[simp] lemma Union_ball_nat_succ (x : Œ±) : (‚ãÉ n : ‚Ñï, ball x (n + 1)) = univ :=
Union_eq_univ_iff.2 $ Œª y, (exists_nat_gt (dist y x)).imp $ Œª n hn,
  hn.trans (lt_add_one _)

/-- `closed_ball x Œµ` is the set of all points `y` with `dist y x ‚â§ Œµ` -/
def closed_ball (x : Œ±) (Œµ : ‚Ñù) := {y | dist y x ‚â§ Œµ}

@[simp] theorem mem_closed_ball : y ‚àà closed_ball x Œµ ‚Üî dist y x ‚â§ Œµ := iff.rfl

/-- `sphere x Œµ` is the set of all points `y` with `dist y x = Œµ` -/
def sphere (x : Œ±) (Œµ : ‚Ñù) := {y | dist y x = Œµ}

@[simp] theorem mem_sphere : y ‚àà sphere x Œµ ‚Üî dist y x = Œµ := iff.rfl

theorem sphere_eq_empty_of_subsingleton [subsingleton Œ±] (hŒµ : Œµ ‚â† 0) :
  sphere x Œµ = ‚àÖ :=
begin
  refine set.eq_empty_iff_forall_not_mem.mpr (Œª y hy, _),
  rw [mem_sphere, ‚Üêsubsingleton.elim x y, dist_self x] at hy,
  exact hŒµ.symm hy,
end

theorem sphere_is_empty_of_subsingleton [subsingleton Œ±] (hŒµ : Œµ ‚â† 0) :
  is_empty (sphere x Œµ) :=
by simp only [sphere_eq_empty_of_subsingleton hŒµ, set.has_emptyc.emptyc.is_empty Œ±]

theorem mem_closed_ball' : y ‚àà closed_ball x Œµ ‚Üî dist x y ‚â§ Œµ :=
by { rw dist_comm, refl }

theorem mem_closed_ball_self (h : 0 ‚â§ Œµ) : x ‚àà closed_ball x Œµ :=
show dist x x ‚â§ Œµ, by rw dist_self; assumption

@[simp] lemma nonempty_closed_ball : (closed_ball x Œµ).nonempty ‚Üî 0 ‚â§ Œµ :=
‚ü®Œª ‚ü®x, hx‚ü©, dist_nonneg.trans hx, Œª h, ‚ü®x, mem_closed_ball_self h‚ü©‚ü©

@[simp] lemma closed_ball_eq_empty : closed_ball x Œµ = ‚àÖ ‚Üî Œµ < 0 :=
by rw [‚Üê not_nonempty_iff_eq_empty, nonempty_closed_ball, not_le]

theorem ball_subset_closed_ball : ball x Œµ ‚äÜ closed_ball x Œµ :=
assume y (hy : _ < _), le_of_lt hy

theorem sphere_subset_closed_ball : sphere x Œµ ‚äÜ closed_ball x Œµ :=
Œª y, le_of_eq

lemma closed_ball_disjoint_ball (x y : Œ±) (rx ry : ‚Ñù) (h : rx + ry ‚â§ dist x y) :
  disjoint (closed_ball x rx) (ball y ry) :=
begin
  rw disjoint_left,
  intros a ax ay,
  apply lt_irrefl (dist x y),
  calc dist x y ‚â§ dist a x + dist a y : dist_triangle_left _ _ _
  ... < rx + ry : add_lt_add_of_le_of_lt (mem_closed_ball.1 ax) (mem_ball.1 ay)
  ... ‚â§ dist x y : h
end

lemma ball_disjoint_ball (x y : Œ±) (rx ry : ‚Ñù) (h : rx + ry ‚â§ dist x y) :
  disjoint (ball x rx) (ball y ry) :=
(closed_ball_disjoint_ball x y rx ry h).mono_left ball_subset_closed_ball

lemma closed_ball_disjoint_closed_ball {x y : Œ±} {rx ry : ‚Ñù} (h : rx + ry < dist x y) :
  disjoint (closed_ball x rx) (closed_ball y ry) :=
begin
  rw disjoint_left,
  intros a ax ay,
  apply lt_irrefl (dist x y),
  calc dist x y ‚â§ dist a x + dist a y : dist_triangle_left _ _ _
  ... ‚â§ rx + ry : add_le_add ax ay
  ... < dist x y : h
end

theorem sphere_disjoint_ball : disjoint (sphere x Œµ) (ball x Œµ) :=
Œª y ‚ü®hy‚ÇÅ, hy‚ÇÇ‚ü©, absurd hy‚ÇÅ $ ne_of_lt hy‚ÇÇ

@[simp] theorem ball_union_sphere : ball x Œµ ‚à™ sphere x Œµ = closed_ball x Œµ :=
set.ext $ Œª y, (@le_iff_lt_or_eq ‚Ñù _ _ _).symm

@[simp] theorem sphere_union_ball : sphere x Œµ ‚à™ ball x Œµ = closed_ball x Œµ :=
by rw [union_comm, ball_union_sphere]

@[simp] theorem closed_ball_diff_sphere : closed_ball x Œµ \ sphere x Œµ = ball x Œµ :=
by rw [‚Üê ball_union_sphere, set.union_diff_cancel_right sphere_disjoint_ball.symm]

@[simp] theorem closed_ball_diff_ball : closed_ball x Œµ \ ball x Œµ = sphere x Œµ :=
by rw [‚Üê ball_union_sphere, set.union_diff_cancel_left sphere_disjoint_ball.symm]

theorem mem_ball_comm : x ‚àà ball y Œµ ‚Üî y ‚àà ball x Œµ :=
by simp [dist_comm]

theorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=
Œª y (yx : _ < Œµ‚ÇÅ), lt_of_lt_of_le yx h

lemma ball_subset_ball' (h : Œµ‚ÇÅ + dist x y ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball y Œµ‚ÇÇ :=
Œª z hz, calc
  dist z y ‚â§ dist z x + dist x y : dist_triangle _ _ _
  ... < Œµ‚ÇÅ + dist x y : add_lt_add_right hz _
  ... ‚â§ Œµ‚ÇÇ : h

theorem closed_ball_subset_closed_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) :
  closed_ball x Œµ‚ÇÅ ‚äÜ closed_ball x Œµ‚ÇÇ :=
Œª y (yx : _ ‚â§ Œµ‚ÇÅ), le_trans yx h

lemma closed_ball_subset_closed_ball' (h : Œµ‚ÇÅ + dist x y ‚â§ Œµ‚ÇÇ) :
  closed_ball x Œµ‚ÇÅ ‚äÜ closed_ball y Œµ‚ÇÇ :=
Œª z hz, calc
  dist z y ‚â§ dist z x + dist x y : dist_triangle _ _ _
  ... ‚â§ Œµ‚ÇÅ + dist x y : add_le_add_right hz _
  ... ‚â§ Œµ‚ÇÇ : h

theorem closed_ball_subset_ball (h : Œµ‚ÇÅ < Œµ‚ÇÇ) :
  closed_ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=
Œª y (yh : dist y x ‚â§ Œµ‚ÇÅ), lt_of_le_of_lt yh h

lemma dist_le_add_of_nonempty_closed_ball_inter_closed_ball
  (h : (closed_ball x Œµ‚ÇÅ ‚à© closed_ball y Œµ‚ÇÇ).nonempty) :
  dist x y ‚â§ Œµ‚ÇÅ + Œµ‚ÇÇ :=
let ‚ü®z, hz‚ü© := h in calc
  dist x y ‚â§ dist z x + dist z y : dist_triangle_left _ _ _
  ... ‚â§ Œµ‚ÇÅ + Œµ‚ÇÇ : add_le_add hz.1 hz.2

lemma dist_lt_add_of_nonempty_closed_ball_inter_ball (h : (closed_ball x Œµ‚ÇÅ ‚à© ball y Œµ‚ÇÇ).nonempty) :
  dist x y < Œµ‚ÇÅ + Œµ‚ÇÇ :=
let ‚ü®z, hz‚ü© := h in calc
  dist x y ‚â§ dist z x + dist z y : dist_triangle_left _ _ _
  ... < Œµ‚ÇÅ + Œµ‚ÇÇ : add_lt_add_of_le_of_lt hz.1 hz.2

lemma dist_lt_add_of_nonempty_ball_inter_closed_ball (h : (ball x Œµ‚ÇÅ ‚à© closed_ball y Œµ‚ÇÇ).nonempty) :
  dist x y < Œµ‚ÇÅ + Œµ‚ÇÇ :=
begin
  rw inter_comm at h,
  rw [add_comm, dist_comm],
  exact dist_lt_add_of_nonempty_closed_ball_inter_ball h
end

lemma dist_lt_add_of_nonempty_ball_inter_ball (h : (ball x Œµ‚ÇÅ ‚à© ball y Œµ‚ÇÇ).nonempty) :
  dist x y < Œµ‚ÇÅ + Œµ‚ÇÇ :=
dist_lt_add_of_nonempty_closed_ball_inter_ball $
  h.mono (inter_subset_inter ball_subset_closed_ball subset.rfl)

@[simp] lemma Union_closed_ball_nat (x : Œ±) : (‚ãÉ n : ‚Ñï, closed_ball x n) = univ :=
Union_eq_univ_iff.2 $ Œª y, exists_nat_ge (dist y x)

lemma Union_inter_closed_ball_nat (s : set Œ±) (x : Œ±) :
  (‚ãÉ (n : ‚Ñï), s ‚à© closed_ball x n) = s :=
by rw [‚Üê inter_Union, Union_closed_ball_nat, inter_univ]

theorem ball_subset (h : dist x y ‚â§ Œµ‚ÇÇ - Œµ‚ÇÅ) : ball x Œµ‚ÇÅ ‚äÜ ball y Œµ‚ÇÇ :=
Œª z zx, by rw ‚Üê add_sub_cancel'_right Œµ‚ÇÅ Œµ‚ÇÇ; exact
lt_of_le_of_lt (dist_triangle z x y) (add_lt_add_of_lt_of_le zx h)

theorem ball_half_subset (y) (h : y ‚àà ball x (Œµ / 2)) : ball y (Œµ / 2) ‚äÜ ball x Œµ :=
ball_subset $ by rw sub_self_div_two; exact le_of_lt h

theorem exists_ball_subset_ball (h : y ‚àà ball x Œµ) : ‚àÉ Œµ' > 0, ball y Œµ' ‚äÜ ball x Œµ :=
‚ü®_, sub_pos.2 h, ball_subset $ by rw sub_sub_self‚ü©

/-- If a property holds for all points in closed balls of arbitrarily large radii, then it holds for
all points. -/
lemma forall_of_forall_mem_closed_ball (p : Œ± ‚Üí Prop) (x : Œ±)
  (H : ‚àÉ·∂† (R : ‚Ñù) in at_top, ‚àÄ y ‚àà closed_ball x R, p y) (y : Œ±) :
  p y :=
begin
  obtain ‚ü®R, hR, h‚ü© : ‚àÉ (R : ‚Ñù) (H : dist y x ‚â§ R), ‚àÄ (z : Œ±), z ‚àà closed_ball x R ‚Üí p z :=
    frequently_iff.1 H (Ici_mem_at_top (dist y x)),
  exact h _ hR
end

/-- If a property holds for all points in balls of arbitrarily large radii, then it holds for all
points. -/
lemma forall_of_forall_mem_ball (p : Œ± ‚Üí Prop) (x : Œ±)
  (H : ‚àÉ·∂† (R : ‚Ñù) in at_top, ‚àÄ y ‚àà ball x R, p y) (y : Œ±) :
  p y :=
begin
  obtain ‚ü®R, hR, h‚ü© : ‚àÉ (R : ‚Ñù) (H : dist y x < R), ‚àÄ (z : Œ±), z ‚àà ball x R ‚Üí p z :=
    frequently_iff.1 H (Ioi_mem_at_top (dist y x)),
  exact h _ hR
end

theorem uniformity_basis_dist :
  (ùì§ Œ±).has_basis (Œª Œµ : ‚Ñù, 0 < Œµ) (Œª Œµ, {p:Œ±√óŒ± | dist p.1 p.2 < Œµ}) :=
begin
  rw ‚Üê pseudo_metric_space.uniformity_dist.symm,
  refine has_basis_binfi_principal _ nonempty_Ioi,
  exact Œª r (hr : 0 < r) p (hp : 0 < p), ‚ü®min r p, lt_min hr hp,
     Œª x (hx : dist _ _ < _), lt_of_lt_of_le hx (min_le_left r p),
     Œª x (hx : dist _ _ < _), lt_of_lt_of_le hx (min_le_right r p)‚ü©
end

/-- Given `f : Œ≤ ‚Üí ‚Ñù`, if `f` sends `{i | p i}` to a set of positive numbers
accumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `ùì§ Œ±`.

For specific bases see `uniformity_basis_dist`, `uniformity_basis_dist_inv_nat_succ`,
and `uniformity_basis_dist_inv_nat_pos`. -/
protected theorem mk_uniformity_basis {Œ≤ : Type*} {p : Œ≤ ‚Üí Prop} {f : Œ≤ ‚Üí ‚Ñù}
  (hf‚ÇÄ : ‚àÄ i, p i ‚Üí 0 < f i) (hf : ‚àÄ ‚¶ÉŒµ‚¶Ñ, 0 < Œµ ‚Üí ‚àÉ i (hi : p i), f i ‚â§ Œµ) :
  (ùì§ Œ±).has_basis p (Œª i, {p:Œ±√óŒ± | dist p.1 p.2 < f i}) :=
begin
  refine ‚ü®Œª s, uniformity_basis_dist.mem_iff.trans _‚ü©,
  split,
  { rintros ‚ü®Œµ, Œµ‚ÇÄ, hŒµ‚ü©,
    obtain ‚ü®i, hi, H‚ü© : ‚àÉ i (hi : p i), f i ‚â§ Œµ, from hf Œµ‚ÇÄ,
    exact ‚ü®i, hi, Œª x (hx : _ < _), hŒµ $ lt_of_lt_of_le hx H‚ü© },
  { exact Œª ‚ü®i, hi, H‚ü©, ‚ü®f i, hf‚ÇÄ i hi, H‚ü© }
end

theorem uniformity_basis_dist_inv_nat_succ :
  (ùì§ Œ±).has_basis (Œª _, true) (Œª n:‚Ñï, {p:Œ±√óŒ± | dist p.1 p.2 < 1 / (‚Üën+1) }) :=
metric.mk_uniformity_basis (Œª n _, div_pos zero_lt_one $ nat.cast_add_one_pos n)
  (Œª Œµ Œµ0, (exists_nat_one_div_lt Œµ0).imp $ Œª n hn, ‚ü®trivial, le_of_lt hn‚ü©)

theorem uniformity_basis_dist_inv_nat_pos :
  (ùì§ Œ±).has_basis (Œª n:‚Ñï, 0<n) (Œª n:‚Ñï, {p:Œ±√óŒ± | dist p.1 p.2 < 1 / ‚Üën }) :=
metric.mk_uniformity_basis (Œª n hn, div_pos zero_lt_one $ nat.cast_pos.2 hn)
  (Œª Œµ Œµ0, let ‚ü®n, hn‚ü© := exists_nat_one_div_lt Œµ0 in ‚ü®n+1, nat.succ_pos n, hn.le‚ü©)

theorem uniformity_basis_dist_pow {r : ‚Ñù} (h0 : 0 < r) (h1 : r < 1) :
  (ùì§ Œ±).has_basis (Œª n:‚Ñï, true) (Œª n:‚Ñï, {p:Œ±√óŒ± | dist p.1 p.2 < r ^ n }) :=
metric.mk_uniformity_basis (Œª n hn, pow_pos h0 _)
  (Œª Œµ Œµ0, let ‚ü®n, hn‚ü© := exists_pow_lt_of_lt_one Œµ0 h1 in ‚ü®n, trivial, hn.le‚ü©)

theorem uniformity_basis_dist_lt {R : ‚Ñù} (hR : 0 < R) :
  (ùì§ Œ±).has_basis (Œª r : ‚Ñù, 0 < r ‚àß r < R) (Œª r, {p : Œ± √ó Œ± | dist p.1 p.2 < r}) :=
metric.mk_uniformity_basis (Œª r, and.left) $ Œª r hr,
  ‚ü®min r (R / 2), ‚ü®lt_min hr (half_pos hR), min_lt_iff.2 $ or.inr (half_lt_self hR)‚ü©,
    min_le_left _ _‚ü©

/-- Given `f : Œ≤ ‚Üí ‚Ñù`, if `f` sends `{i | p i}` to a set of positive numbers
accumulating to zero, then closed neighborhoods of the diagonal of sizes `{f i | p i}`
form a basis of `ùì§ Œ±`.

Currently we have only one specific basis `uniformity_basis_dist_le` based on this constructor.
More can be easily added if needed in the future. -/
protected theorem mk_uniformity_basis_le {Œ≤ : Type*} {p : Œ≤ ‚Üí Prop} {f : Œ≤ ‚Üí ‚Ñù}
  (hf‚ÇÄ : ‚àÄ x, p x ‚Üí 0 < f x) (hf : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚àÉ x (hx : p x), f x ‚â§ Œµ) :
  (ùì§ Œ±).has_basis p (Œª x, {p:Œ±√óŒ± | dist p.1 p.2 ‚â§ f x}) :=
begin
  refine ‚ü®Œª s, uniformity_basis_dist.mem_iff.trans _‚ü©,
  split,
  { rintros ‚ü®Œµ, Œµ‚ÇÄ, hŒµ‚ü©,
    rcases exists_between Œµ‚ÇÄ with ‚ü®Œµ', hŒµ'‚ü©,
    rcases hf Œµ' hŒµ'.1 with ‚ü®i, hi, H‚ü©,
    exact ‚ü®i, hi, Œª x (hx : _ ‚â§ _), hŒµ $ lt_of_le_of_lt (le_trans hx H) hŒµ'.2‚ü© },
  { exact Œª ‚ü®i, hi, H‚ü©, ‚ü®f i, hf‚ÇÄ i hi, Œª x (hx : _ < _), H (le_of_lt hx)‚ü© }
end

/-- Contant size closed neighborhoods of the diagonal form a basis
of the uniformity filter. -/
theorem uniformity_basis_dist_le :
  (ùì§ Œ±).has_basis (Œª Œµ : ‚Ñù, 0 < Œµ) (Œª Œµ, {p:Œ±√óŒ± | dist p.1 p.2 ‚â§ Œµ}) :=
metric.mk_uniformity_basis_le (Œª _, id) (Œª Œµ Œµ‚ÇÄ, ‚ü®Œµ, Œµ‚ÇÄ, le_refl Œµ‚ü©)

theorem uniformity_basis_dist_le_pow {r : ‚Ñù} (h0 : 0 < r) (h1 : r < 1) :
  (ùì§ Œ±).has_basis (Œª n:‚Ñï, true) (Œª n:‚Ñï, {p:Œ±√óŒ± | dist p.1 p.2 ‚â§ r ^ n }) :=
metric.mk_uniformity_basis_le (Œª n hn, pow_pos h0 _)
  (Œª Œµ Œµ0, let ‚ü®n, hn‚ü© := exists_pow_lt_of_lt_one Œµ0 h1 in ‚ü®n, trivial, hn.le‚ü©)

theorem mem_uniformity_dist {s : set (Œ±√óŒ±)} :
  s ‚àà ùì§ Œ± ‚Üî (‚àÉŒµ>0, ‚àÄ{a b:Œ±}, dist a b < Œµ ‚Üí (a, b) ‚àà s) :=
uniformity_basis_dist.mem_uniformity_iff

/-- A constant size neighborhood of the diagonal is an entourage. -/
theorem dist_mem_uniformity {Œµ:‚Ñù} (Œµ0 : 0 < Œµ) :
  {p:Œ±√óŒ± | dist p.1 p.2 < Œµ} ‚àà ùì§ Œ± :=
mem_uniformity_dist.2 ‚ü®Œµ, Œµ0, Œª a b, id‚ü©

theorem uniform_continuous_iff [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} :
  uniform_continuous f ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0,
    ‚àÄ{a b:Œ±}, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ :=
uniformity_basis_dist.uniform_continuous_iff uniformity_basis_dist

lemma uniform_continuous_on_iff [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} :
  uniform_continuous_on f s ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x y ‚àà s, dist x y < Œ¥ ‚Üí dist (f x) (f y) < Œµ :=
metric.uniformity_basis_dist.uniform_continuous_on_iff metric.uniformity_basis_dist

lemma uniform_continuous_on_iff_le [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} :
  uniform_continuous_on f s ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x y ‚àà s, dist x y ‚â§ Œ¥ ‚Üí dist (f x) (f y) ‚â§ Œµ :=
metric.uniformity_basis_dist_le.uniform_continuous_on_iff metric.uniformity_basis_dist_le

theorem uniform_embedding_iff [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} :
  uniform_embedding f ‚Üî function.injective f ‚àß uniform_continuous f ‚àß
    ‚àÄ Œ¥ > 0, ‚àÉ Œµ > 0, ‚àÄ {a b : Œ±}, dist (f a) (f b) < Œµ ‚Üí dist a b < Œ¥ :=
uniform_embedding_def'.trans $ and_congr iff.rfl $ and_congr iff.rfl
‚ü®Œª H Œ¥ Œ¥0, let ‚ü®t, tu, ht‚ü© := H _ (dist_mem_uniformity Œ¥0),
               ‚ü®Œµ, Œµ0, hŒµ‚ü© := mem_uniformity_dist.1 tu in
  ‚ü®Œµ, Œµ0, Œª a b h, ht _ _ (hŒµ h)‚ü©,
 Œª H s su, let ‚ü®Œ¥, Œ¥0, hŒ¥‚ü© := mem_uniformity_dist.1 su, ‚ü®Œµ, Œµ0, hŒµ‚ü© := H _ Œ¥0 in
  ‚ü®_, dist_mem_uniformity Œµ0, Œª a b h, hŒ¥ (hŒµ h)‚ü©‚ü©

/-- If a map between pseudometric spaces is a uniform embedding then the distance between `f x`
and `f y` is controlled in terms of the distance between `x` and `y`. -/
theorem controlled_of_uniform_embedding [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} :
  uniform_embedding f ‚Üí
  (‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ {a b : Œ±}, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ) ‚àß
  (‚àÄ Œ¥ > 0, ‚àÉ Œµ > 0, ‚àÄ {a b : Œ±}, dist (f a) (f b) < Œµ ‚Üí dist a b < Œ¥) :=
begin
  assume h,
  exact ‚ü®uniform_continuous_iff.1 (uniform_embedding_iff.1 h).2.1, (uniform_embedding_iff.1 h).2.2‚ü©
end

theorem totally_bounded_iff {s : set Œ±} :
  totally_bounded s ‚Üî ‚àÄ Œµ > 0, ‚àÉt : set Œ±, finite t ‚àß s ‚äÜ ‚ãÉy‚ààt, ball y Œµ :=
‚ü®Œª H Œµ Œµ0, H _ (dist_mem_uniformity Œµ0),
 Œª H r ru, let ‚ü®Œµ, Œµ0, hŒµ‚ü© := mem_uniformity_dist.1 ru,
               ‚ü®t, ft, h‚ü© := H Œµ Œµ0 in
  ‚ü®t, ft, h.trans $ Union‚ÇÇ_mono $ Œª y yt z, hŒµ‚ü©‚ü©

/-- A pseudometric space is totally bounded if one can reconstruct up to any Œµ>0 any element of the
space from finitely many data. -/
lemma totally_bounded_of_finite_discretization {s : set Œ±}
  (H : ‚àÄŒµ > (0 : ‚Ñù), ‚àÉ (Œ≤ : Type u) (_ : fintype Œ≤) (F : s ‚Üí Œ≤),
    ‚àÄx y, F x = F y ‚Üí dist (x:Œ±) y < Œµ) :
  totally_bounded s :=
begin
  cases s.eq_empty_or_nonempty with hs hs,
  { rw hs, exact totally_bounded_empty },
  rcases hs with ‚ü®x0, hx0‚ü©,
  haveI : inhabited s := ‚ü®‚ü®x0, hx0‚ü©‚ü©,
  refine totally_bounded_iff.2 (Œª Œµ Œµ0, _),
  rcases H Œµ Œµ0 with ‚ü®Œ≤, fŒ≤, F, hF‚ü©,
  resetI,
  let Finv := function.inv_fun F,
  refine ‚ü®range (subtype.val ‚àò Finv), finite_range _, Œª x xs, _‚ü©,
  let x' := Finv (F ‚ü®x, xs‚ü©),
  have : F x' = F ‚ü®x, xs‚ü© := function.inv_fun_eq ‚ü®‚ü®x, xs‚ü©, rfl‚ü©,
  simp only [set.mem_Union, set.mem_range],
  exact ‚ü®_, ‚ü®F ‚ü®x, xs‚ü©, rfl‚ü©, hF _ _ this.symm‚ü©
end

theorem finite_approx_of_totally_bounded {s : set Œ±} (hs : totally_bounded s) :
  ‚àÄ Œµ > 0, ‚àÉ t ‚äÜ s, finite t ‚àß s ‚äÜ ‚ãÉy‚ààt, ball y Œµ :=
begin
  intros Œµ Œµ_pos,
  rw totally_bounded_iff_subset at hs,
  exact hs _ (dist_mem_uniformity Œµ_pos),
end

/-- Expressing locally uniform convergence on a set using `dist`. -/
lemma tendsto_locally_uniformly_on_iff {Œπ : Type*} [topological_space Œ≤]
  {F : Œπ ‚Üí Œ≤ ‚Üí Œ±} {f : Œ≤ ‚Üí Œ±} {p : filter Œπ} {s : set Œ≤} :
  tendsto_locally_uniformly_on F f p s ‚Üî
  ‚àÄ Œµ > 0, ‚àÄ x ‚àà s, ‚àÉ t ‚àà ùìù[s] x, ‚àÄ·∂† n in p, ‚àÄ y ‚àà t, dist (f y) (F n y) < Œµ :=
begin
  refine ‚ü®Œª H Œµ hŒµ, H _ (dist_mem_uniformity hŒµ), Œª H u hu x hx, _‚ü©,
  rcases mem_uniformity_dist.1 hu with ‚ü®Œµ, Œµpos, hŒµ‚ü©,
  rcases H Œµ Œµpos x hx with ‚ü®t, ht, Ht‚ü©,
  exact ‚ü®t, ht, Ht.mono (Œª n hs x hx, hŒµ (hs x hx))‚ü©
end

/-- Expressing uniform convergence on a set using `dist`. -/
lemma tendsto_uniformly_on_iff {Œπ : Type*}
  {F : Œπ ‚Üí Œ≤ ‚Üí Œ±} {f : Œ≤ ‚Üí Œ±} {p : filter Œπ} {s : set Œ≤} :
  tendsto_uniformly_on F f p s ‚Üî ‚àÄ Œµ > 0, ‚àÄ·∂† n in p, ‚àÄ x ‚àà s, dist (f x) (F n x) < Œµ :=
begin
  refine ‚ü®Œª H Œµ hŒµ, H _ (dist_mem_uniformity hŒµ), Œª H u hu, _‚ü©,
  rcases mem_uniformity_dist.1 hu with ‚ü®Œµ, Œµpos, hŒµ‚ü©,
  exact (H Œµ Œµpos).mono (Œª n hs x hx, hŒµ (hs x hx))
end

/-- Expressing locally uniform convergence using `dist`. -/
lemma tendsto_locally_uniformly_iff {Œπ : Type*} [topological_space Œ≤]
  {F : Œπ ‚Üí Œ≤ ‚Üí Œ±} {f : Œ≤ ‚Üí Œ±} {p : filter Œπ} :
  tendsto_locally_uniformly F f p ‚Üî
  ‚àÄ Œµ > 0, ‚àÄ (x : Œ≤), ‚àÉ t ‚àà ùìù x, ‚àÄ·∂† n in p, ‚àÄ y ‚àà t, dist (f y) (F n y) < Œµ :=
by simp only [‚Üê tendsto_locally_uniformly_on_univ, tendsto_locally_uniformly_on_iff,
  nhds_within_univ, mem_univ, forall_const, exists_prop]

/-- Expressing uniform convergence using `dist`. -/
lemma tendsto_uniformly_iff {Œπ : Type*}
  {F : Œπ ‚Üí Œ≤ ‚Üí Œ±} {f : Œ≤ ‚Üí Œ±} {p : filter Œπ} :
  tendsto_uniformly F f p ‚Üî ‚àÄ Œµ > 0, ‚àÄ·∂† n in p, ‚àÄ x, dist (f x) (F n x) < Œµ :=
by { rw [‚Üê tendsto_uniformly_on_univ, tendsto_uniformly_on_iff], simp }

protected lemma cauchy_iff {f : filter Œ±} :
  cauchy f ‚Üî ne_bot f ‚àß ‚àÄ Œµ > 0, ‚àÉ t ‚àà f, ‚àÄ x y ‚àà t, dist x y < Œµ :=
uniformity_basis_dist.cauchy_iff

theorem nhds_basis_ball : (ùìù x).has_basis (Œª Œµ:‚Ñù, 0 < Œµ) (ball x) :=
nhds_basis_uniformity uniformity_basis_dist

theorem mem_nhds_iff : s ‚àà ùìù x ‚Üî ‚àÉŒµ>0, ball x Œµ ‚äÜ s :=
nhds_basis_ball.mem_iff

theorem eventually_nhds_iff {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂† y in ùìù x, p y) ‚Üî ‚àÉŒµ>0, ‚àÄ ‚¶Éy‚¶Ñ, dist y x < Œµ ‚Üí p y :=
mem_nhds_iff

lemma eventually_nhds_iff_ball {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂† y in ùìù x, p y) ‚Üî ‚àÉ Œµ>0, ‚àÄ y ‚àà ball x Œµ, p y :=
mem_nhds_iff

theorem nhds_basis_closed_ball : (ùìù x).has_basis (Œª Œµ:‚Ñù, 0 < Œµ) (closed_ball x) :=
nhds_basis_uniformity uniformity_basis_dist_le

theorem nhds_basis_ball_inv_nat_succ :
  (ùìù x).has_basis (Œª _, true) (Œª n:‚Ñï, ball x (1 / (‚Üën+1))) :=
nhds_basis_uniformity uniformity_basis_dist_inv_nat_succ

theorem nhds_basis_ball_inv_nat_pos :
  (ùìù x).has_basis (Œª n, 0<n) (Œª n:‚Ñï, ball x (1 / ‚Üën)) :=
nhds_basis_uniformity uniformity_basis_dist_inv_nat_pos

theorem nhds_basis_ball_pow {r : ‚Ñù} (h0 : 0 < r) (h1 : r < 1) :
  (ùìù x).has_basis (Œª n, true) (Œª n:‚Ñï, ball x (r ^ n)) :=
nhds_basis_uniformity (uniformity_basis_dist_pow h0 h1)

theorem nhds_basis_closed_ball_pow {r : ‚Ñù} (h0 : 0 < r) (h1 : r < 1) :
  (ùìù x).has_basis (Œª n, true) (Œª n:‚Ñï, closed_ball x (r ^ n)) :=
nhds_basis_uniformity (uniformity_basis_dist_le_pow h0 h1)

theorem is_open_iff : is_open s ‚Üî ‚àÄx‚ààs, ‚àÉŒµ>0, ball x Œµ ‚äÜ s :=
by simp only [is_open_iff_mem_nhds, mem_nhds_iff]

theorem is_open_ball : is_open (ball x Œµ) :=
is_open_iff.2 $ Œª y, exists_ball_subset_ball

theorem ball_mem_nhds (x : Œ±) {Œµ : ‚Ñù} (Œµ0 : 0 < Œµ) : ball x Œµ ‚àà ùìù x :=
is_open_ball.mem_nhds (mem_ball_self Œµ0)

theorem closed_ball_mem_nhds (x : Œ±) {Œµ : ‚Ñù} (Œµ0 : 0 < Œµ) : closed_ball x Œµ ‚àà ùìù x :=
mem_of_superset (ball_mem_nhds x Œµ0) ball_subset_closed_ball

theorem closed_ball_mem_nhds_of_mem {x c : Œ±} {Œµ : ‚Ñù} (h : x ‚àà ball c Œµ) :
  closed_ball c Œµ ‚àà ùìù x :=
mem_of_superset (is_open_ball.mem_nhds h) ball_subset_closed_ball

theorem nhds_within_basis_ball {s : set Œ±} :
  (ùìù[s] x).has_basis (Œª Œµ:‚Ñù, 0 < Œµ) (Œª Œµ, ball x Œµ ‚à© s) :=
nhds_within_has_basis nhds_basis_ball s

theorem mem_nhds_within_iff {t : set Œ±} : s ‚àà ùìù[t] x ‚Üî ‚àÉŒµ>0, ball x Œµ ‚à© t ‚äÜ s :=
nhds_within_basis_ball.mem_iff

theorem tendsto_nhds_within_nhds_within [pseudo_metric_space Œ≤] {t : set Œ≤} {f : Œ± ‚Üí Œ≤} {a b} :
  tendsto f (ùìù[s] a) (ùìù[t] b) ‚Üî
    ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ{x:Œ±}, x ‚àà s ‚Üí dist x a < Œ¥ ‚Üí f x ‚àà t ‚àß dist (f x) b < Œµ :=
(nhds_within_basis_ball.tendsto_iff nhds_within_basis_ball).trans $
  forall‚ÇÇ_congr $ Œª Œµ hŒµ, exists‚ÇÇ_congr $ Œª Œ¥ hŒ¥,
  forall_congr $ Œª x, by simp; itauto

theorem tendsto_nhds_within_nhds [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} {a b} :
  tendsto f (ùìù[s] a) (ùìù b) ‚Üî
    ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ{x:Œ±}, x ‚àà s ‚Üí dist x a < Œ¥ ‚Üí dist (f x) b < Œµ :=
by { rw [‚Üê nhds_within_univ b, tendsto_nhds_within_nhds_within],
  simp only [mem_univ, true_and] }

theorem tendsto_nhds_nhds [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} {a b} :
  tendsto f (ùìù a) (ùìù b) ‚Üî
    ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ{x:Œ±}, dist x a < Œ¥ ‚Üí dist (f x) b < Œµ :=
nhds_basis_ball.tendsto_iff nhds_basis_ball

theorem continuous_at_iff [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} {a : Œ±} :
  continuous_at f a ‚Üî
    ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ{x:Œ±}, dist x a < Œ¥ ‚Üí dist (f x) (f a) < Œµ :=
by rw [continuous_at, tendsto_nhds_nhds]

theorem continuous_within_at_iff [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} {a : Œ±} {s : set Œ±} :
  continuous_within_at f s a ‚Üî
  ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ{x:Œ±}, x ‚àà s ‚Üí dist x a < Œ¥ ‚Üí dist (f x) (f a) < Œµ :=
by rw [continuous_within_at, tendsto_nhds_within_nhds]

theorem continuous_on_iff [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} :
  continuous_on f s ‚Üî
  ‚àÄ (b ‚àà s) (Œµ > 0), ‚àÉ Œ¥ > 0, ‚àÄa ‚àà s, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ :=
by simp [continuous_on, continuous_within_at_iff]

theorem continuous_iff [pseudo_metric_space Œ≤] {f : Œ± ‚Üí Œ≤} :
  continuous f ‚Üî
  ‚àÄb (Œµ > 0), ‚àÉ Œ¥ > 0, ‚àÄa, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ :=
continuous_iff_continuous_at.trans $ forall_congr $ Œª b, tendsto_nhds_nhds

theorem tendsto_nhds {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} :
  tendsto u f (ùìù a) ‚Üî ‚àÄ Œµ > 0, ‚àÄ·∂† x in f, dist (u x) a < Œµ :=
nhds_basis_ball.tendsto_right_iff

theorem continuous_at_iff' [topological_space Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} :
  continuous_at f b ‚Üî
  ‚àÄ Œµ > 0, ‚àÄ·∂† x in ùìù b, dist (f x) (f b) < Œµ :=
by rw [continuous_at, tendsto_nhds]

theorem continuous_within_at_iff' [topological_space Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} {s : set Œ≤} :
  continuous_within_at f s b ‚Üî
  ‚àÄ Œµ > 0, ‚àÄ·∂† x in ùìù[s] b, dist (f x) (f b) < Œµ :=
by rw [continuous_within_at, tendsto_nhds]

theorem continuous_on_iff' [topological_space Œ≤] {f : Œ≤ ‚Üí Œ±} {s : set Œ≤} :
  continuous_on f s ‚Üî
  ‚àÄ (b ‚àà s) (Œµ > 0), ‚àÄ·∂† x in ùìù[s] b, dist (f x) (f b) < Œµ  :=
by simp [continuous_on, continuous_within_at_iff']

theorem continuous_iff' [topological_space Œ≤] {f : Œ≤ ‚Üí Œ±} :
  continuous f ‚Üî ‚àÄa (Œµ > 0), ‚àÄ·∂† x in ùìù a, dist (f x) (f a) < Œµ :=
continuous_iff_continuous_at.trans $ forall_congr $ Œª b, tendsto_nhds

theorem tendsto_at_top [nonempty Œ≤] [semilattice_sup Œ≤] {u : Œ≤ ‚Üí Œ±} {a : Œ±} :
  tendsto u at_top (ùìù a) ‚Üî ‚àÄŒµ>0, ‚àÉN, ‚àÄn‚â•N, dist (u n) a < Œµ :=
(at_top_basis.tendsto_iff nhds_basis_ball).trans $
  by { simp only [exists_prop, true_and], refl }

/--
A variant of `tendsto_at_top` that
uses `‚àÉ N, ‚àÄ n > N, ...` rather than `‚àÉ N, ‚àÄ n ‚â• N, ...`
-/
theorem tendsto_at_top' [nonempty Œ≤] [semilattice_sup Œ≤] [no_max_order Œ≤] {u : Œ≤ ‚Üí Œ±} {a : Œ±} :
  tendsto u at_top (ùìù a) ‚Üî ‚àÄŒµ>0, ‚àÉN, ‚àÄn>N, dist (u n) a < Œµ :=
(at_top_basis_Ioi.tendsto_iff nhds_basis_ball).trans $
  by { simp only [exists_prop, true_and], refl }

lemma is_open_singleton_iff {Œ± : Type*} [pseudo_metric_space Œ±] {x : Œ±} :
  is_open ({x} : set Œ±) ‚Üî ‚àÉ Œµ > 0, ‚àÄ y, dist y x < Œµ ‚Üí y = x :=
by simp [is_open_iff, subset_singleton_iff, mem_ball]

/-- Given a point `x` in a discrete subset `s` of a pseudometric space, there is an open ball
centered at `x` and intersecting `s` only at `x`. -/
lemma exists_ball_inter_eq_singleton_of_mem_discrete [discrete_topology s] {x : Œ±} (hx : x ‚àà s) :
  ‚àÉ Œµ > 0, metric.ball x Œµ ‚à© s = {x} :=
nhds_basis_ball.exists_inter_eq_singleton_of_mem_discrete hx

/-- Given a point `x` in a discrete subset `s` of a pseudometric space, there is a closed ball
of positive radius centered at `x` and intersecting `s` only at `x`. -/
lemma exists_closed_ball_inter_eq_singleton_of_discrete [discrete_topology s] {x : Œ±} (hx : x ‚àà s) :
  ‚àÉ Œµ > 0, metric.closed_ball x Œµ ‚à© s = {x} :=
nhds_basis_closed_ball.exists_inter_eq_singleton_of_mem_discrete hx

end metric

open metric

/-Instantiate a pseudometric space as a pseudoemetric space. Before we can state the instance,
we need to show that the uniform structure coming from the edistance and the
distance coincide. -/

/-- Expressing the uniformity in terms of `edist` -/
protected lemma pseudo_metric.uniformity_basis_edist :
  (ùì§ Œ±).has_basis (Œª Œµ:‚Ñù‚â•0‚àû, 0 < Œµ) (Œª Œµ, {p | edist p.1 p.2 < Œµ}) :=
‚ü®begin
  intro t,
  refine mem_uniformity_dist.trans ‚ü®_, _‚ü©; rintro ‚ü®Œµ, Œµ0, HŒµ‚ü©,
  { use [ennreal.of_real Œµ, ennreal.of_real_pos.2 Œµ0],
    rintros ‚ü®a, b‚ü©,
    simp only [edist_dist, ennreal.of_real_lt_of_real_iff Œµ0],
    exact HŒµ },
  { rcases ennreal.lt_iff_exists_real_btwn.1 Œµ0 with ‚ü®Œµ', _, Œµ0', hŒµ‚ü©,
    rw [ennreal.of_real_pos] at Œµ0',
    refine ‚ü®Œµ', Œµ0', Œª a b h, HŒµ (lt_trans _ hŒµ)‚ü©,
    rwa [edist_dist, ennreal.of_real_lt_of_real_iff Œµ0'] }
end‚ü©

theorem metric.uniformity_edist : ùì§ Œ± = (‚®Ö Œµ>0, ùìü {p:Œ±√óŒ± | edist p.1 p.2 < Œµ}) :=
pseudo_metric.uniformity_basis_edist.eq_binfi

/-- A pseudometric space induces a pseudoemetric space -/
@[priority 100] -- see Note [lower instance priority]
instance pseudo_metric_space.to_pseudo_emetric_space : pseudo_emetric_space Œ± :=
{ edist               := edist,
  edist_self          := by simp [edist_dist],
  edist_comm          := by simp only [edist_dist, dist_comm]; simp,
  edist_triangle      := assume x y z, begin
    simp only [edist_dist, ‚Üê ennreal.of_real_add, dist_nonneg],
    rw ennreal.of_real_le_of_real_iff _,
    { exact dist_triangle _ _ _ },
    { simpa using add_le_add (dist_nonneg : 0 ‚â§ dist x y) dist_nonneg }
  end,
  uniformity_edist    := metric.uniformity_edist,
  ..‚Äπpseudo_metric_space Œ±‚Ä∫ }

/-- In a pseudometric space, an open ball of infinite radius is the whole space -/
lemma metric.eball_top_eq_univ (x : Œ±) :
  emetric.ball x ‚àû = set.univ :=
set.eq_univ_iff_forall.mpr (Œª y, edist_lt_top y x)

/-- Balls defined using the distance or the edistance coincide -/
@[simp] lemma metric.emetric_ball {x : Œ±} {Œµ : ‚Ñù} : emetric.ball x (ennreal.of_real Œµ) = ball x Œµ :=
begin
  ext y,
  simp only [emetric.mem_ball, mem_ball, edist_dist],
  exact ennreal.of_real_lt_of_real_iff_of_nonneg dist_nonneg
end

/-- Balls defined using the distance or the edistance coincide -/
@[simp] lemma metric.emetric_ball_nnreal {x : Œ±} {Œµ : ‚Ñù‚â•0} : emetric.ball x Œµ = ball x Œµ :=
by { convert metric.emetric_ball, simp }

/-- Closed balls defined using the distance or the edistance coincide -/
lemma metric.emetric_closed_ball {x : Œ±} {Œµ : ‚Ñù} (h : 0 ‚â§ Œµ) :
  emetric.closed_ball x (ennreal.of_real Œµ) = closed_ball x Œµ :=
by ext y; simp [edist_dist]; rw ennreal.of_real_le_of_real_iff h

/-- Closed balls defined using the distance or the edistance coincide -/
@[simp] lemma metric.emetric_closed_ball_nnreal {x : Œ±} {Œµ : ‚Ñù‚â•0} :
  emetric.closed_ball x Œµ = closed_ball x Œµ :=
by { convert metric.emetric_closed_ball Œµ.2, simp }

@[simp] lemma metric.emetric_ball_top (x : Œ±) : emetric.ball x ‚ä§ = univ :=
eq_univ_of_forall $ Œª y, edist_lt_top _ _

/-- Build a new pseudometric space from an old one where the bundled uniform structure is provably
(but typically non-definitionaly) equal to some given uniform structure.
See Note [forgetful inheritance].
-/
def pseudo_metric_space.replace_uniformity {Œ±} [U : uniform_space Œ±] (m : pseudo_metric_space Œ±)
  (H : @uniformity _ U = @uniformity _ pseudo_emetric_space.to_uniform_space') :
  pseudo_metric_space Œ± :=
{ dist               := @dist _ m.to_has_dist,
  dist_self          := dist_self,
  dist_comm          := dist_comm,
  dist_triangle      := dist_triangle,
  edist              := edist,
  edist_dist         := edist_dist,
  to_uniform_space   := U,
  uniformity_dist    := H.trans pseudo_metric_space.uniformity_dist }

/-- One gets a pseudometric space from an emetric space if the edistance
is everywhere finite, by pushing the edistance to reals. We set it up so that the edist and the
uniformity are defeq in the pseudometric space and the pseudoemetric space. In this definition, the
distance is given separately, to be able to prescribe some expression which is not defeq to the
push-forward of the edistance to reals. -/
def pseudo_emetric_space.to_pseudo_metric_space_of_dist {Œ± : Type u} [e : pseudo_emetric_space Œ±]
  (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)
  (edist_ne_top : ‚àÄx y: Œ±, edist x y ‚â† ‚ä§)
  (h : ‚àÄx y, dist x y = ennreal.to_real (edist x y)) :
  pseudo_metric_space Œ± :=
let m : pseudo_metric_space Œ± :=
{ dist := dist,
  dist_self          := Œªx, by simp [h],
  dist_comm          := Œªx y, by simp [h, pseudo_emetric_space.edist_comm],
  dist_triangle      := Œªx y z, begin
    simp only [h],
    rw [‚Üê ennreal.to_real_add (edist_ne_top _ _) (edist_ne_top _ _),
        ennreal.to_real_le_to_real (edist_ne_top _ _)],
    { exact edist_triangle _ _ _ },
    { simp [ennreal.add_eq_top, edist_ne_top] }
  end,
  edist := Œªx y, edist x y,
  edist_dist := Œªx y, by simp [h, ennreal.of_real_to_real, edist_ne_top] } in
m.replace_uniformity $ by { rw [uniformity_pseudoedist, metric.uniformity_edist], refl }

/-- One gets a pseudometric space from an emetric space if the edistance
is everywhere finite, by pushing the edistance to reals. We set it up so that the edist and the
uniformity are defeq in the pseudometric space and the emetric space. -/
def pseudo_emetric_space.to_pseudo_metric_space {Œ± : Type u} [e : pseudo_emetric_space Œ±]
  (h : ‚àÄx y: Œ±, edist x y ‚â† ‚ä§) : pseudo_metric_space Œ± :=
pseudo_emetric_space.to_pseudo_metric_space_of_dist
  (Œªx y, ennreal.to_real (edist x y)) h (Œªx y, rfl)

/-- A very useful criterion to show that a space is complete is to show that all sequences
which satisfy a bound of the form `dist (u n) (u m) < B N` for all `n m ‚â• N` are
converging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to
`0`, which makes it possible to use arguments of converging series, while this is impossible
to do in general for arbitrary Cauchy sequences. -/
theorem metric.complete_of_convergent_controlled_sequences (B : ‚Ñï ‚Üí real) (hB : ‚àÄn, 0 < B n)
  (H : ‚àÄu : ‚Ñï ‚Üí Œ±, (‚àÄN n m : ‚Ñï, N ‚â§ n ‚Üí N ‚â§ m ‚Üí dist (u n) (u m) < B N) ‚Üí
    ‚àÉx, tendsto u at_top (ùìù x)) :
  complete_space Œ± :=
begin
  -- this follows from the same criterion in emetric spaces. We just need to translate
  -- the convergence assumption from `dist` to `edist`
  apply emetric.complete_of_convergent_controlled_sequences (Œªn, ennreal.of_real (B n)),
  { simp [hB] },
  { assume u Hu,
    apply H,
    assume N n m hn hm,
    rw [‚Üê ennreal.of_real_lt_of_real_iff (hB N), ‚Üê edist_dist],
    exact Hu N n m hn hm }
end

theorem metric.complete_of_cauchy_seq_tendsto :
  (‚àÄ u : ‚Ñï ‚Üí Œ±, cauchy_seq u ‚Üí ‚àÉa, tendsto u at_top (ùìù a)) ‚Üí complete_space Œ± :=
emetric.complete_of_cauchy_seq_tendsto

section real

/-- Instantiate the reals as a pseudometric space. -/
noncomputable instance real.pseudo_metric_space : pseudo_metric_space ‚Ñù :=
{ dist               := Œªx y, |x - y|,
  dist_self          := by simp [abs_zero],
  dist_comm          := assume x y, abs_sub_comm _ _,
  dist_triangle      := assume x y z, abs_sub_le _ _ _ }

theorem real.dist_eq (x y : ‚Ñù) : dist x y = |x - y| := rfl

theorem real.nndist_eq (x y : ‚Ñù) : nndist x y = real.nnabs (x - y) := rfl

theorem real.nndist_eq' (x y : ‚Ñù) : nndist x y = real.nnabs (y - x) := nndist_comm _ _

theorem real.dist_0_eq_abs (x : ‚Ñù) : dist x 0 = |x| :=
by simp [real.dist_eq]

theorem real.dist_left_le_of_mem_interval {x y z : ‚Ñù} (h : y ‚àà interval x z) :
  dist x y ‚â§ dist x z :=
by simpa only [dist_comm x] using abs_sub_left_of_mem_interval h

theorem real.dist_right_le_of_mem_interval {x y z : ‚Ñù} (h : y ‚àà interval x z) :
  dist y z ‚â§ dist x z :=
by simpa only [dist_comm _ z] using abs_sub_right_of_mem_interval h

theorem real.dist_le_of_mem_interval {x y x' y' : ‚Ñù} (hx : x ‚àà interval x' y')
  (hy : y ‚àà interval x' y') : dist x y ‚â§ dist x' y' :=
abs_sub_le_of_subinterval $ interval_subset_interval (by rwa interval_swap) (by rwa interval_swap)

theorem real.dist_le_of_mem_Icc {x y x' y' : ‚Ñù} (hx : x ‚àà Icc x' y') (hy : y ‚àà Icc x' y') :
  dist x y ‚â§ y' - x' :=
by simpa only [real.dist_eq, abs_of_nonpos (sub_nonpos.2 $ hx.1.trans hx.2), neg_sub]
  using real.dist_le_of_mem_interval (Icc_subset_interval hx) (Icc_subset_interval hy)

theorem real.dist_le_of_mem_Icc_01 {x y : ‚Ñù} (hx : x ‚àà Icc (0:‚Ñù) 1) (hy : y ‚àà Icc (0:‚Ñù) 1) :
  dist x y ‚â§ 1 :=
by simpa only [sub_zero] using real.dist_le_of_mem_Icc hx hy

instance : order_topology ‚Ñù :=
order_topology_of_nhds_abs $ Œª x,
  by simp only [nhds_basis_ball.eq_binfi, ball, real.dist_eq, abs_sub_comm]

lemma real.ball_eq_Ioo (x r : ‚Ñù) : ball x r = Ioo (x - r) (x + r) :=
set.ext $ Œª y, by rw [mem_ball, dist_comm, real.dist_eq,
  abs_sub_lt_iff, mem_Ioo, ‚Üê sub_lt_iff_lt_add', sub_lt]

lemma real.closed_ball_eq_Icc {x r : ‚Ñù} : closed_ball x r = Icc (x - r) (x + r) :=
by ext y; rw [mem_closed_ball, dist_comm, real.dist_eq,
  abs_sub_le_iff, mem_Icc, ‚Üê sub_le_iff_le_add', sub_le]

theorem real.Ioo_eq_ball (x y : ‚Ñù) : Ioo x y = ball ((x + y) / 2) ((y - x) / 2) :=
by rw [real.ball_eq_Ioo, ‚Üê sub_div, add_comm, ‚Üê sub_add,
  add_sub_cancel', add_self_div_two, ‚Üê add_div,
  add_assoc, add_sub_cancel'_right, add_self_div_two]

theorem real.Icc_eq_closed_ball (x y : ‚Ñù) : Icc x y = closed_ball ((x + y) / 2) ((y - x) / 2) :=
by rw [real.closed_ball_eq_Icc, ‚Üê sub_div, add_comm, ‚Üê sub_add,
  add_sub_cancel', add_self_div_two, ‚Üê add_div,
  add_assoc, add_sub_cancel'_right, add_self_div_two]

section metric_ordered

variables [preorder Œ±] [compact_Icc_space Œ±]

lemma totally_bounded_Icc (a b : Œ±) : totally_bounded (Icc a b) :=
is_compact_Icc.totally_bounded

lemma totally_bounded_Ico (a b : Œ±) : totally_bounded (Ico a b) :=
totally_bounded_subset Ico_subset_Icc_self (totally_bounded_Icc a b)

lemma totally_bounded_Ioc (a b : Œ±) : totally_bounded (Ioc a b) :=
totally_bounded_subset Ioc_subset_Icc_self (totally_bounded_Icc a b)

lemma totally_bounded_Ioo (a b : Œ±) : totally_bounded (Ioo a b) :=
totally_bounded_subset Ioo_subset_Icc_self (totally_bounded_Icc a b)

end metric_ordered

/-- Special case of the sandwich theorem; see `tendsto_of_tendsto_of_tendsto_of_le_of_le'` for the
general case. -/
lemma squeeze_zero' {Œ±} {f g : Œ± ‚Üí ‚Ñù} {t‚ÇÄ : filter Œ±} (hf : ‚àÄ·∂† t in t‚ÇÄ, 0 ‚â§ f t)
  (hft : ‚àÄ·∂† t in t‚ÇÄ, f t ‚â§ g t) (g0 : tendsto g t‚ÇÄ (nhds 0)) : tendsto f t‚ÇÄ (ùìù 0) :=
tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds g0 hf hft

/-- Special case of the sandwich theorem; see `tendsto_of_tendsto_of_tendsto_of_le_of_le`
and  `tendsto_of_tendsto_of_tendsto_of_le_of_le'` for the general case. -/
lemma squeeze_zero {Œ±} {f g : Œ± ‚Üí ‚Ñù} {t‚ÇÄ : filter Œ±} (hf : ‚àÄt, 0 ‚â§ f t) (hft : ‚àÄt, f t ‚â§ g t)
  (g0 : tendsto g t‚ÇÄ (ùìù 0)) : tendsto f t‚ÇÄ (ùìù 0) :=
squeeze_zero' (eventually_of_forall hf) (eventually_of_forall hft) g0

theorem metric.uniformity_eq_comap_nhds_zero :
  ùì§ Œ± = comap (Œªp:Œ±√óŒ±, dist p.1 p.2) (ùìù (0 : ‚Ñù)) :=
by { ext s,
  simp [mem_uniformity_dist, (nhds_basis_ball.comap _).mem_iff, subset_def, real.dist_0_eq_abs] }

lemma cauchy_seq_iff_tendsto_dist_at_top_0 [nonempty Œ≤] [semilattice_sup Œ≤] {u : Œ≤ ‚Üí Œ±} :
  cauchy_seq u ‚Üî tendsto (Œª (n : Œ≤ √ó Œ≤), dist (u n.1) (u n.2)) at_top (ùìù 0) :=
by rw [cauchy_seq_iff_tendsto, metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff,
  prod.map_def]

lemma tendsto_uniformity_iff_dist_tendsto_zero {Œπ : Type*} {f : Œπ ‚Üí Œ± √ó Œ±} {p : filter Œπ} :
  tendsto f p (ùì§ Œ±) ‚Üî tendsto (Œª x, dist (f x).1 (f x).2) p (ùìù 0) :=
by rw [metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff]

lemma filter.tendsto.congr_dist {Œπ : Type*} {f‚ÇÅ f‚ÇÇ : Œπ ‚Üí Œ±} {p : filter Œπ} {a : Œ±}
  (h‚ÇÅ : tendsto f‚ÇÅ p (ùìù a)) (h : tendsto (Œª x, dist (f‚ÇÅ x) (f‚ÇÇ x)) p (ùìù 0)) :
  tendsto f‚ÇÇ p (ùìù a) :=
h‚ÇÅ.congr_uniformity $ tendsto_uniformity_iff_dist_tendsto_zero.2 h

alias filter.tendsto.congr_dist ‚Üê  tendsto_of_tendsto_of_dist

lemma tendsto_iff_of_dist {Œπ : Type*} {f‚ÇÅ f‚ÇÇ : Œπ ‚Üí Œ±} {p : filter Œπ} {a : Œ±}
  (h : tendsto (Œª x, dist (f‚ÇÅ x) (f‚ÇÇ x)) p (ùìù 0)) :
  tendsto f‚ÇÅ p (ùìù a) ‚Üî tendsto f‚ÇÇ p (ùìù a) :=
uniform.tendsto_congr $ tendsto_uniformity_iff_dist_tendsto_zero.2 h

/-- If `u` is a neighborhood of `x`, then for small enough `r`, the closed ball
`closed_ball x r` is contained in `u`. -/
lemma eventually_closed_ball_subset {x : Œ±} {u : set Œ±} (hu : u ‚àà ùìù x) :
  ‚àÄ·∂† r in ùìù (0 : ‚Ñù), closed_ball x r ‚äÜ u :=
begin
  obtain ‚ü®Œµ, Œµpos, hŒµ‚ü© : ‚àÉ Œµ (hŒµ : 0 < Œµ), closed_ball x Œµ ‚äÜ u :=
    nhds_basis_closed_ball.mem_iff.1 hu,
  have : Iic Œµ ‚àà ùìù (0 : ‚Ñù) := Iic_mem_nhds Œµpos,
  filter_upwards [this] with _ hr using subset.trans (closed_ball_subset_closed_ball hr) hŒµ,
end

end real

section cauchy_seq
variables [nonempty Œ≤] [semilattice_sup Œ≤]

/-- In a pseudometric space, Cauchy sequences are characterized by the fact that, eventually,
the distance between its elements is arbitrarily small -/
@[nolint ge_or_gt] -- see Note [nolint_ge]
theorem metric.cauchy_seq_iff {u : Œ≤ ‚Üí Œ±} :
  cauchy_seq u ‚Üî ‚àÄŒµ>0, ‚àÉN, ‚àÄm n‚â•N, dist (u m) (u n) < Œµ :=
uniformity_basis_dist.cauchy_seq_iff

/-- A variation around the pseudometric characterization of Cauchy sequences -/
theorem metric.cauchy_seq_iff' {u : Œ≤ ‚Üí Œ±} :
  cauchy_seq u ‚Üî ‚àÄŒµ>0, ‚àÉN, ‚àÄn‚â•N, dist (u n) (u N) < Œµ :=
uniformity_basis_dist.cauchy_seq_iff'

/-- If the distance between `s n` and `s m`, `n, m ‚â• N` is bounded above by `b N`
and `b` converges to zero, then `s` is a Cauchy sequence.  -/
lemma cauchy_seq_of_le_tendsto_0 {s : Œ≤ ‚Üí Œ±} (b : Œ≤ ‚Üí ‚Ñù)
  (h : ‚àÄ n m N : Œ≤, N ‚â§ n ‚Üí N ‚â§ m ‚Üí dist (s n) (s m) ‚â§ b N) (h‚ÇÄ : tendsto b at_top (nhds 0)) :
  cauchy_seq s :=
metric.cauchy_seq_iff.2 $ Œª Œµ Œµ0,
  (metric.tendsto_at_top.1 h‚ÇÄ Œµ Œµ0).imp $ Œª N hN m hm n hn,
  calc dist (s m) (s n) ‚â§ b N : h m n N hm hn
                    ... ‚â§ |b N| : le_abs_self _
                    ... = dist (b N) 0 : by rw real.dist_0_eq_abs; refl
                    ... < Œµ : (hN _ (le_refl N))

/-- A Cauchy sequence on the natural numbers is bounded. -/
theorem cauchy_seq_bdd {u : ‚Ñï ‚Üí Œ±} (hu : cauchy_seq u) :
  ‚àÉ R > 0, ‚àÄ m n, dist (u m) (u n) < R :=
begin
  rcases metric.cauchy_seq_iff'.1 hu 1 zero_lt_one with ‚ü®N, hN‚ü©,
  suffices : ‚àÉ R > 0, ‚àÄ n, dist (u n) (u N) < R,
  { rcases this with ‚ü®R, R0, H‚ü©,
    exact ‚ü®_, add_pos R0 R0, Œª m n,
      lt_of_le_of_lt (dist_triangle_right _ _ _) (add_lt_add (H m) (H n))‚ü© },
  let R := finset.sup (finset.range N) (Œª n, nndist (u n) (u N)),
  refine ‚ü®‚ÜëR + 1, add_pos_of_nonneg_of_pos R.2 zero_lt_one, Œª n, _‚ü©,
  cases le_or_lt N n,
  { exact lt_of_lt_of_le (hN _ h) (le_add_of_nonneg_left R.2) },
  { have : _ ‚â§ R := finset.le_sup (finset.mem_range.2 h),
    exact lt_of_le_of_lt this (lt_add_of_pos_right _ zero_lt_one) }
end

/-- Yet another metric characterization of Cauchy sequences on integers. This one is often the
most efficient. -/
lemma cauchy_seq_iff_le_tendsto_0 {s : ‚Ñï ‚Üí Œ±} : cauchy_seq s ‚Üî ‚àÉ b : ‚Ñï ‚Üí ‚Ñù,
  (‚àÄ n, 0 ‚â§ b n) ‚àß
  (‚àÄ n m N : ‚Ñï, N ‚â§ n ‚Üí N ‚â§ m ‚Üí dist (s n) (s m) ‚â§ b N) ‚àß
  tendsto b at_top (ùìù 0) :=
‚ü®Œª hs, begin
  /- `s` is a Cauchy sequence. The sequence `b` will be constructed by taking
  the supremum of the distances between `s n` and `s m` for `n m ‚â• N`.
  First, we prove that all these distances are bounded, as otherwise the Sup
  would not make sense. -/
  let S := Œª N, (Œª(p : ‚Ñï √ó ‚Ñï), dist (s p.1) (s p.2)) '' {p | p.1 ‚â• N ‚àß p.2 ‚â• N},
  have hS : ‚àÄ N, ‚àÉ x, ‚àÄ y ‚àà S N, y ‚â§ x,
  { rcases cauchy_seq_bdd hs with ‚ü®R, R0, hR‚ü©,
    refine Œª N, ‚ü®R, _‚ü©, rintro _ ‚ü®‚ü®m, n‚ü©, _, rfl‚ü©,
    exact le_of_lt (hR m n) },
  have bdd : bdd_above (range (Œª(p : ‚Ñï √ó ‚Ñï), dist (s p.1) (s p.2))),
  { rcases cauchy_seq_bdd hs with ‚ü®R, R0, hR‚ü©,
    use R, rintro _ ‚ü®‚ü®m, n‚ü©, rfl‚ü©, exact le_of_lt (hR m n) },
  -- Prove that it bounds the distances of points in the Cauchy sequence
  have ub : ‚àÄ m n N, N ‚â§ m ‚Üí N ‚â§ n ‚Üí dist (s m) (s n) ‚â§ Sup (S N) :=
    Œª m n N hm hn, le_cSup (hS N) ‚ü®‚ü®_, _‚ü©, ‚ü®hm, hn‚ü©, rfl‚ü©,
  have S0m : ‚àÄ n, (0:‚Ñù) ‚àà S n := Œª n, ‚ü®‚ü®n, n‚ü©, ‚ü®le_rfl, le_rfl‚ü©, dist_self _‚ü©,
  have S0 := Œª n, le_cSup (hS n) (S0m n),
  -- Prove that it tends to `0`, by using the Cauchy property of `s`
  refine ‚ü®Œª N, Sup (S N), S0, ub, metric.tendsto_at_top.2 (Œª Œµ Œµ0, _)‚ü©,
  refine (metric.cauchy_seq_iff.1 hs (Œµ/2) (half_pos Œµ0)).imp (Œª N hN n hn, _),
  rw [real.dist_0_eq_abs, abs_of_nonneg (S0 n)],
  refine lt_of_le_of_lt (cSup_le ‚ü®_, S0m _‚ü© _) (half_lt_self Œµ0),
  rintro _ ‚ü®‚ü®m', n'‚ü©, ‚ü®hm', hn'‚ü©, rfl‚ü©,
  exact le_of_lt (hN _ (le_trans hn hm') _ (le_trans hn hn'))
  end,
Œª ‚ü®b, _, b_bound, b_lim‚ü©, cauchy_seq_of_le_tendsto_0 b b_bound b_lim‚ü©

end cauchy_seq

/-- Pseudometric space structure pulled back by a function. -/
def pseudo_metric_space.induced {Œ± Œ≤} (f : Œ± ‚Üí Œ≤)
  (m : pseudo_metric_space Œ≤) : pseudo_metric_space Œ± :=
{ dist               := Œª x y, dist (f x) (f y),
  dist_self          := Œª x, dist_self _,
  dist_comm          := Œª x y, dist_comm _ _,
  dist_triangle      := Œª x y z, dist_triangle _ _ _,
  edist              := Œª x y, edist (f x) (f y),
  edist_dist         := Œª x y, edist_dist _ _,
  to_uniform_space   := uniform_space.comap f m.to_uniform_space,
  uniformity_dist    := begin
    apply @uniformity_dist_of_mem_uniformity _ _ _ _ _ (Œª x y, dist (f x) (f y)),
    refine Œª s, mem_comap.trans _,
    split; intro H,
    { rcases H with ‚ü®r, ru, rs‚ü©,
      rcases mem_uniformity_dist.1 ru with ‚ü®Œµ, Œµ0, hŒµ‚ü©,
      refine ‚ü®Œµ, Œµ0, Œª a b h, rs (hŒµ _)‚ü©, exact h },
    { rcases H with ‚ü®Œµ, Œµ0, hŒµ‚ü©,
      exact ‚ü®_, dist_mem_uniformity Œµ0, Œª ‚ü®a, b‚ü©, hŒµ‚ü© }
  end }

/-- Pull back a pseudometric space structure by a uniform inducing map. This is a version of
`pseudo_metric_space.induced` useful in case if the domain already has a `uniform_space`
structure. -/
def uniform_inducing.comap_pseudo_metric_space {Œ± Œ≤} [uniform_space Œ±] [pseudo_metric_space Œ≤]
  (f : Œ± ‚Üí Œ≤) (h : uniform_inducing f) : pseudo_metric_space Œ± :=
(pseudo_metric_space.induced f ‚Äπ_‚Ä∫).replace_uniformity h.comap_uniformity.symm

instance subtype.psudo_metric_space {Œ± : Type*} {p : Œ± ‚Üí Prop} [t : pseudo_metric_space Œ±] :
  pseudo_metric_space (subtype p) :=
pseudo_metric_space.induced coe t

theorem subtype.pseudo_dist_eq {p : Œ± ‚Üí Prop} (x y : subtype p) : dist x y = dist (x : Œ±) y := rfl

section nnreal

noncomputable instance : pseudo_metric_space ‚Ñù‚â•0 := by unfold nnreal; apply_instance

lemma nnreal.dist_eq (a b : ‚Ñù‚â•0) : dist a b = |(a:‚Ñù) - b| := rfl

lemma nnreal.nndist_eq (a b : ‚Ñù‚â•0) :
  nndist a b = max (a - b) (b - a) :=
begin
  wlog h : a ‚â§ b,
  { apply nnreal.coe_eq.1,
    rw [tsub_eq_zero_iff_le.2 h, max_eq_right (zero_le $ b - a), ‚Üê dist_nndist, nnreal.dist_eq,
      nnreal.coe_sub h, abs_eq_max_neg, neg_sub],
    apply max_eq_right,
    linarith [nnreal.coe_le_coe.2 h] },
  rwa [nndist_comm, max_comm]
end

@[simp] lemma nnreal.nndist_zero_eq_val (z : ‚Ñù‚â•0) : nndist 0 z = z :=
by simp only [nnreal.nndist_eq, max_eq_right, tsub_zero, zero_tsub, zero_le']

@[simp] lemma nnreal.nndist_zero_eq_val' (z : ‚Ñù‚â•0) : nndist z 0 = z :=
by { rw nndist_comm, exact nnreal.nndist_zero_eq_val z, }

lemma nnreal.le_add_nndist (a b : ‚Ñù‚â•0) : a ‚â§ b + nndist a b :=
begin
  suffices : (a : ‚Ñù) ‚â§ (b : ‚Ñù) + (dist a b),
  { exact nnreal.coe_le_coe.mp this, },
  linarith [le_of_abs_le (by refl : abs (a-b : ‚Ñù) ‚â§ (dist a b))],
end

end nnreal

section prod

noncomputable instance prod.pseudo_metric_space_max [pseudo_metric_space Œ≤] :
  pseudo_metric_space (Œ± √ó Œ≤) :=
{ dist := Œª x y, max (dist x.1 y.1) (dist x.2 y.2),
  dist_self := Œª x, by simp,
  dist_comm := Œª x y, by simp [dist_comm],
  dist_triangle := Œª x y z, max_le
    (le_trans (dist_triangle _ _ _) (add_le_add (le_max_left _ _) (le_max_left _ _)))
    (le_trans (dist_triangle _ _ _) (add_le_add (le_max_right _ _) (le_max_right _ _))),
  edist := Œª x y, max (edist x.1 y.1) (edist x.2 y.2),
  edist_dist := assume x y, begin
    have : monotone ennreal.of_real := assume x y h, ennreal.of_real_le_of_real h,
    rw [edist_dist, edist_dist, ‚Üê this.map_max]
  end,
  uniformity_dist := begin
    refine uniformity_prod.trans _,
    simp only [uniformity_basis_dist.eq_binfi, comap_infi],
    rw ‚Üê infi_inf_eq, congr, funext,
    rw ‚Üê infi_inf_eq, congr, funext,
    simp [inf_principal, ext_iff, max_lt_iff]
  end,
  to_uniform_space := prod.uniform_space }

lemma prod.dist_eq [pseudo_metric_space Œ≤] {x y : Œ± √ó Œ≤} :
  dist x y = max (dist x.1 y.1) (dist x.2 y.2) := rfl

theorem ball_prod_same [pseudo_metric_space Œ≤] (x : Œ±) (y : Œ≤) (r : ‚Ñù) :
  ball x r √óÀ¢ ball y r = ball (x, y) r :=
ext $ Œª z, by simp [prod.dist_eq]

theorem closed_ball_prod_same [pseudo_metric_space Œ≤] (x : Œ±) (y : Œ≤) (r : ‚Ñù) :
  closed_ball x r √óÀ¢ closed_ball y r = closed_ball (x, y) r :=
ext $ Œª z, by simp [prod.dist_eq]

end prod

theorem uniform_continuous_dist : uniform_continuous (Œªp:Œ±√óŒ±, dist p.1 p.2) :=
metric.uniform_continuous_iff.2 (Œª Œµ Œµ0, ‚ü®Œµ/2, half_pos Œµ0,
begin
  suffices,
  { intros p q h, cases p with p‚ÇÅ p‚ÇÇ, cases q with q‚ÇÅ q‚ÇÇ,
    cases max_lt_iff.1 h with h‚ÇÅ h‚ÇÇ, clear h,
    dsimp at h‚ÇÅ h‚ÇÇ ‚ä¢,
    rw real.dist_eq,
    refine abs_sub_lt_iff.2 ‚ü®_, _‚ü©,
    { revert p‚ÇÅ p‚ÇÇ q‚ÇÅ q‚ÇÇ h‚ÇÅ h‚ÇÇ, exact this },
    { apply this; rwa dist_comm } },
  intros p‚ÇÅ p‚ÇÇ q‚ÇÅ q‚ÇÇ h‚ÇÅ h‚ÇÇ,
  have := add_lt_add
    (abs_sub_lt_iff.1 (lt_of_le_of_lt (abs_dist_sub_le p‚ÇÅ q‚ÇÅ p‚ÇÇ) h‚ÇÅ)).1
    (abs_sub_lt_iff.1 (lt_of_le_of_lt (abs_dist_sub_le p‚ÇÇ q‚ÇÇ q‚ÇÅ) h‚ÇÇ)).1,
  rwa [add_halves, dist_comm p‚ÇÇ, sub_add_sub_cancel, dist_comm q‚ÇÇ] at this
end‚ü©)

theorem uniform_continuous.dist [uniform_space Œ≤] {f g : Œ≤ ‚Üí Œ±}
  (hf : uniform_continuous f) (hg : uniform_continuous g) :
  uniform_continuous (Œªb, dist (f b) (g b)) :=
uniform_continuous_dist.comp (hf.prod_mk hg)

@[continuity]
theorem continuous_dist : continuous (Œªp:Œ±√óŒ±, dist p.1 p.2) :=
uniform_continuous_dist.continuous

@[continuity]
theorem continuous.dist [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±}
  (hf : continuous f) (hg : continuous g) : continuous (Œªb, dist (f b) (g b)) :=
continuous_dist.comp (hf.prod_mk hg : _)

theorem filter.tendsto.dist {f g : Œ≤ ‚Üí Œ±} {x : filter Œ≤} {a b : Œ±}
  (hf : tendsto f x (ùìù a)) (hg : tendsto g x (ùìù b)) :
  tendsto (Œªx, dist (f x) (g x)) x (ùìù (dist a b)) :=
(continuous_dist.tendsto (a, b)).comp (hf.prod_mk_nhds hg)

lemma nhds_comap_dist (a : Œ±) : (ùìù (0 : ‚Ñù)).comap (Œªa', dist a' a) = ùìù a :=
by simp only [@nhds_eq_comap_uniformity Œ±, metric.uniformity_eq_comap_nhds_zero,
  comap_comap, (‚àò), dist_comm]

lemma tendsto_iff_dist_tendsto_zero {f : Œ≤ ‚Üí Œ±} {x : filter Œ≤} {a : Œ±} :
  (tendsto f x (ùìù a)) ‚Üî (tendsto (Œªb, dist (f b) a) x (ùìù 0)) :=
by rw [‚Üê nhds_comap_dist a, tendsto_comap_iff]

lemma uniform_continuous_nndist : uniform_continuous (Œªp:Œ±√óŒ±, nndist p.1 p.2) :=
uniform_continuous_subtype_mk uniform_continuous_dist _

lemma uniform_continuous.nndist [uniform_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : uniform_continuous f)
  (hg : uniform_continuous g) :
  uniform_continuous (Œª b, nndist (f b) (g b)) :=
uniform_continuous_nndist.comp (hf.prod_mk hg)

lemma continuous_nndist : continuous (Œªp:Œ±√óŒ±, nndist p.1 p.2) :=
uniform_continuous_nndist.continuous

lemma continuous.nndist [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±}
  (hf : continuous f) (hg : continuous g) : continuous (Œªb, nndist (f b) (g b)) :=
continuous_nndist.comp (hf.prod_mk hg : _)

theorem filter.tendsto.nndist {f g : Œ≤ ‚Üí Œ±} {x : filter Œ≤} {a b : Œ±}
  (hf : tendsto f x (ùìù a)) (hg : tendsto g x (ùìù b)) :
  tendsto (Œªx, nndist (f x) (g x)) x (ùìù (nndist a b)) :=
(continuous_nndist.tendsto (a, b)).comp (hf.prod_mk_nhds hg)

namespace metric
variables {x y z : Œ±} {Œµ Œµ‚ÇÅ Œµ‚ÇÇ : ‚Ñù} {s : set Œ±}

theorem is_closed_ball : is_closed (closed_ball x Œµ) :=
is_closed_le (continuous_id.dist continuous_const) continuous_const

lemma is_closed_sphere : is_closed (sphere x Œµ) :=
is_closed_eq (continuous_id.dist continuous_const) continuous_const

@[simp] theorem closure_closed_ball : closure (closed_ball x Œµ) = closed_ball x Œµ :=
is_closed_ball.closure_eq

theorem closure_ball_subset_closed_ball : closure (ball x Œµ) ‚äÜ closed_ball x Œµ :=
closure_minimal ball_subset_closed_ball is_closed_ball

theorem frontier_ball_subset_sphere : frontier (ball x Œµ) ‚äÜ sphere x Œµ :=
frontier_lt_subset_eq (continuous_id.dist continuous_const) continuous_const

theorem frontier_closed_ball_subset_sphere : frontier (closed_ball x Œµ) ‚äÜ sphere x Œµ :=
frontier_le_subset_eq (continuous_id.dist continuous_const) continuous_const

theorem ball_subset_interior_closed_ball : ball x Œµ ‚äÜ interior (closed_ball x Œµ) :=
interior_maximal ball_subset_closed_ball is_open_ball

/-- Œµ-characterization of the closure in pseudometric spaces-/
theorem mem_closure_iff {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} {a : Œ±} :
  a ‚àà closure s ‚Üî ‚àÄŒµ>0, ‚àÉb ‚àà s, dist a b < Œµ :=
(mem_closure_iff_nhds_basis nhds_basis_ball).trans $
  by simp only [mem_ball, dist_comm]

lemma mem_closure_range_iff {Œ± : Type u} [pseudo_metric_space Œ±] {e : Œ≤ ‚Üí Œ±} {a : Œ±} :
  a ‚àà closure (range e) ‚Üî ‚àÄŒµ>0, ‚àÉ k : Œ≤, dist a (e k) < Œµ :=
by simp only [mem_closure_iff, exists_range_iff]

lemma mem_closure_range_iff_nat {Œ± : Type u} [pseudo_metric_space Œ±] {e : Œ≤ ‚Üí Œ±} {a : Œ±} :
  a ‚àà closure (range e) ‚Üî ‚àÄn : ‚Ñï, ‚àÉ k : Œ≤, dist a (e k) < 1 / ((n : ‚Ñù) + 1) :=
(mem_closure_iff_nhds_basis nhds_basis_ball_inv_nat_succ).trans $
  by simp only [mem_ball, dist_comm, exists_range_iff, forall_const]

theorem mem_of_closed' {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±} (hs : is_closed s)
  {a : Œ±} : a ‚àà s ‚Üî ‚àÄŒµ>0, ‚àÉb ‚àà s, dist a b < Œµ :=
by simpa only [hs.closure_eq] using @mem_closure_iff _ _ s a

end metric

section pi
open finset
variables {œÄ : Œ≤ ‚Üí Type*} [fintype Œ≤] [‚àÄb, pseudo_metric_space (œÄ b)]

/-- A finite product of pseudometric spaces is a pseudometric space, with the sup distance. -/
noncomputable instance pseudo_metric_space_pi : pseudo_metric_space (Œ†b, œÄ b) :=
begin
  /- we construct the instance from the pseudoemetric space instance to avoid checking again that
  the uniformity is the same as the product uniformity, but we register nevertheless a nice formula
  for the distance -/
  refine pseudo_emetric_space.to_pseudo_metric_space_of_dist
    (Œªf g, ((sup univ (Œªb, nndist (f b) (g b)) : ‚Ñù‚â•0) : ‚Ñù)) _ _,
  show ‚àÄ (x y : Œ† (b : Œ≤), œÄ b), edist x y ‚â† ‚ä§,
  { assume x y,
    rw ‚Üê lt_top_iff_ne_top,
    have : (‚ä• : ‚Ñù‚â•0‚àû) < ‚ä§ := ennreal.coe_lt_top,
    simp [edist_pi_def, finset.sup_lt_iff this, edist_lt_top] },
  show ‚àÄ (x y : Œ† (b : Œ≤), œÄ b), ‚Üë(sup univ (Œª (b : Œ≤), nndist (x b) (y b))) =
    ennreal.to_real (sup univ (Œª (b : Œ≤), edist (x b) (y b))),
  { assume x y,
    simp only [edist_nndist],
    norm_cast }
end

lemma nndist_pi_def (f g : Œ†b, œÄ b) : nndist f g = sup univ (Œªb, nndist (f b) (g b)) :=
subtype.eta _ _

lemma dist_pi_def (f g : Œ†b, œÄ b) :
  dist f g = (sup univ (Œªb, nndist (f b) (g b)) : ‚Ñù‚â•0) := rfl

@[simp] lemma dist_pi_const [nonempty Œ≤] (a b : Œ±) : dist (Œª x : Œ≤, a) (Œª _, b) = dist a b :=
by simpa only [dist_edist] using congr_arg ennreal.to_real (edist_pi_const a b)

@[simp] lemma nndist_pi_const [nonempty Œ≤] (a b : Œ±) :
  nndist (Œª x : Œ≤, a) (Œª _, b) = nndist a b := nnreal.eq $ dist_pi_const a b

lemma nndist_pi_le_iff {f g : Œ†b, œÄ b} {r : ‚Ñù‚â•0} :
  nndist f g ‚â§ r ‚Üî ‚àÄb, nndist (f b) (g b) ‚â§ r :=
by simp [nndist_pi_def]

lemma dist_pi_lt_iff {f g : Œ†b, œÄ b} {r : ‚Ñù} (hr : 0 < r) :
  dist f g < r ‚Üî ‚àÄb, dist (f b) (g b) < r :=
begin
  lift r to ‚Ñù‚â•0 using hr.le,
  simp [dist_pi_def, finset.sup_lt_iff (show ‚ä• < r, from hr)],
end

lemma dist_pi_le_iff {f g : Œ†b, œÄ b} {r : ‚Ñù} (hr : 0 ‚â§ r) :
  dist f g ‚â§ r ‚Üî ‚àÄb, dist (f b) (g b) ‚â§ r :=
begin
  lift r to ‚Ñù‚â•0 using hr,
  exact nndist_pi_le_iff
end

lemma nndist_le_pi_nndist (f g : Œ†b, œÄ b) (b : Œ≤) : nndist (f b) (g b) ‚â§ nndist f g :=
by { rw [nndist_pi_def], exact finset.le_sup (finset.mem_univ b) }

lemma dist_le_pi_dist (f g : Œ†b, œÄ b) (b : Œ≤) : dist (f b) (g b) ‚â§ dist f g :=
by simp only [dist_nndist, nnreal.coe_le_coe, nndist_le_pi_nndist f g b]

/-- An open ball in a product space is a product of open balls. See also `metric.ball_pi'`
for a version assuming `nonempty Œ≤` instead of `0 < r`. -/
lemma ball_pi (x : Œ†b, œÄ b) {r : ‚Ñù} (hr : 0 < r) :
  ball x r = set.pi univ (Œª b, ball (x b) r) :=
by { ext p, simp [dist_pi_lt_iff hr] }

/-- An open ball in a product space is a product of open balls. See also `metric.ball_pi`
for a version assuming `0 < r` instead of `nonempty Œ≤`. -/
lemma ball_pi' [nonempty Œ≤] (x : Œ† b, œÄ b) (r : ‚Ñù) :
  ball x r = set.pi univ (Œª b, ball (x b) r) :=
(lt_or_le 0 r).elim (ball_pi x) $ Œª hr, by simp [ball_eq_empty.2 hr]

/-- A closed ball in a product space is a product of closed balls. See also `metric.closed_ball_pi'`
for a version assuming `nonempty Œ≤` instead of `0 ‚â§ r`. -/
lemma closed_ball_pi (x : Œ†b, œÄ b) {r : ‚Ñù} (hr : 0 ‚â§ r) :
  closed_ball x r = set.pi univ (Œª b, closed_ball (x b) r) :=
by { ext p, simp [dist_pi_le_iff hr] }

/-- A closed ball in a product space is a product of closed balls. See also `metric.closed_ball_pi`
for a version assuming `0 ‚â§ r` instead of `nonempty Œ≤`. -/
lemma closed_ball_pi' [nonempty Œ≤] (x : Œ† b, œÄ b) (r : ‚Ñù) :
  closed_ball x r = set.pi univ (Œª b, closed_ball (x b) r) :=
(le_or_lt 0 r).elim (closed_ball_pi x) $ Œª hr, by simp [closed_ball_eq_empty.2 hr]

@[simp] lemma fin.nndist_insert_nth_insert_nth {n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type*}
  [Œ† i, pseudo_metric_space (Œ± i)] (i : fin (n + 1)) (x y : Œ± i) (f g : Œ† j, Œ± (i.succ_above j)) :
  nndist (i.insert_nth x f) (i.insert_nth y g) = max (nndist x y) (nndist f g) :=
eq_of_forall_ge_iff $ Œª c, by simp [nndist_pi_le_iff, i.forall_iff_succ_above]

@[simp] lemma fin.dist_insert_nth_insert_nth {n : ‚Ñï} {Œ± : fin (n + 1) ‚Üí Type*}
  [Œ† i, pseudo_metric_space (Œ± i)] (i : fin (n + 1)) (x y : Œ± i) (f g : Œ† j, Œ± (i.succ_above j)) :
  dist (i.insert_nth x f) (i.insert_nth y g) = max (dist x y) (dist f g) :=
by simp only [dist_nndist, fin.nndist_insert_nth_insert_nth, nnreal.coe_max]

lemma real.dist_le_of_mem_pi_Icc {x y x' y' : Œ≤ ‚Üí ‚Ñù} (hx : x ‚àà Icc x' y') (hy : y ‚àà Icc x' y') :
  dist x y ‚â§ dist x' y' :=
begin
  refine (dist_pi_le_iff dist_nonneg).2 (Œª b, (real.dist_le_of_mem_interval _ _).trans
    (dist_le_pi_dist _ _ b)); refine Icc_subset_interval _,
  exacts [‚ü®hx.1 _, hx.2 _‚ü©, ‚ü®hy.1 _, hy.2 _‚ü©]
end

end pi

section compact

/-- Any compact set in a pseudometric space can be covered by finitely many balls of a given
positive radius -/
lemma finite_cover_balls_of_compact {Œ± : Type u} [pseudo_metric_space Œ±] {s : set Œ±}
  (hs : is_compact s) {e : ‚Ñù} (he : 0 < e) :
  ‚àÉt ‚äÜ s, finite t ‚àß s ‚äÜ ‚ãÉx‚ààt, ball x e :=
begin
  apply hs.elim_finite_subcover_image,
  { simp [is_open_ball] },
  { intros x xs,
    simp,
    exact ‚ü®x, ‚ü®xs, by simpa‚ü©‚ü© }
end

alias finite_cover_balls_of_compact ‚Üê is_compact.finite_cover_balls

end compact

section proper_space
open metric

/-- A pseudometric space is proper if all closed balls are compact. -/
class proper_space (Œ± : Type u) [pseudo_metric_space Œ±] : Prop :=
(is_compact_closed_ball : ‚àÄx:Œ±, ‚àÄr, is_compact (closed_ball x r))

export proper_space (is_compact_closed_ball)

/-- In a proper pseudometric space, all spheres are compact. -/
lemma is_compact_sphere {Œ± : Type*} [pseudo_metric_space Œ±] [proper_space Œ±] (x : Œ±) (r : ‚Ñù) :
  is_compact (sphere x r) :=
compact_of_is_closed_subset (is_compact_closed_ball x r) is_closed_sphere sphere_subset_closed_ball

/-- In a proper pseudometric space, any sphere is a `compact_space` when considered as a subtype. -/
instance {Œ± : Type*} [pseudo_metric_space Œ±] [proper_space Œ±] (x : Œ±) (r : ‚Ñù) :
  compact_space (sphere x r) :=
is_compact_iff_compact_space.mp (is_compact_sphere _ _)

/-- A proper pseudo metric space is sigma compact, and therefore second countable. -/
@[priority 100] -- see Note [lower instance priority]
instance second_countable_of_proper [proper_space Œ±] :
  second_countable_topology Œ± :=
begin
  -- We already have `sigma_compact_space_of_locally_compact_second_countable`, so we don't
  -- add an instance for `sigma_compact_space`.
  suffices : sigma_compact_space Œ±, by exactI emetric.second_countable_of_sigma_compact Œ±,
  rcases em (nonempty Œ±) with ‚ü®‚ü®x‚ü©‚ü©|hn,
  { exact ‚ü®‚ü®Œª n, closed_ball x n, Œª n, is_compact_closed_ball _ _, Union_closed_ball_nat _‚ü©‚ü© },
  { exact ‚ü®‚ü®Œª n, ‚àÖ, Œª n, is_compact_empty, Union_eq_univ_iff.2 $ Œª x, (hn ‚ü®x‚ü©).elim‚ü©‚ü© }
end

lemma tendsto_dist_right_cocompact_at_top [proper_space Œ±] (x : Œ±) :
  tendsto (Œª y, dist y x) (cocompact Œ±) at_top :=
(has_basis_cocompact.tendsto_iff at_top_basis).2 $ Œª r hr,
  ‚ü®closed_ball x r, is_compact_closed_ball x r, Œª y hy, (not_le.1 $ mt mem_closed_ball.2 hy).le‚ü©

lemma tendsto_dist_left_cocompact_at_top [proper_space Œ±] (x : Œ±) :
  tendsto (dist x) (cocompact Œ±) at_top :=
by simpa only [dist_comm] using tendsto_dist_right_cocompact_at_top x

/-- If all closed balls of large enough radius are compact, then the space is proper. Especially
useful when the lower bound for the radius is 0. -/
lemma proper_space_of_compact_closed_ball_of_le
  (R : ‚Ñù) (h : ‚àÄx:Œ±, ‚àÄr, R ‚â§ r ‚Üí is_compact (closed_ball x r)) :
  proper_space Œ± :=
‚ü®begin
  assume x r,
  by_cases hr : R ‚â§ r,
  { exact h x r hr },
  { have : closed_ball x r = closed_ball x R ‚à© closed_ball x r,
    { symmetry,
      apply inter_eq_self_of_subset_right,
      exact closed_ball_subset_closed_ball (le_of_lt (not_le.1 hr)) },
    rw this,
    exact (h x R le_rfl).inter_right is_closed_ball }
end‚ü©

/- A compact pseudometric space is proper -/
@[priority 100] -- see Note [lower instance priority]
instance proper_of_compact [compact_space Œ±] : proper_space Œ± :=
‚ü®assume x r, is_closed_ball.is_compact‚ü©

/-- A proper space is locally compact -/
@[priority 100] -- see Note [lower instance priority]
instance locally_compact_of_proper [proper_space Œ±] :
  locally_compact_space Œ± :=
locally_compact_space_of_has_basis (Œª x, nhds_basis_closed_ball) $
  Œª x Œµ Œµ0, is_compact_closed_ball _ _

/-- A proper space is complete -/
@[priority 100] -- see Note [lower instance priority]
instance complete_of_proper [proper_space Œ±] : complete_space Œ± :=
‚ü®begin
  intros f hf,
  /- We want to show that the Cauchy filter `f` is converging. It suffices to find a closed
  ball (therefore compact by properness) where it is nontrivial. -/
  obtain ‚ü®t, t_fset, ht‚ü© : ‚àÉ t ‚àà f, ‚àÄ x y ‚àà t, dist x y < 1 :=
    (metric.cauchy_iff.1 hf).2 1 zero_lt_one,
  rcases hf.1.nonempty_of_mem t_fset with ‚ü®x, xt‚ü©,
  have : closed_ball x 1 ‚àà f := mem_of_superset t_fset (Œª y yt, (ht y yt x xt).le),
  rcases (compact_iff_totally_bounded_complete.1 (is_compact_closed_ball x 1)).2 f hf
    (le_principal_iff.2 this) with ‚ü®y, -, hy‚ü©,
  exact ‚ü®y, hy‚ü©
end‚ü©

/-- A finite product of proper spaces is proper. -/
instance pi_proper_space {œÄ : Œ≤ ‚Üí Type*} [fintype Œ≤] [‚àÄb, pseudo_metric_space (œÄ b)]
  [h : ‚àÄb, proper_space (œÄ b)] : proper_space (Œ†b, œÄ b) :=
begin
  refine proper_space_of_compact_closed_ball_of_le 0 (Œªx r hr, _),
  rw closed_ball_pi _ hr,
  apply is_compact_univ_pi (Œªb, _),
  apply (h b).is_compact_closed_ball
end

variables [proper_space Œ±] {x : Œ±} {r : ‚Ñù} {s : set Œ±}

/-- If a nonempty ball in a proper space includes a closed set `s`, then there exists a nonempty
ball with the same center and a strictly smaller radius that includes `s`. -/
lemma exists_pos_lt_subset_ball (hr : 0 < r) (hs : is_closed s) (h : s ‚äÜ ball x r) :
  ‚àÉ r' ‚àà Ioo 0 r, s ‚äÜ ball x r' :=
begin
  unfreezingI { rcases eq_empty_or_nonempty s with rfl|hne },
  { exact ‚ü®r / 2, ‚ü®half_pos hr, half_lt_self hr‚ü©, empty_subset _‚ü© },
  have : is_compact s,
    from compact_of_is_closed_subset (is_compact_closed_ball x r) hs
      (subset.trans h ball_subset_closed_ball),
  obtain ‚ü®y, hys, hy‚ü© : ‚àÉ y ‚àà s, s ‚äÜ closed_ball x (dist y x),
    from this.exists_forall_ge hne (continuous_id.dist continuous_const).continuous_on,
  have hyr : dist y x < r, from h hys,
  rcases exists_between hyr with ‚ü®r', hyr', hrr'‚ü©,
  exact ‚ü®r', ‚ü®dist_nonneg.trans_lt hyr', hrr'‚ü©, subset.trans hy $ closed_ball_subset_ball hyr'‚ü©
end

/-- If a ball in a proper space includes a closed set `s`, then there exists a ball with the same
center and a strictly smaller radius that includes `s`. -/
lemma exists_lt_subset_ball (hs : is_closed s) (h : s ‚äÜ ball x r) :
  ‚àÉ r' < r, s ‚äÜ ball x r' :=
begin
  cases le_or_lt r 0 with hr hr,
  { rw [ball_eq_empty.2 hr, subset_empty_iff] at h, unfreezingI { subst s },
    exact (exists_lt r).imp (Œª r' hr', ‚ü®hr', empty_subset _‚ü©) },
  { exact (exists_pos_lt_subset_ball hr hs h).imp (Œª r' hr', ‚ü®hr'.fst.2, hr'.snd‚ü©) }
end

end proper_space

namespace metric
section second_countable
open topological_space

/-- A pseudometric space is second countable if, for every `Œµ > 0`, there is a countable set which
is `Œµ`-dense. -/
lemma second_countable_of_almost_dense_set
  (H : ‚àÄŒµ > (0 : ‚Ñù), ‚àÉ s : set Œ±, countable s ‚àß (‚àÄx, ‚àÉy ‚àà s, dist x y ‚â§ Œµ)) :
  second_countable_topology Œ± :=
begin
  refine emetric.second_countable_of_almost_dense_set (Œª Œµ Œµ0, _),
  rcases ennreal.lt_iff_exists_nnreal_btwn.1 Œµ0 with ‚ü®Œµ', Œµ'0, Œµ'Œµ‚ü©,
  choose s hsc y hys hyx using H Œµ' (by exact_mod_cast Œµ'0),
  refine ‚ü®s, hsc, Union‚ÇÇ_eq_univ_iff.2 (Œª x, ‚ü®y x, hys _, le_trans _ Œµ'Œµ.le‚ü©)‚ü©,
  exact_mod_cast hyx x
end

end second_countable
end metric

lemma lebesgue_number_lemma_of_metric
  {s : set Œ±} {Œπ} {c : Œπ ‚Üí set Œ±} (hs : is_compact s)
  (hc‚ÇÅ : ‚àÄ i, is_open (c i)) (hc‚ÇÇ : s ‚äÜ ‚ãÉ i, c i) :
  ‚àÉ Œ¥ > 0, ‚àÄ x ‚àà s, ‚àÉ i, ball x Œ¥ ‚äÜ c i :=
let ‚ü®n, en, hn‚ü© := lebesgue_number_lemma hs hc‚ÇÅ hc‚ÇÇ,
    ‚ü®Œ¥, Œ¥0, hŒ¥‚ü© := mem_uniformity_dist.1 en in
‚ü®Œ¥, Œ¥0, assume x hx, let ‚ü®i, hi‚ü© := hn x hx in
 ‚ü®i, assume y hy, hi (hŒ¥ (mem_ball'.mp hy))‚ü©‚ü©

lemma lebesgue_number_lemma_of_metric_sUnion
  {s : set Œ±} {c : set (set Œ±)} (hs : is_compact s)
  (hc‚ÇÅ : ‚àÄ t ‚àà c, is_open t) (hc‚ÇÇ : s ‚äÜ ‚ãÉ‚ÇÄ c) :
  ‚àÉ Œ¥ > 0, ‚àÄ x ‚àà s, ‚àÉ t ‚àà c, ball x Œ¥ ‚äÜ t :=
by rw sUnion_eq_Union at hc‚ÇÇ;
   simpa using lebesgue_number_lemma_of_metric hs (by simpa) hc‚ÇÇ

namespace metric

/-- Boundedness of a subset of a pseudometric space. We formulate the definition to work
even in the empty space. -/
def bounded (s : set Œ±) : Prop :=
‚àÉC, ‚àÄx y ‚àà s, dist x y ‚â§ C

section bounded
variables {x : Œ±} {s t : set Œ±} {r : ‚Ñù}

@[simp] lemma bounded_empty : bounded (‚àÖ : set Œ±) :=
‚ü®0, by simp‚ü©

lemma bounded_iff_mem_bounded : bounded s ‚Üî ‚àÄ x ‚àà s, bounded s :=
‚ü®Œª h _ _, h, Œª H,
  s.eq_empty_or_nonempty.elim
  (Œª hs, hs.symm ‚ñ∏ bounded_empty)
  (Œª ‚ü®x, hx‚ü©, H x hx)‚ü©

/-- Subsets of a bounded set are also bounded -/
lemma bounded.mono (incl : s ‚äÜ t) : bounded t ‚Üí bounded s :=
Exists.imp $ Œª C hC x hx y hy, hC x (incl hx) y (incl hy)

/-- Closed balls are bounded -/
lemma bounded_closed_ball : bounded (closed_ball x r) :=
‚ü®r + r, Œª y hy z hz, begin
  simp only [mem_closed_ball] at *,
  calc dist y z ‚â§ dist y x + dist z x : dist_triangle_right _ _ _
            ... ‚â§ r + r : add_le_add hy hz
end‚ü©

/-- Open balls are bounded -/
lemma bounded_ball : bounded (ball x r) :=
bounded_closed_ball.mono ball_subset_closed_ball

/-- Spheres are bounded -/
lemma bounded_sphere : bounded (sphere x r) :=
bounded_closed_ball.mono sphere_subset_closed_ball

/-- Given a point, a bounded subset is included in some ball around this point -/
lemma bounded_iff_subset_ball (c : Œ±) : bounded s ‚Üî ‚àÉr, s ‚äÜ closed_ball c r :=
begin
  split; rintro ‚ü®C, hC‚ü©,
  { cases s.eq_empty_or_nonempty with h h,
    { subst s, exact ‚ü®0, by simp‚ü© },
    { rcases h with ‚ü®x, hx‚ü©,
      exact ‚ü®C + dist x c, Œª y hy, calc
        dist y c ‚â§ dist y x + dist x c : dist_triangle _ _ _
            ... ‚â§ C + dist x c : add_le_add_right (hC y hy x hx) _‚ü© } },
  { exact bounded_closed_ball.mono hC }
end

lemma bounded.subset_ball (h : bounded s) (c : Œ±) : ‚àÉ r, s ‚äÜ closed_ball c r :=
(bounded_iff_subset_ball c).1 h

lemma bounded.subset_ball_lt (h : bounded s) (a : ‚Ñù) (c : Œ±) : ‚àÉ r, a < r ‚àß s ‚äÜ closed_ball c r :=
begin
  rcases h.subset_ball c with ‚ü®r, hr‚ü©,
  refine ‚ü®max r (a+1), lt_of_lt_of_le (by linarith) (le_max_right _ _), _‚ü©,
  exact subset.trans hr (closed_ball_subset_closed_ball (le_max_left _ _))
end

lemma bounded_closure_of_bounded (h : bounded s) : bounded (closure s) :=
let ‚ü®C, h‚ü© := h in
‚ü®C, Œª a ha b hb, (is_closed_le' C).closure_subset $ map_mem_closure2 continuous_dist ha hb
$ ball_mem_comm.mp h‚ü©

alias bounded_closure_of_bounded ‚Üê metric.bounded.closure

@[simp] lemma bounded_closure_iff : bounded (closure s) ‚Üî bounded s :=
‚ü®Œª h, h.mono subset_closure, Œª h, h.closure‚ü©

/-- The union of two bounded sets is bounded. -/
lemma bounded.union (hs : bounded s) (ht : bounded t) : bounded (s ‚à™ t) :=
begin
  refine bounded_iff_mem_bounded.2 (Œª x _, _),
  rw bounded_iff_subset_ball x at hs ht ‚ä¢,
  rcases hs with ‚ü®Cs, hCs‚ü©, rcases ht with ‚ü®Ct, hCt‚ü©,
  exact ‚ü®max Cs Ct, union_subset
    (subset.trans hCs $ closed_ball_subset_closed_ball $ le_max_left _ _)
    (subset.trans hCt $ closed_ball_subset_closed_ball $ le_max_right _ _)‚ü©,
end

/-- The union of two sets is bounded iff each of the sets is bounded. -/
@[simp] lemma bounded_union : bounded (s ‚à™ t) ‚Üî bounded s ‚àß bounded t :=
‚ü®Œª h, ‚ü®h.mono (by simp), h.mono (by simp)‚ü©, Œª h, h.1.union h.2‚ü©

/-- A finite union of bounded sets is bounded -/
lemma bounded_bUnion {I : set Œ≤} {s : Œ≤ ‚Üí set Œ±} (H : finite I) :
  bounded (‚ãÉi‚ààI, s i) ‚Üî ‚àÄi ‚àà I, bounded (s i) :=
finite.induction_on H (by simp) $ Œª x I _ _ IH,
by simp [or_imp_distrib, forall_and_distrib, IH]

/-- A totally bounded set is bounded -/
lemma _root_.totally_bounded.bounded {s : set Œ±} (h : totally_bounded s) : bounded s :=
-- We cover the totally bounded set by finitely many balls of radius 1,
-- and then argue that a finite union of bounded sets is bounded
let ‚ü®t, fint, subs‚ü© := (totally_bounded_iff.mp h) 1 zero_lt_one in
bounded.mono subs $ (bounded_bUnion fint).2 $ Œª i hi, bounded_ball

/-- A compact set is bounded -/
lemma _root_.is_compact.bounded {s : set Œ±} (h : is_compact s) : bounded s :=
-- A compact set is totally bounded, thus bounded
h.totally_bounded.bounded

/-- A finite set is bounded -/
lemma bounded_of_finite {s : set Œ±} (h : finite s) : bounded s :=
h.is_compact.bounded

alias bounded_of_finite ‚Üê set.finite.bounded

/-- A singleton is bounded -/
lemma bounded_singleton {x : Œ±} : bounded ({x} : set Œ±) :=
bounded_of_finite $ finite_singleton _

/-- Characterization of the boundedness of the range of a function -/
lemma bounded_range_iff {f : Œ≤ ‚Üí Œ±} : bounded (range f) ‚Üî ‚àÉC, ‚àÄx y, dist (f x) (f y) ‚â§ C :=
exists_congr $ Œª C, ‚ü®
  Œª H x y, H _ ‚ü®x, rfl‚ü© _ ‚ü®y, rfl‚ü©,
  by rintro H _ ‚ü®x, rfl‚ü© _ ‚ü®y, rfl‚ü©; exact H x y‚ü©

lemma bounded_range_of_tendsto_cofinite_uniformity {f : Œ≤ ‚Üí Œ±}
  (hf : tendsto (prod.map f f) (cofinite √ó·∂† cofinite) (ùì§ Œ±)) :
  bounded (range f) :=
begin
  rcases (has_basis_cofinite.prod_self.tendsto_iff uniformity_basis_dist).1 hf 1 zero_lt_one
    with ‚ü®s, hsf, hs1‚ü©,
  rw [‚Üê image_univ, ‚Üê union_compl_self s, image_union, bounded_union],
  use [(hsf.image f).bounded, 1],
  rintro _ ‚ü®x, hx, rfl‚ü© _ ‚ü®y, hy, rfl‚ü©,
  exact le_of_lt (hs1 (x, y) ‚ü®hx, hy‚ü©)
end

lemma bounded_range_of_cauchy_map_cofinite {f : Œ≤ ‚Üí Œ±} (hf : cauchy (map f cofinite)) :
  bounded (range f) :=
bounded_range_of_tendsto_cofinite_uniformity $ (cauchy_map_iff.1 hf).2

lemma _root_.cauchy_seq.bounded_range {f : ‚Ñï ‚Üí Œ±} (hf : cauchy_seq f) : bounded (range f) :=
bounded_range_of_cauchy_map_cofinite $ by rwa nat.cofinite_eq_at_top

lemma bounded_range_of_tendsto_cofinite {f : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : tendsto f cofinite (ùìù a)) :
  bounded (range f) :=
bounded_range_of_tendsto_cofinite_uniformity $
  (hf.prod_map hf).mono_right $ nhds_prod_eq.symm.trans_le (nhds_le_uniformity a)

/-- In a compact space, all sets are bounded -/
lemma bounded_of_compact_space [compact_space Œ±] : bounded s :=
compact_univ.bounded.mono (subset_univ _)

lemma bounded_range_of_tendsto {Œ± : Type*} [pseudo_metric_space Œ±] (u : ‚Ñï ‚Üí Œ±) {x : Œ±}
  (hu : tendsto u at_top (ùìù x)) :
  bounded (range u) :=
hu.cauchy_seq.bounded_range

/-- The **Heine‚ÄìBorel theorem**: In a proper space, a closed bounded set is compact. -/
lemma is_compact_of_is_closed_bounded [proper_space Œ±] (hc : is_closed s) (hb : bounded s) :
  is_compact s :=
begin
  unfreezingI { rcases eq_empty_or_nonempty s with (rfl|‚ü®x, hx‚ü©) },
  { exact is_compact_empty },
  { rcases hb.subset_ball x with ‚ü®r, hr‚ü©,
    exact compact_of_is_closed_subset (is_compact_closed_ball x r) hc hr }
end

/-- The **Heine‚ÄìBorel theorem**: In a proper space, the closure of a bounded set is compact. -/
lemma bounded.is_compact_closure [proper_space Œ±] (h : bounded s) :
  is_compact (closure s) :=
is_compact_of_is_closed_bounded is_closed_closure h.closure

/-- The **Heine‚ÄìBorel theorem**:
In a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/
lemma compact_iff_closed_bounded [t2_space Œ±] [proper_space Œ±] :
  is_compact s ‚Üî is_closed s ‚àß bounded s :=
‚ü®Œª h, ‚ü®h.is_closed, h.bounded‚ü©, Œª h, is_compact_of_is_closed_bounded h.1 h.2‚ü©

lemma compact_space_iff_bounded_univ [proper_space Œ±] : compact_space Œ± ‚Üî bounded (univ : set Œ±) :=
‚ü®@bounded_of_compact_space Œ± _ _, Œª hb, ‚ü®is_compact_of_is_closed_bounded is_closed_univ hb‚ü©‚ü©

section conditionally_complete_linear_order

variables [preorder Œ±] [compact_Icc_space Œ±]

lemma bounded_Icc (a b : Œ±) : bounded (Icc a b) :=
(totally_bounded_Icc a b).bounded

lemma bounded_Ico (a b : Œ±) : bounded (Ico a b) :=
(totally_bounded_Ico a b).bounded

lemma bounded_Ioc (a b : Œ±) : bounded (Ioc a b) :=
(totally_bounded_Ioc a b).bounded

lemma bounded_Ioo (a b : Œ±) : bounded (Ioo a b) :=
(totally_bounded_Ioo a b).bounded

/-- In a pseudo metric space with a conditionally complete linear order such that the order and the
    metric structure give the same topology, any order-bounded set is metric-bounded. -/
lemma bounded_of_bdd_above_of_bdd_below {s : set Œ±} (h‚ÇÅ : bdd_above s) (h‚ÇÇ : bdd_below s) :
  bounded s :=
let ‚ü®u, hu‚ü© := h‚ÇÅ, ‚ü®l, hl‚ü© := h‚ÇÇ in
bounded.mono (Œª x hx, mem_Icc.mpr ‚ü®hl hx, hu hx‚ü©) (bounded_Icc l u)

end conditionally_complete_linear_order

end bounded

section diam
variables {s : set Œ±} {x y z : Œ±}

/-- The diameter of a set in a metric space. To get controllable behavior even when the diameter
should be infinite, we express it in terms of the emetric.diameter -/
noncomputable def diam (s : set Œ±) : ‚Ñù := ennreal.to_real (emetric.diam s)

/-- The diameter of a set is always nonnegative -/
lemma diam_nonneg : 0 ‚â§ diam s := ennreal.to_real_nonneg

lemma diam_subsingleton (hs : s.subsingleton) : diam s = 0 :=
by simp only [diam, emetric.diam_subsingleton hs, ennreal.zero_to_real]

/-- The empty set has zero diameter -/
@[simp] lemma diam_empty : diam (‚àÖ : set Œ±) = 0 :=
diam_subsingleton subsingleton_empty

/-- A singleton has zero diameter -/
@[simp] lemma diam_singleton : diam ({x} : set Œ±) = 0 :=
diam_subsingleton subsingleton_singleton

-- Does not work as a simp-lemma, since {x, y} reduces to (insert y {x})
lemma diam_pair : diam ({x, y} : set Œ±) = dist x y :=
by simp only [diam, emetric.diam_pair, dist_edist]

-- Does not work as a simp-lemma, since {x, y, z} reduces to (insert z (insert y {x}))
lemma diam_triple :
  metric.diam ({x, y, z} : set Œ±) = max (max (dist x y) (dist x z)) (dist y z) :=
begin
  simp only [metric.diam, emetric.diam_triple, dist_edist],
  rw [ennreal.to_real_max, ennreal.to_real_max];
    apply_rules [ne_of_lt, edist_lt_top, max_lt]
end

/-- If the distance between any two points in a set is bounded by some constant `C`,
then `ennreal.of_real C`  bounds the emetric diameter of this set. -/
lemma ediam_le_of_forall_dist_le {C : ‚Ñù} (h : ‚àÄ (x ‚àà s) (y ‚àà s), dist x y ‚â§ C) :
  emetric.diam s ‚â§ ennreal.of_real C :=
emetric.diam_le $
Œª x hx y hy, (edist_dist x y).symm ‚ñ∏ ennreal.of_real_le_of_real (h x hx y hy)

/-- If the distance between any two points in a set is bounded by some non-negative constant,
this constant bounds the diameter. -/
lemma diam_le_of_forall_dist_le {C : ‚Ñù} (h‚ÇÄ : 0 ‚â§ C) (h : ‚àÄ (x ‚àà s) (y ‚àà s), dist x y ‚â§ C) :
  diam s ‚â§ C :=
ennreal.to_real_le_of_le_of_real h‚ÇÄ (ediam_le_of_forall_dist_le h)

/-- If the distance between any two points in a nonempty set is bounded by some constant,
this constant bounds the diameter. -/
lemma diam_le_of_forall_dist_le_of_nonempty (hs : s.nonempty) {C : ‚Ñù}
  (h : ‚àÄ (x ‚àà s) (y ‚àà s), dist x y ‚â§ C) : diam s ‚â§ C :=
have h‚ÇÄ : 0 ‚â§ C, from let ‚ü®x, hx‚ü© := hs in le_trans dist_nonneg (h x hx x hx),
diam_le_of_forall_dist_le h‚ÇÄ h

/-- The distance between two points in a set is controlled by the diameter of the set. -/
lemma dist_le_diam_of_mem' (h : emetric.diam s ‚â† ‚ä§) (hx : x ‚àà s) (hy : y ‚àà s) :
  dist x y ‚â§ diam s :=
begin
  rw [diam, dist_edist],
  rw ennreal.to_real_le_to_real (edist_ne_top _ _) h,
  exact emetric.edist_le_diam_of_mem hx hy
end

/-- Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. -/
lemma bounded_iff_ediam_ne_top : bounded s ‚Üî emetric.diam s ‚â† ‚ä§ :=
iff.intro
  (Œª ‚ü®C, hC‚ü©, ne_top_of_le_ne_top ennreal.of_real_ne_top $ ediam_le_of_forall_dist_le hC)
  (Œª h, ‚ü®diam s, Œª x hx y hy, dist_le_diam_of_mem' h hx hy‚ü©)

lemma bounded.ediam_ne_top (h : bounded s) : emetric.diam s ‚â† ‚ä§ :=
bounded_iff_ediam_ne_top.1 h

lemma ediam_univ_eq_top_iff_noncompact [proper_space Œ±] :
  emetric.diam (univ : set Œ±) = ‚àû ‚Üî noncompact_space Œ± :=
by rw [‚Üê not_compact_space_iff, compact_space_iff_bounded_univ, bounded_iff_ediam_ne_top, not_not]

@[simp] lemma ediam_univ_of_noncompact [proper_space Œ±] [noncompact_space Œ±] :
  emetric.diam (univ : set Œ±) = ‚àû :=
ediam_univ_eq_top_iff_noncompact.mpr ‚Äπ_‚Ä∫

@[simp] lemma diam_univ_of_noncompact [proper_space Œ±] [noncompact_space Œ±] :
  diam (univ : set Œ±) = 0 :=
by simp [diam]

/-- The distance between two points in a set is controlled by the diameter of the set. -/
lemma dist_le_diam_of_mem (h : bounded s) (hx : x ‚àà s) (hy : y ‚àà s) : dist x y ‚â§ diam s :=
dist_le_diam_of_mem' h.ediam_ne_top hx hy

lemma ediam_of_unbounded (h : ¬¨(bounded s)) : emetric.diam s = ‚àû :=
by rwa [bounded_iff_ediam_ne_top, not_not] at h

/-- An unbounded set has zero diameter. If you would prefer to get the value ‚àû, use `emetric.diam`.
This lemma makes it possible to avoid side conditions in some situations -/
lemma diam_eq_zero_of_unbounded (h : ¬¨(bounded s)) : diam s = 0 :=
by rw [diam, ediam_of_unbounded h, ennreal.top_to_real]

/-- If `s ‚äÜ t`, then the diameter of `s` is bounded by that of `t`, provided `t` is bounded. -/
lemma diam_mono {s t : set Œ±} (h : s ‚äÜ t) (ht : bounded t) : diam s ‚â§ diam t :=
begin
  unfold diam,
  rw ennreal.to_real_le_to_real (bounded.mono h ht).ediam_ne_top ht.ediam_ne_top,
  exact emetric.diam_mono h
end

/-- The diameter of a union is controlled by the sum of the diameters, and the distance between
any two points in each of the sets. This lemma is true without any side condition, since it is
obviously true if `s ‚à™ t` is unbounded. -/
lemma diam_union {t : set Œ±} (xs : x ‚àà s) (yt : y ‚àà t) :
  diam (s ‚à™ t) ‚â§ diam s + dist x y + diam t :=
begin
  by_cases H : bounded (s ‚à™ t),
  { have hs : bounded s, from H.mono (subset_union_left _ _),
    have ht : bounded t, from H.mono (subset_union_right _ _),
    rw [bounded_iff_ediam_ne_top] at H hs ht,
    rw [dist_edist, diam, diam, diam, ‚Üê ennreal.to_real_add, ‚Üê ennreal.to_real_add,
      ennreal.to_real_le_to_real];
      repeat { apply ennreal.add_ne_top.2; split }; try { assumption };
      try { apply edist_ne_top },
    exact emetric.diam_union xs yt },
  { rw [diam_eq_zero_of_unbounded H],
    apply_rules [add_nonneg, diam_nonneg, dist_nonneg] }
end

/-- If two sets intersect, the diameter of the union is bounded by the sum of the diameters. -/
lemma diam_union' {t : set Œ±} (h : (s ‚à© t).nonempty) : diam (s ‚à™ t) ‚â§ diam s + diam t :=
begin
  rcases h with ‚ü®x, ‚ü®xs, xt‚ü©‚ü©,
  simpa using diam_union xs xt
end

lemma diam_le_of_subset_closed_ball {r : ‚Ñù} (hr : 0 ‚â§ r) (h : s ‚äÜ closed_ball x r) :
  diam s ‚â§ 2 * r :=
diam_le_of_forall_dist_le (mul_nonneg zero_le_two hr) $ Œªa ha b hb, calc
  dist a b ‚â§ dist a x + dist b x : dist_triangle_right _ _ _
  ... ‚â§ r + r : add_le_add (h ha) (h hb)
  ... = 2 * r : by simp [mul_two, mul_comm]

/-- The diameter of a closed ball of radius `r` is at most `2 r`. -/
lemma diam_closed_ball {r : ‚Ñù} (h : 0 ‚â§ r) : diam (closed_ball x r) ‚â§ 2 * r :=
diam_le_of_subset_closed_ball h subset.rfl

/-- The diameter of a ball of radius `r` is at most `2 r`. -/
lemma diam_ball {r : ‚Ñù} (h : 0 ‚â§ r) : diam (ball x r) ‚â§ 2 * r :=
diam_le_of_subset_closed_ball h ball_subset_closed_ball

end diam

end metric

lemma comap_dist_right_at_top_le_cocompact (x : Œ±) : comap (Œª y, dist y x) at_top ‚â§ cocompact Œ± :=
begin
  refine filter.has_basis_cocompact.ge_iff.2 (Œª s hs, mem_comap.2 _),
  rcases hs.bounded.subset_ball x with ‚ü®r, hr‚ü©,
  exact ‚ü®Ioi r, Ioi_mem_at_top r, Œª y hy hys, (mem_closed_ball.1 $ hr hys).not_lt hy‚ü©
end

lemma comap_dist_left_at_top_le_cocompact (x : Œ±) : comap (dist x) at_top ‚â§ cocompact Œ± :=
by simpa only [dist_comm _ x] using comap_dist_right_at_top_le_cocompact x

lemma comap_dist_right_at_top_eq_cocompact [proper_space Œ±] (x : Œ±) :
  comap (Œª y, dist y x) at_top = cocompact Œ± :=
(comap_dist_right_at_top_le_cocompact x).antisymm $ (tendsto_dist_right_cocompact_at_top x).le_comap

lemma comap_dist_left_at_top_eq_cocompact [proper_space Œ±] (x : Œ±) :
  comap (dist x) at_top = cocompact Œ± :=
(comap_dist_left_at_top_le_cocompact x).antisymm $ (tendsto_dist_left_cocompact_at_top x).le_comap

lemma tendsto_cocompact_of_tendsto_dist_comp_at_top {f : Œ≤ ‚Üí Œ±} {l : filter Œ≤} (x : Œ±)
  (h : tendsto (Œª y, dist (f y) x) l at_top) : tendsto f l (cocompact Œ±) :=
by { refine tendsto.mono_right _ (comap_dist_right_at_top_le_cocompact x), rwa tendsto_comap_iff }

namespace int
open metric

/-- Under the coercion from `‚Ñ§` to `‚Ñù`, inverse images of compact sets are finite. -/
lemma tendsto_coe_cofinite : tendsto (coe : ‚Ñ§ ‚Üí ‚Ñù) cofinite (cocompact ‚Ñù) :=
begin
  refine tendsto_cocompact_of_tendsto_dist_comp_at_top (0 : ‚Ñù) _,
  simp only [filter.tendsto_at_top, eventually_cofinite, not_le, ‚Üê mem_ball],
  change ‚àÄ r : ‚Ñù, finite (coe ‚Åª¬π' (ball (0 : ‚Ñù) r)),
  simp [real.ball_eq_Ioo, set.finite_Ioo],
end

end int

/-- We now define `metric_space`, extending `pseudo_metric_space`. -/
class metric_space (Œ± : Type u) extends pseudo_metric_space Œ± : Type u :=
(eq_of_dist_eq_zero : ‚àÄ {x y : Œ±}, dist x y = 0 ‚Üí x = y)

/-- Construct a metric space structure whose underlying topological space structure
(definitionally) agrees which a pre-existing topology which is compatible with a given distance
function. -/
def metric_space.of_metrizable {Œ± : Type*} [topological_space Œ±] (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)
  (dist_self : ‚àÄ x : Œ±, dist x x = 0)
  (dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x)
  (dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z)
  (H : ‚àÄ s : set Œ±, is_open s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, ‚àÄ y, dist x y < Œµ ‚Üí y ‚àà s)
  (eq_of_dist_eq_zero : ‚àÄ x y : Œ±, dist x y = 0 ‚Üí x = y) : metric_space Œ± :=
{ eq_of_dist_eq_zero := eq_of_dist_eq_zero,
  ..pseudo_metric_space.of_metrizable dist dist_self dist_comm dist_triangle H }

variables {Œ≥ : Type w} [metric_space Œ≥]

theorem eq_of_dist_eq_zero {x y : Œ≥} : dist x y = 0 ‚Üí x = y :=
metric_space.eq_of_dist_eq_zero

@[simp] theorem dist_eq_zero {x y : Œ≥} : dist x y = 0 ‚Üî x = y :=
iff.intro eq_of_dist_eq_zero (assume : x = y, this ‚ñ∏ dist_self _)

@[simp] theorem zero_eq_dist {x y : Œ≥} : 0 = dist x y ‚Üî x = y :=
by rw [eq_comm, dist_eq_zero]

theorem dist_ne_zero {x y : Œ≥} : dist x y ‚â† 0 ‚Üî x ‚â† y :=
by simpa only [not_iff_not] using dist_eq_zero

@[simp] theorem dist_le_zero {x y : Œ≥} : dist x y ‚â§ 0 ‚Üî x = y :=
by simpa [le_antisymm_iff, dist_nonneg] using @dist_eq_zero _ _ x y

@[simp] theorem dist_pos {x y : Œ≥} : 0 < dist x y ‚Üî x ‚â† y :=
by simpa only [not_le] using not_congr dist_le_zero

theorem eq_of_forall_dist_le {x y : Œ≥} (h : ‚àÄ Œµ > 0, dist x y ‚â§ Œµ) : x = y :=
eq_of_dist_eq_zero (eq_of_le_of_forall_le_of_dense dist_nonneg h)

/--Deduce the equality of points with the vanishing of the nonnegative distance-/
theorem eq_of_nndist_eq_zero {x y : Œ≥} : nndist x y = 0 ‚Üí x = y :=
by simp only [‚Üê nnreal.eq_iff, ‚Üê dist_nndist, imp_self, nnreal.coe_zero, dist_eq_zero]

/--Characterize the equality of points with the vanishing of the nonnegative distance-/
@[simp] theorem nndist_eq_zero {x y : Œ≥} : nndist x y = 0 ‚Üî x = y :=
by simp only [‚Üê nnreal.eq_iff, ‚Üê dist_nndist, imp_self, nnreal.coe_zero, dist_eq_zero]

@[simp] theorem zero_eq_nndist {x y : Œ≥} : 0 = nndist x y ‚Üî x = y :=
by simp only [‚Üê nnreal.eq_iff, ‚Üê dist_nndist, imp_self, nnreal.coe_zero, zero_eq_dist]

namespace metric

variables {x : Œ≥} {s : set Œ≥}

@[simp] lemma closed_ball_zero : closed_ball x 0 = {x} :=
set.ext $ Œª y, dist_le_zero

@[simp] lemma sphere_zero : sphere x 0 = {x} :=
set.ext $ Œª y, dist_eq_zero

/-- A map between metric spaces is a uniform embedding if and only if the distance between `f x`
and `f y` is controlled in terms of the distance between `x` and `y` and conversely. -/
theorem uniform_embedding_iff' [metric_space Œ≤] {f : Œ≥ ‚Üí Œ≤} :
  uniform_embedding f ‚Üî
  (‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ {a b : Œ≥}, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ) ‚àß
  (‚àÄ Œ¥ > 0, ‚àÉ Œµ > 0, ‚àÄ {a b : Œ≥}, dist (f a) (f b) < Œµ ‚Üí dist a b < Œ¥) :=
begin
  split,
  { assume h,
    exact ‚ü®uniform_continuous_iff.1 (uniform_embedding_iff.1 h).2.1,
          (uniform_embedding_iff.1 h).2.2‚ü© },
  { rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    refine uniform_embedding_iff.2 ‚ü®_, uniform_continuous_iff.2 h‚ÇÅ, h‚ÇÇ‚ü©,
    assume x y hxy,
    have : dist x y ‚â§ 0,
    { refine le_of_forall_lt' (ŒªŒ¥ Œ¥pos, _),
      rcases h‚ÇÇ Œ¥ Œ¥pos with ‚ü®Œµ, Œµpos, hŒµ‚ü©,
      have : dist (f x) (f y) < Œµ, by simpa [hxy],
      exact hŒµ this },
    simpa using this }
end

@[priority 100] -- see Note [lower instance priority]
instance metric_space.to_separated : separated_space Œ≥ :=
separated_def.2 $ Œª x y h, eq_of_forall_dist_le $
  Œª Œµ Œµ0, le_of_lt (h _ (dist_mem_uniformity Œµ0))

/-- If a  `pseudo_metric_space` is separated, then it is a `metric_space`. -/
def of_t2_pseudo_metric_space {Œ± : Type*} [pseudo_metric_space Œ±]
  (h : separated_space Œ±) : metric_space Œ± :=
{ eq_of_dist_eq_zero := Œª x y hdist,
  begin
    refine separated_def.1 h x y (Œª s hs, _),
    obtain ‚ü®Œµ, hŒµ, H‚ü© := mem_uniformity_dist.1 hs,
    exact H (show dist x y < Œµ, by rwa [hdist])
  end
  ..‚Äπpseudo_metric_space Œ±‚Ä∫ }

/-- A metric space induces an emetric space -/
@[priority 100] -- see Note [lower instance priority]
instance metric_space.to_emetric_space : emetric_space Œ≥ :=
{ eq_of_edist_eq_zero := assume x y h, by simpa [edist_dist] using h,
  ..pseudo_metric_space.to_pseudo_emetric_space, }

lemma is_closed_of_pairwise_le_dist {s : set Œ≥} {Œµ : ‚Ñù} (hŒµ : 0 < Œµ)
  (hs : s.pairwise (Œª x y, Œµ ‚â§ dist x y)) : is_closed s :=
is_closed_of_spaced_out (dist_mem_uniformity hŒµ) $ by simpa using hs

lemma closed_embedding_of_pairwise_le_dist {Œ± : Type*} [topological_space Œ±] [discrete_topology Œ±]
  {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {f : Œ± ‚Üí Œ≥} (hf : pairwise (Œª x y, Œµ ‚â§ dist (f x) (f y))) :
  closed_embedding f :=
closed_embedding_of_spaced_out (dist_mem_uniformity hŒµ) $ by simpa using hf

/-- If `f : Œ≤ ‚Üí Œ±` sends any two distinct points to points at distance at least `Œµ > 0`, then
`f` is a uniform embedding with respect to the discrete uniformity on `Œ≤`. -/
lemma uniform_embedding_bot_of_pairwise_le_dist {Œ≤ : Type*} {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {f : Œ≤ ‚Üí Œ±}
  (hf : pairwise (Œª x y, Œµ ‚â§ dist (f x) (f y))) : @uniform_embedding _ _ ‚ä• (by apply_instance) f :=
uniform_embedding_of_spaced_out (dist_mem_uniformity hŒµ) $ by simpa using hf

end metric

/-- Build a new metric space from an old one where the bundled uniform structure is provably
(but typically non-definitionaly) equal to some given uniform structure.
See Note [forgetful inheritance].
-/
def metric_space.replace_uniformity {Œ≥} [U : uniform_space Œ≥] (m : metric_space Œ≥)
  (H : @uniformity _ U = @uniformity _ emetric_space.to_uniform_space') :
  metric_space Œ≥ :=
{ eq_of_dist_eq_zero := @eq_of_dist_eq_zero _ _,
  ..pseudo_metric_space.replace_uniformity m.to_pseudo_metric_space H, }

  /-- One gets a metric space from an emetric space if the edistance
is everywhere finite, by pushing the edistance to reals. We set it up so that the edist and the
uniformity are defeq in the metric space and the emetric space. In this definition, the distance
is given separately, to be able to prescribe some expression which is not defeq to the push-forward
of the edistance to reals. -/
def emetric_space.to_metric_space_of_dist {Œ± : Type u} [e : emetric_space Œ±]
  (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù)
  (edist_ne_top : ‚àÄx y: Œ±, edist x y ‚â† ‚ä§)
  (h : ‚àÄx y, dist x y = ennreal.to_real (edist x y)) :
  metric_space Œ± :=
{ dist := dist,
  eq_of_dist_eq_zero := Œªx y hxy,
    by simpa [h, ennreal.to_real_eq_zero_iff, edist_ne_top x y] using hxy,
  ..pseudo_emetric_space.to_pseudo_metric_space_of_dist dist edist_ne_top h, }

/-- One gets a metric space from an emetric space if the edistance
is everywhere finite, by pushing the edistance to reals. We set it up so that the edist and the
uniformity are defeq in the metric space and the emetric space. -/
def emetric_space.to_metric_space {Œ± : Type u} [e : emetric_space Œ±] (h : ‚àÄx y: Œ±, edist x y ‚â† ‚ä§) :
  metric_space Œ± :=
emetric_space.to_metric_space_of_dist (Œªx y, ennreal.to_real (edist x y)) h (Œªx y, rfl)

/-- Metric space structure pulled back by an injective function. Injectivity is necessary to
ensure that `dist x y = 0` only if `x = y`. -/
def metric_space.induced {Œ≥ Œ≤} (f : Œ≥ ‚Üí Œ≤) (hf : function.injective f)
  (m : metric_space Œ≤) : metric_space Œ≥ :=
{ eq_of_dist_eq_zero := Œª x y h, hf (dist_eq_zero.1 h),
  ..pseudo_metric_space.induced f m.to_pseudo_metric_space }

/-- Pull back a metric space structure by a uniform embedding. This is a version of
`metric_space.induced` useful in case if the domain already has a `uniform_space` structure. -/
def uniform_embedding.comap_metric_space {Œ± Œ≤} [uniform_space Œ±] [metric_space Œ≤] (f : Œ± ‚Üí Œ≤)
  (h : uniform_embedding f) : metric_space Œ± :=
(metric_space.induced f h.inj ‚Äπ_‚Ä∫).replace_uniformity h.comap_uniformity.symm

instance subtype.metric_space {Œ± : Type*} {p : Œ± ‚Üí Prop} [t : metric_space Œ±] :
  metric_space (subtype p) :=
metric_space.induced coe (Œª x y, subtype.ext) t

theorem subtype.dist_eq {p : Œ± ‚Üí Prop} (x y : subtype p) : dist x y = dist (x : Œ±) y := rfl

instance : metric_space empty :=
{ dist := Œª _ _, 0,
  dist_self := Œª _, rfl,
  dist_comm := Œª _ _, rfl,
  eq_of_dist_eq_zero := Œª _ _ _, subsingleton.elim _ _,
  dist_triangle := Œª _ _ _, show (0:‚Ñù) ‚â§ 0 + 0, by rw add_zero, }

instance : metric_space punit :=
{ dist := Œª _ _, 0,
  dist_self := Œª _, rfl,
  dist_comm := Œª _ _, rfl,
  eq_of_dist_eq_zero := Œª _ _ _, subsingleton.elim _ _,
  dist_triangle := Œª _ _ _, show (0:‚Ñù) ‚â§ 0 + 0, by rw add_zero, }

section real

/-- Instantiate the reals as a metric space. -/
noncomputable instance real.metric_space : metric_space ‚Ñù :=
{ eq_of_dist_eq_zero := Œª x y h, by simpa [dist, sub_eq_zero] using h,
  ..real.pseudo_metric_space }

end real

section nnreal

noncomputable instance : metric_space ‚Ñù‚â•0 := subtype.metric_space

end nnreal

section prod

noncomputable instance prod.metric_space_max [metric_space Œ≤] : metric_space (Œ≥ √ó Œ≤) :=
{ eq_of_dist_eq_zero := Œª x y h, begin
    cases max_le_iff.1 (le_of_eq h) with h‚ÇÅ h‚ÇÇ,
    exact prod.ext_iff.2 ‚ü®dist_le_zero.1 h‚ÇÅ, dist_le_zero.1 h‚ÇÇ‚ü©
  end,
  ..prod.pseudo_metric_space_max, }

end prod

section pi
open finset
variables {œÄ : Œ≤ ‚Üí Type*} [fintype Œ≤] [‚àÄb, metric_space (œÄ b)]

/-- A finite product of metric spaces is a metric space, with the sup distance. -/
noncomputable instance metric_space_pi : metric_space (Œ†b, œÄ b) :=
  /- we construct the instance from the emetric space instance to avoid checking again that the
  uniformity is the same as the product uniformity, but we register nevertheless a nice formula
  for the distance -/
{ eq_of_dist_eq_zero := assume f g eq0,
  begin
    have eq1 : edist f g = 0 := by simp only [edist_dist, eq0, ennreal.of_real_zero],
    have eq2 : sup univ (Œª (b : Œ≤), edist (f b) (g b)) ‚â§ 0 := le_of_eq eq1,
    simp only [finset.sup_le_iff] at eq2,
    exact (funext $ assume b, edist_le_zero.1 $ eq2 b $ mem_univ b)
  end,
  ..pseudo_metric_space_pi }

end pi

namespace metric
section second_countable
open topological_space

/-- A metric space is second countable if one can reconstruct up to any `Œµ>0` any element of the
space from countably many data. -/
lemma second_countable_of_countable_discretization {Œ± : Type u} [metric_space Œ±]
  (H : ‚àÄŒµ > (0 : ‚Ñù), ‚àÉ (Œ≤ : Type*) (_ : encodable Œ≤) (F : Œ± ‚Üí Œ≤), ‚àÄx y, F x = F y ‚Üí dist x y ‚â§ Œµ) :
  second_countable_topology Œ± :=
begin
  cases (univ : set Œ±).eq_empty_or_nonempty with hs hs,
  { haveI : compact_space Œ± := ‚ü®by rw hs; exact is_compact_empty‚ü©, by apply_instance },
  rcases hs with ‚ü®x0, hx0‚ü©,
  letI : inhabited Œ± := ‚ü®x0‚ü©,
  refine second_countable_of_almost_dense_set (ŒªŒµ Œµ0, _),
  rcases H Œµ Œµ0 with ‚ü®Œ≤, fŒ≤, F, hF‚ü©,
  resetI,
  let Finv := function.inv_fun F,
  refine ‚ü®range Finv, ‚ü®countable_range _, Œªx, _‚ü©‚ü©,
  let x' := Finv (F x),
  have : F x' = F x := function.inv_fun_eq ‚ü®x, rfl‚ü©,
  exact ‚ü®x', mem_range_self _, hF _ _ this.symm‚ü©
end

end second_countable
end metric

section eq_rel

/-- The canonical equivalence relation on a pseudometric space. -/
def pseudo_metric.dist_setoid (Œ± : Type u) [pseudo_metric_space Œ±] : setoid Œ± :=
setoid.mk (Œªx y, dist x y = 0)
begin
  unfold equivalence,
  repeat { split },
  { exact pseudo_metric_space.dist_self },
  { assume x y h, rwa pseudo_metric_space.dist_comm },
  { assume x y z hxy hyz,
    refine le_antisymm _ dist_nonneg,
    calc dist x z ‚â§ dist x y + dist y z : pseudo_metric_space.dist_triangle _ _ _
         ... = 0 + 0 : by rw [hxy, hyz]
         ... = 0 : by simp }
end

local attribute [instance] pseudo_metric.dist_setoid

/-- The canonical quotient of a pseudometric space, identifying points at distance `0`. -/
@[reducible] definition pseudo_metric_quot (Œ± : Type u) [pseudo_metric_space Œ±] : Type* :=
quotient (pseudo_metric.dist_setoid Œ±)

instance has_dist_metric_quot {Œ± : Type u} [pseudo_metric_space Œ±] :
  has_dist (pseudo_metric_quot Œ±) :=
{ dist := quotient.lift‚ÇÇ (Œªp q : Œ±, dist p q)
begin
  assume x y x' y' hxx' hyy',
  have Hxx' : dist x x' = 0 := hxx',
  have Hyy' : dist y y' = 0 := hyy',
  have A : dist x y ‚â§ dist x' y' := calc
    dist x y ‚â§ dist x x' + dist x' y : pseudo_metric_space.dist_triangle _ _ _
    ... = dist x' y : by simp [Hxx']
    ... ‚â§ dist x' y' + dist y' y : pseudo_metric_space.dist_triangle _ _ _
    ... = dist x' y' : by simp [pseudo_metric_space.dist_comm, Hyy'],
  have B : dist x' y' ‚â§ dist x y := calc
    dist x' y' ‚â§ dist x' x + dist x y' : pseudo_metric_space.dist_triangle _ _ _
    ... = dist x y' : by simp [pseudo_metric_space.dist_comm, Hxx']
    ... ‚â§ dist x y + dist y y' : pseudo_metric_space.dist_triangle _ _ _
    ... = dist x y : by simp [Hyy'],
  exact le_antisymm A B
end }

lemma pseudo_metric_quot_dist_eq {Œ± : Type u} [pseudo_metric_space Œ±] (p q : Œ±) :
  dist ‚ü¶p‚üß ‚ü¶q‚üß = dist p q := rfl

instance metric_space_quot {Œ± : Type u} [pseudo_metric_space Œ±] :
  metric_space (pseudo_metric_quot Œ±) :=
{ dist_self := begin
    refine quotient.ind (Œªy, _),
    exact pseudo_metric_space.dist_self _
  end,
  eq_of_dist_eq_zero := Œªxc yc, by exact quotient.induction_on‚ÇÇ xc yc (Œªx y H, quotient.sound H),
  dist_comm :=
    Œªxc yc, quotient.induction_on‚ÇÇ xc yc (Œªx y, pseudo_metric_space.dist_comm _ _),
  dist_triangle :=
    Œªxc yc zc, quotient.induction_on‚ÇÉ xc yc zc (Œªx y z, pseudo_metric_space.dist_triangle _ _ _) }

end eq_rel
