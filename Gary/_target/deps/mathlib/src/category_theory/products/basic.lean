/-
Copyright (c) 2017 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Stephen Morgan, Scott Morrison
-/
import category_theory.eq_to_hom

/-!
# Cartesian products of categories

We define the category instance on `C √ó D` when `C` and `D` are categories.

We define:
* `sectl C Z` : the functor `C ‚•§ C √ó D` given by `X ‚Ü¶ ‚ü®X, Z‚ü©`
* `sectr Z D` : the functor `D ‚•§ C √ó D` given by `Y ‚Ü¶ ‚ü®Z, Y‚ü©`
* `fst`       : the functor `‚ü®X, Y‚ü© ‚Ü¶ X`
* `snd`       : the functor `‚ü®X, Y‚ü© ‚Ü¶ Y`
* `swap`      : the functor `C √ó D ‚•§ D √ó C` given by `‚ü®X, Y‚ü© ‚Ü¶ ‚ü®Y, X‚ü©`
    (and the fact this is an equivalence)

We further define `evaluation : C ‚•§ (C ‚•§ D) ‚•§ D` and `evaluation_uncurried : C √ó (C ‚•§ D) ‚•§ D`,
and products of functors and natural transformations, written `F.prod G` and `Œ±.prod Œ≤`.
-/

namespace category_theory

-- declare the `v`'s first; see `category_theory.category` for an explanation
universes v‚ÇÅ v‚ÇÇ v‚ÇÉ v‚ÇÑ u‚ÇÅ u‚ÇÇ u‚ÇÉ u‚ÇÑ

section
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D]

/--
`prod C D` gives the cartesian product of two categories.

See https://stacks.math.columbia.edu/tag/001K.
-/
@[simps {not_recursive := []}] -- the generates simp lemmas like `id_fst` and `comp_snd`
instance prod : category.{max v‚ÇÅ v‚ÇÇ} (C √ó D) :=
{ hom     := Œª X Y, ((X.1) ‚ü∂ (Y.1)) √ó ((X.2) ‚ü∂ (Y.2)),
  id      := Œª X, ‚ü® ùüô (X.1), ùüô (X.2) ‚ü©,
  comp    := Œª _ _ _ f g, (f.1 ‚â´ g.1, f.2 ‚â´ g.2) }

/-- Two rfl lemmas that cannot be generated by `@[simps]`. -/
@[simp] lemma prod_id (X : C) (Y : D) : ùüô (X, Y) = (ùüô X, ùüô Y) := rfl
@[simp] lemma prod_comp {P Q R : C} {S T U : D} (f : (P, S) ‚ü∂ (Q, T)) (g : (Q, T) ‚ü∂ (R, U)) :
  f ‚â´ g = (f.1 ‚â´ g.1, f.2 ‚â´ g.2) := rfl

end

section
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÅ) [category.{v‚ÇÅ} D]
/--
`prod.category.uniform C D` is an additional instance specialised so both factors have the same
universe levels. This helps typeclass resolution.
-/
instance uniform_prod : category (C √ó D) := category_theory.prod C D
end

-- Next we define the natural functors into and out of product categories. For now this doesn't
-- address the universal properties.
namespace prod

/-- `sectl C Z` is the functor `C ‚•§ C √ó D` given by `X ‚Ü¶ (X, Z)`. -/
@[simps] def sectl
  (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] (Z : D) : C ‚•§ C √ó D :=
{ obj := Œª X, (X, Z),
  map := Œª X Y f, (f, ùüô Z) }

/-- `sectr Z D` is the functor `D ‚•§ C √ó D` given by `Y ‚Ü¶ (Z, Y)` . -/
@[simps] def sectr
  {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] (Z : C) (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D] : D ‚•§ C √ó D :=
{ obj := Œª X, (Z, X),
  map := Œª X Y f, (ùüô Z, f) }

variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D]

/-- `fst` is the functor `(X, Y) ‚Ü¶ X`. -/
@[simps] def fst : C √ó D ‚•§ C :=
{ obj := Œª X, X.1,
  map := Œª X Y f, f.1 }

/-- `snd` is the functor `(X, Y) ‚Ü¶ Y`. -/
@[simps] def snd : C √ó D ‚•§ D :=
{ obj := Œª X, X.2,
  map := Œª X Y f, f.2 }

/-- The functor swapping the factors of a cartesian product of categories, `C √ó D ‚•§ D √ó C`. -/
@[simps] def swap : C √ó D ‚•§ D √ó C :=
{ obj := Œª X, (X.2, X.1),
  map := Œª _ _ f, (f.2, f.1) }

/--
Swapping the factors of a cartesion product of categories twice is naturally isomorphic
to the identity functor.
-/
@[simps] def symmetry : swap C D ‚ãô swap D C ‚âÖ ùü≠ (C √ó D) :=
{ hom := { app := Œª X, ùüô X },
  inv := { app := Œª X, ùüô X } }

/--
The equivalence, given by swapping factors, between `C √ó D` and `D √ó C`.
-/
@[simps]
def braiding : C √ó D ‚âå D √ó C :=
equivalence.mk (swap C D) (swap D C)
  (nat_iso.of_components (Œª X, eq_to_iso (by simp)) (by tidy))
  (nat_iso.of_components (Œª X, eq_to_iso (by simp)) (by tidy))

instance swap_is_equivalence : is_equivalence (swap C D) :=
(by apply_instance : is_equivalence (braiding C D).functor)

end prod

section
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D]

/--
The "evaluation at `X`" functor, such that
`(evaluation.obj X).obj F = F.obj X`,
which is functorial in both `X` and `F`.
-/
@[simps] def evaluation : C ‚•§ (C ‚•§ D) ‚•§ D :=
{ obj := Œª X,
  { obj := Œª F, F.obj X,
    map := Œª F G Œ±, Œ±.app X, },
  map := Œª X Y f,
  { app := Œª F, F.map f,
    naturality' := Œª F G Œ±, eq.symm (Œ±.naturality f) } }

/--
The "evaluation of `F` at `X`" functor,
as a functor `C √ó (C ‚•§ D) ‚•§ D`.
-/
@[simps] def evaluation_uncurried : C √ó (C ‚•§ D) ‚•§ D :=
{ obj := Œª p, p.2.obj p.1,
  map := Œª x y f, (x.2.map f.1) ‚â´ (f.2.app y.1),
  map_comp' := Œª X Y Z f g,
  begin
    cases g, cases f, cases Z, cases Y, cases X,
    simp only [prod_comp, nat_trans.comp_app, functor.map_comp, category.assoc],
    rw [‚Üênat_trans.comp_app, nat_trans.naturality, nat_trans.comp_app,
        category.assoc, nat_trans.naturality],
  end }

end

variables {A : Type u‚ÇÅ} [category.{v‚ÇÅ} A]
          {B : Type u‚ÇÇ} [category.{v‚ÇÇ} B]
          {C : Type u‚ÇÉ} [category.{v‚ÇÉ} C]
          {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D]

namespace functor
/-- The cartesian product of two functors. -/
@[simps] def prod (F : A ‚•§ B) (G : C ‚•§ D) : A √ó C ‚•§ B √ó D :=
{ obj := Œª X, (F.obj X.1, G.obj X.2),
  map := Œª _ _ f, (F.map f.1, G.map f.2) }

/- Because of limitations in Lean 3's handling of notations, we do not setup a notation `F √ó G`.
   You can use `F.prod G` as a "poor man's infix", or just write `functor.prod F G`. -/

/-- Similar to `prod`, but both functors start from the same category `A` -/
@[simps] def prod' (F : A ‚•§ B) (G : A ‚•§ C) : A ‚•§ (B √ó C) :=
{ obj := Œª a, (F.obj a, G.obj a),
  map := Œª x y f, (F.map f, G.map f), }

end functor

namespace nat_trans

/-- The cartesian product of two natural transformations. -/
@[simps] def prod {F G : A ‚•§ B} {H I : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : H ‚ü∂ I) :
  F.prod H ‚ü∂ G.prod I :=
{ app         := Œª X, (Œ±.app X.1, Œ≤.app X.2),
  naturality' := Œª X Y f,
  begin
    cases X, cases Y,
    simp only [functor.prod_map, prod.mk.inj_iff, prod_comp],
    split; rw naturality
  end }

/- Again, it is inadvisable in Lean 3 to setup a notation `Œ± √ó Œ≤`;
   use instead `Œ±.prod Œ≤` or `nat_trans.prod Œ± Œ≤`. -/

end nat_trans

/-- `F.flip` composed with evaluation is the same as evaluating `F`. -/
@[simps]
def flip_comp_evaluation (F : A ‚•§ B ‚•§ C) (a) :
  F.flip ‚ãô (evaluation _ _).obj a ‚âÖ F.obj a :=
nat_iso.of_components (Œª b, eq_to_iso rfl) $ by tidy

end category_theory
