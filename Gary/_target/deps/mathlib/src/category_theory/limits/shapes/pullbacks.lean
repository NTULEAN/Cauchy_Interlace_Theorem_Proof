/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Markus Himmel, Bhavik Mehta, Andrew Yang
-/
import category_theory.limits.shapes.wide_pullbacks
import category_theory.limits.shapes.binary_products

/-!
# Pullbacks

We define a category `walking_cospan` (resp. `walking_span`), which is the index category
for the given data for a pullback (resp. pushout) diagram. Convenience methods `cospan f g`
and `span f g` construct functors from the walking (co)span, hitting the given morphisms.

We define `pullback f g` and `pushout f g` as limits and colimits of such functors.

## References
* [Stacks: Fibre products](https://stacks.math.columbia.edu/tag/001U)
* [Stacks: Pushouts](https://stacks.math.columbia.edu/tag/0025)
-/

noncomputable theory

open category_theory

namespace category_theory.limits

universes v‚ÇÅ v‚ÇÇ v u u‚ÇÇ

local attribute [tidy] tactic.case_bash

/--
The type of objects for the diagram indexing a pullback, defined as a special case of
`wide_pullback_shape`.
-/
abbreviation walking_cospan : Type v := wide_pullback_shape walking_pair

/-- The left point of the walking cospan. -/
@[pattern] abbreviation walking_cospan.left : walking_cospan := some walking_pair.left
/-- The right point of the walking cospan. -/
@[pattern] abbreviation walking_cospan.right : walking_cospan := some walking_pair.right
/-- The central point of the walking cospan. -/
@[pattern] abbreviation walking_cospan.one : walking_cospan := none

/--
The type of objects for the diagram indexing a pushout, defined as a special case of
`wide_pushout_shape`.
-/
abbreviation walking_span : Type v := wide_pushout_shape walking_pair

/-- The left point of the walking span. -/
@[pattern] abbreviation walking_span.left : walking_span := some walking_pair.left
/-- The right point of the walking span. -/
@[pattern] abbreviation walking_span.right : walking_span := some walking_pair.right
/-- The central point of the walking span. -/
@[pattern] abbreviation walking_span.zero : walking_span := none

namespace walking_cospan

/-- The type of arrows for the diagram indexing a pullback. -/
abbreviation hom : walking_cospan ‚Üí walking_cospan ‚Üí Type v := wide_pullback_shape.hom

/-- The left arrow of the walking cospan. -/
@[pattern] abbreviation hom.inl : left ‚ü∂ one := wide_pullback_shape.hom.term _
/-- The right arrow of the walking cospan. -/
@[pattern] abbreviation hom.inr : right ‚ü∂ one := wide_pullback_shape.hom.term _
/-- The identity arrows of the walking cospan. -/
@[pattern] abbreviation hom.id (X : walking_cospan) : X ‚ü∂ X := wide_pullback_shape.hom.id X

instance (X Y : walking_cospan) : subsingleton (X ‚ü∂ Y) := by tidy

end walking_cospan

namespace walking_span

/-- The type of arrows for the diagram indexing a pushout. -/
abbreviation hom : walking_span ‚Üí walking_span ‚Üí Type v := wide_pushout_shape.hom

/-- The left arrow of the walking span. -/
@[pattern] abbreviation hom.fst : zero ‚ü∂ left := wide_pushout_shape.hom.init _
/-- The right arrow of the walking span. -/
@[pattern] abbreviation hom.snd : zero ‚ü∂ right := wide_pushout_shape.hom.init _
/-- The identity arrows of the walking span. -/
@[pattern] abbreviation hom.id (X : walking_span) : X ‚ü∂ X := wide_pushout_shape.hom.id X

instance (X Y : walking_span) : subsingleton (X ‚ü∂ Y) := by tidy

end walking_span

section
open walking_cospan

/-- The functor between two `walking_cospan`s in different universes. -/
def walking_cospan_functor : walking_cospan.{v‚ÇÅ} ‚•§ walking_cospan.{v‚ÇÇ} :=
{ obj := by { rintro (_|_|_), exacts [one, left, right] },
  map := by { rintro _ _ (_|_|_), exacts [hom.id _, hom.inl, hom.inr] },
  map_id' := Œª X, rfl,
  map_comp' := Œª _ _ _ _ _, subsingleton.elim _ _ }

@[simp] lemma walking_cospan_functor_one : walking_cospan_functor.obj one = one := rfl
@[simp] lemma walking_cospan_functor_left : walking_cospan_functor.obj left = left := rfl
@[simp] lemma walking_cospan_functor_right : walking_cospan_functor.obj right = right := rfl
@[simp] lemma walking_cospan_functor_id (X) : walking_cospan_functor.map (ùüô X) = ùüô _ := rfl
@[simp] lemma walking_cospan_functor_inl : walking_cospan_functor.map hom.inl = hom.inl := rfl
@[simp] lemma walking_cospan_functor_inr : walking_cospan_functor.map hom.inr = hom.inr := rfl

/-- The equivalence between two `walking_cospan`s in different universes. -/
def walking_cospan_equiv : walking_cospan.{v‚ÇÅ} ‚âå walking_cospan.{v‚ÇÇ} :=
{ functor := walking_cospan_functor,
  inverse := walking_cospan_functor,
  unit_iso := nat_iso.of_components
    (Œª x, eq_to_iso (by { rcases x with (_|_|_); refl }))
    (by { rintros _ _ (_|_|_); simp }),
  counit_iso := nat_iso.of_components
    (Œª x, eq_to_iso (by { rcases x with (_|_|_); refl }))
    (by { rintros _ _ (_|_|_); simp }) }

end

section
open walking_span

/-- The functor between two `walking_span`s in different universes. -/
def walking_span_functor : walking_span.{v‚ÇÅ} ‚•§ walking_span.{v‚ÇÇ} :=
{ obj := by { rintro (_|_|_), exacts [zero, left, right] },
  map := by { rintro _ _ (_|_|_), exacts [hom.id _, hom.fst, hom.snd] },
  map_id' := Œª X, rfl,
  map_comp' := Œª _ _ _ _ _, subsingleton.elim _ _ }

@[simp] lemma walking_span_functor_zero : walking_span_functor.obj zero = zero := rfl
@[simp] lemma walking_span_functor_left : walking_span_functor.obj left = left := rfl
@[simp] lemma walking_span_functor_right : walking_span_functor.obj right = right := rfl
@[simp] lemma walking_span_functor_id (X) : walking_span_functor.map (ùüô X) = ùüô _ := rfl
@[simp] lemma walking_span_functor_fst : walking_span_functor.map hom.fst = hom.fst := rfl
@[simp] lemma walking_span_functor_snd : walking_span_functor.map hom.snd = hom.snd := rfl

/-- The equivalence between two `walking_span`s in different universes. -/
def walking_span_equiv : walking_span.{v‚ÇÅ} ‚âå walking_span.{v‚ÇÇ} :=
{ functor := walking_span_functor,
  inverse := walking_span_functor,
  unit_iso := nat_iso.of_components
    (Œª x, eq_to_iso (by { rcases x with (_|_|_); refl }))
    (by { rintros _ _ (_|_|_); simp }),
  counit_iso := nat_iso.of_components
    (Œª x, eq_to_iso (by { rcases x with (_|_|_); refl }))
    (by { rintros _ _ (_|_|_); simp }) }

end

open walking_span.hom walking_cospan.hom wide_pullback_shape.hom wide_pushout_shape.hom

variables {C : Type u} [category.{v} C]

/-- `cospan f g` is the functor from the walking cospan hitting `f` and `g`. -/
def cospan {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : walking_cospan ‚•§ C :=
wide_pullback_shape.wide_cospan Z
  (Œª j, walking_pair.cases_on j X Y) (Œª j, walking_pair.cases_on j f g)

/-- `span f g` is the functor from the walking span hitting `f` and `g`. -/
def span {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : walking_span ‚•§ C :=
wide_pushout_shape.wide_span X
  (Œª j, walking_pair.cases_on j Y Z) (Œª j, walking_pair.cases_on j f g)

@[simp] lemma cospan_left {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  (cospan f g).obj walking_cospan.left = X := rfl
@[simp] lemma span_left {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) :
  (span f g).obj walking_span.left = Y := rfl

@[simp] lemma cospan_right {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  (cospan f g).obj walking_cospan.right = Y := rfl
@[simp] lemma span_right {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) :
  (span f g).obj walking_span.right = Z := rfl

@[simp] lemma cospan_one {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  (cospan f g).obj walking_cospan.one = Z := rfl
@[simp] lemma span_zero {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) :
  (span f g).obj walking_span.zero = X := rfl

@[simp] lemma cospan_map_inl {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  (cospan f g).map walking_cospan.hom.inl = f := rfl
@[simp] lemma span_map_fst {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) :
  (span f g).map walking_span.hom.fst = f := rfl

@[simp] lemma cospan_map_inr {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :
  (cospan f g).map walking_cospan.hom.inr = g := rfl
@[simp] lemma span_map_snd {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) :
  (span f g).map walking_span.hom.snd = g := rfl

lemma cospan_map_id {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (w : walking_cospan) :
  (cospan f g).map (walking_cospan.hom.id w) = ùüô _ := rfl
lemma span_map_id {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (w : walking_span) :
  (span f g).map (walking_span.hom.id w) = ùüô _ := rfl

/-- Every diagram indexing an pullback is naturally isomorphic (actually, equal) to a `cospan` -/
@[simps {rhs_md := semireducible}]
def diagram_iso_cospan (F : walking_cospan ‚•§ C) :
  F ‚âÖ cospan (F.map inl) (F.map inr) :=
nat_iso.of_components (Œª j, eq_to_iso (by tidy)) (by tidy)

/-- Every diagram indexing a pushout is naturally isomorphic (actually, equal) to a `span` -/
@[simps {rhs_md := semireducible}]
def diagram_iso_span (F : walking_span ‚•§ C) :
  F ‚âÖ span (F.map fst) (F.map snd) :=
nat_iso.of_components (Œª j, eq_to_iso (by tidy)) (by tidy)

variables {W X Y Z : C}

/-- A pullback cone is just a cone on the cospan formed by two morphisms `f : X ‚ü∂ Z` and
    `g : Y ‚ü∂ Z`.-/
abbreviation pullback_cone (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) := cone (cospan f g)

namespace pullback_cone
variables {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}

/-- The first projection of a pullback cone. -/
abbreviation fst (t : pullback_cone f g) : t.X ‚ü∂ X := t.œÄ.app walking_cospan.left

/-- The second projection of a pullback cone. -/
abbreviation snd (t : pullback_cone f g) : t.X ‚ü∂ Y := t.œÄ.app walking_cospan.right

/-- This is a slightly more convenient method to verify that a pullback cone is a limit cone. It
    only asks for a proof of facts that carry any mathematical content -/
def is_limit_aux (t : pullback_cone f g) (lift : Œ† (s : pullback_cone f g), s.X ‚ü∂ t.X)
  (fac_left : ‚àÄ (s : pullback_cone f g), lift s ‚â´ t.fst = s.fst)
  (fac_right : ‚àÄ (s : pullback_cone f g), lift s ‚â´ t.snd = s.snd)
  (uniq : ‚àÄ (s : pullback_cone f g) (m : s.X ‚ü∂ t.X)
    (w : ‚àÄ j : walking_cospan, m ‚â´ t.œÄ.app j = s.œÄ.app j), m = lift s) :
  is_limit t :=
{ lift := lift,
  fac' := Œª s j, option.cases_on j
    (by { rw [‚Üê s.w inl, ‚Üê t.w inl, ‚Üêcategory.assoc], congr, exact fac_left s, } )
    (Œª j', walking_pair.cases_on j' (fac_left s) (fac_right s)),
  uniq' := uniq }

/-- This is another convenient method to verify that a pullback cone is a limit cone. It
    only asks for a proof of facts that carry any mathematical content, and allows access to the
    same `s` for all parts. -/
def is_limit_aux' (t : pullback_cone f g)
  (create : Œ† (s : pullback_cone f g),
    {l // l ‚â´ t.fst = s.fst ‚àß l ‚â´ t.snd = s.snd ‚àß
            ‚àÄ {m}, m ‚â´ t.fst = s.fst ‚Üí m ‚â´ t.snd = s.snd ‚Üí m = l}) :
limits.is_limit t :=
pullback_cone.is_limit_aux t
  (Œª s, (create s).1)
  (Œª s, (create s).2.1)
  (Œª s, (create s).2.2.1)
  (Œª s m w, (create s).2.2.2 (w walking_cospan.left) (w walking_cospan.right))

/-- A pullback cone on `f` and `g` is determined by morphisms `fst : W ‚ü∂ X` and `snd : W ‚ü∂ Y`
    such that `fst ‚â´ f = snd ‚â´ g`. -/
@[simps]
def mk {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) : pullback_cone f g :=
{ X := W,
  œÄ := { app := Œª j, option.cases_on j (fst ‚â´ f) (Œª j', walking_pair.cases_on j' fst snd) } }

@[simp] lemma mk_œÄ_app_left {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) :
  (mk fst snd eq).œÄ.app walking_cospan.left = fst := rfl
@[simp] lemma mk_œÄ_app_right {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) :
  (mk fst snd eq).œÄ.app walking_cospan.right = snd := rfl
@[simp] lemma mk_œÄ_app_one {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) :
  (mk fst snd eq).œÄ.app walking_cospan.one = fst ‚â´ f := rfl

@[simp] lemma mk_fst {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) :
  (mk fst snd eq).fst = fst := rfl
@[simp] lemma mk_snd {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) :
  (mk fst snd eq).snd = snd := rfl

@[reassoc] lemma condition (t : pullback_cone f g) : fst t ‚â´ f = snd t ‚â´ g :=
(t.w inl).trans (t.w inr).symm

/-- To check whether a morphism is equalized by the maps of a pullback cone, it suffices to check
  it for `fst t` and `snd t` -/
lemma equalizer_ext (t : pullback_cone f g) {W : C} {k l : W ‚ü∂ t.X}
  (h‚ÇÄ : k ‚â´ fst t = l ‚â´ fst t) (h‚ÇÅ : k ‚â´ snd t = l ‚â´ snd t) :
  ‚àÄ (j : walking_cospan), k ‚â´ t.œÄ.app j = l ‚â´ t.œÄ.app j
| (some walking_pair.left) := h‚ÇÄ
| (some walking_pair.right) := h‚ÇÅ
| none := by rw [‚Üê t.w inl, reassoc_of h‚ÇÄ]

lemma is_limit.hom_ext {t : pullback_cone f g} (ht : is_limit t) {W : C} {k l : W ‚ü∂ t.X}
  (h‚ÇÄ : k ‚â´ fst t = l ‚â´ fst t) (h‚ÇÅ : k ‚â´ snd t = l ‚â´ snd t) : k = l :=
ht.hom_ext $ equalizer_ext _ h‚ÇÄ h‚ÇÅ

lemma mono_snd_of_is_pullback_of_mono {t : pullback_cone f g} (ht : is_limit t) [mono f] :
  mono t.snd :=
‚ü®Œª W h k i, is_limit.hom_ext ht (by simp [‚Üêcancel_mono f, t.condition, reassoc_of i]) i‚ü©

lemma mono_fst_of_is_pullback_of_mono {t : pullback_cone f g} (ht : is_limit t) [mono g] :
  mono t.fst :=
‚ü®Œª W h k i, is_limit.hom_ext ht i (by simp [‚Üêcancel_mono g, ‚Üêt.condition, reassoc_of i])‚ü©

/-- If `t` is a limit pullback cone over `f` and `g` and `h : W ‚ü∂ X` and `k : W ‚ü∂ Y` are such that
    `h ‚â´ f = k ‚â´ g`, then we have `l : W ‚ü∂ t.X` satisfying `l ‚â´ fst t = h` and `l ‚â´ snd t = k`.
    -/
def is_limit.lift' {t : pullback_cone f g} (ht : is_limit t) {W : C} (h : W ‚ü∂ X) (k : W ‚ü∂ Y)
  (w : h ‚â´ f = k ‚â´ g) : {l : W ‚ü∂ t.X // l ‚â´ fst t = h ‚àß l ‚â´ snd t = k} :=
‚ü®ht.lift $ pullback_cone.mk _ _ w, ht.fac _ _, ht.fac _ _‚ü©

/--
This is a more convenient formulation to show that a `pullback_cone` constructed using
`pullback_cone.mk` is a limit cone.
-/
def is_limit.mk {W : C} {fst : W ‚ü∂ X} {snd : W ‚ü∂ Y} (eq : fst ‚â´ f = snd ‚â´ g)
  (lift : Œ† (s : pullback_cone f g), s.X ‚ü∂ W)
  (fac_left : ‚àÄ (s : pullback_cone f g), lift s ‚â´ fst = s.fst)
  (fac_right : ‚àÄ (s : pullback_cone f g), lift s ‚â´ snd = s.snd)
  (uniq : ‚àÄ (s : pullback_cone f g) (m : s.X ‚ü∂ W)
    (w_fst : m ‚â´ fst = s.fst) (w_snd : m ‚â´ snd = s.snd), m = lift s) :
  is_limit (mk fst snd eq) :=
is_limit_aux _ lift fac_left fac_right
  (Œª s m w, uniq s m (w walking_cospan.left) (w walking_cospan.right))

/-- The flip of a pullback square is a pullback square. -/
def flip_is_limit {W : C} {h : W ‚ü∂ X} {k : W ‚ü∂ Y}
  {comm : h ‚â´ f = k ‚â´ g} (t : is_limit (mk _ _ comm.symm)) :
  is_limit (mk _ _ comm) :=
is_limit_aux' _ $ Œª s,
begin
  refine ‚ü®(is_limit.lift' t _ _ s.condition.symm).1,
          (is_limit.lift' t _ _ _).2.2,
          (is_limit.lift' t _ _ _).2.1, Œª m m‚ÇÅ m‚ÇÇ, t.hom_ext _‚ü©,
  apply (mk k h _).equalizer_ext,
  { rwa (is_limit.lift' t _ _ _).2.1 },
  { rwa (is_limit.lift' t _ _ _).2.2 },
end

/--
The pullback cone `(ùüô X, ùüô X)` for the pair `(f, f)` is a limit if `f` is a mono. The converse is
shown in `mono_of_pullback_is_id`.
-/
def is_limit_mk_id_id (f : X ‚ü∂ Y) [mono f] :
  is_limit (mk (ùüô X) (ùüô X) rfl : pullback_cone f f) :=
is_limit.mk _
  (Œª s, s.fst)
  (Œª s, category.comp_id _)
  (Œª s, by rw [‚Üêcancel_mono f, category.comp_id, s.condition])
  (Œª s m m‚ÇÅ m‚ÇÇ, by simpa using m‚ÇÅ)

/--
`f` is a mono if the pullback cone `(ùüô X, ùüô X)` is a limit for the pair `(f, f)`. The converse is
given in `pullback_cone.is_id_of_mono`.
-/
lemma mono_of_is_limit_mk_id_id (f : X ‚ü∂ Y)
  (t : is_limit (mk (ùüô X) (ùüô X) rfl : pullback_cone f f)) :
  mono f :=
‚ü®Œª Z g h eq, by { rcases pullback_cone.is_limit.lift' t _ _ eq with ‚ü®_, rfl, rfl‚ü©, refl } ‚ü©

/-- Suppose `f` and `g` are two morphisms with a common codomain and `s` is a limit cone over the
    diagram formed by `f` and `g`. Suppose `f` and `g` both factor through a monomorphism `h` via
    `x` and `y`, respectively.  Then `s` is also a limit cone over the diagram formed by `x` and
    `y`.  -/
def is_limit_of_factors (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (h : W ‚ü∂ Z) [mono h]
  (x : X ‚ü∂ W) (y : Y ‚ü∂ W) (hxh : x ‚â´ h = f) (hyh : y ‚â´ h = g) (s : pullback_cone f g)
  (hs : is_limit s) : is_limit (pullback_cone.mk _ _ (show s.fst ‚â´ x = s.snd ‚â´ y,
    from (cancel_mono h).1 $ by simp only [category.assoc, hxh, hyh, s.condition])) :=
pullback_cone.is_limit_aux' _ $ Œª t,
  ‚ü®hs.lift (pullback_cone.mk t.fst t.snd $ by rw [‚Üêhxh, ‚Üêhyh, reassoc_of t.condition]),
  ‚ü®hs.fac _ walking_cospan.left, hs.fac _ walking_cospan.right, Œª r hr hr',
  begin
    apply pullback_cone.is_limit.hom_ext hs;
    simp only [pullback_cone.mk_fst, pullback_cone.mk_snd] at ‚ä¢ hr hr';
    simp only [hr, hr'];
    symmetry,
    exacts [hs.fac _ walking_cospan.left, hs.fac _ walking_cospan.right]
  end‚ü©‚ü©

/-- If `W` is the pullback of `f, g`,
it is also the pullback of `f ‚â´ i, g ‚â´ i` for any mono `i`. -/
def is_limit_of_comp_mono (f : X ‚ü∂ W) (g : Y ‚ü∂ W) (i : W ‚ü∂ Z) [mono i]
  (s : pullback_cone f g) (H : is_limit s) :
  is_limit (pullback_cone.mk _ _ (show s.fst ‚â´ f ‚â´ i = s.snd ‚â´ g ‚â´ i,
    by rw [‚Üê category.assoc, ‚Üê category.assoc, s.condition])) :=
begin
  apply pullback_cone.is_limit_aux',
  intro s,
  rcases pullback_cone.is_limit.lift' H s.fst s.snd
    ((cancel_mono i).mp (by simpa using s.condition)) with ‚ü®l, h‚ÇÅ, h‚ÇÇ‚ü©,
  refine ‚ü®l,h‚ÇÅ,h‚ÇÇ,_‚ü©,
  intros m hm‚ÇÅ hm‚ÇÇ,
  exact (pullback_cone.is_limit.hom_ext H (hm‚ÇÅ.trans h‚ÇÅ.symm) (hm‚ÇÇ.trans h‚ÇÇ.symm) : _)
end

end pullback_cone

/-- A pushout cocone is just a cocone on the span formed by two morphisms `f : X ‚ü∂ Y` and
    `g : X ‚ü∂ Z`.-/
abbreviation pushout_cocone (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) := cocone (span f g)

namespace pushout_cocone

variables {f : X ‚ü∂ Y} {g : X ‚ü∂ Z}

/-- The first inclusion of a pushout cocone. -/
abbreviation inl (t : pushout_cocone f g) : Y ‚ü∂ t.X := t.Œπ.app walking_span.left

/-- The second inclusion of a pushout cocone. -/
abbreviation inr (t : pushout_cocone f g) : Z ‚ü∂ t.X := t.Œπ.app walking_span.right

/-- This is a slightly more convenient method to verify that a pushout cocone is a colimit cocone.
    It only asks for a proof of facts that carry any mathematical content -/
def is_colimit_aux (t : pushout_cocone f g) (desc : Œ† (s : pushout_cocone f g), t.X ‚ü∂ s.X)
  (fac_left : ‚àÄ (s : pushout_cocone f g), t.inl ‚â´ desc s = s.inl)
  (fac_right : ‚àÄ (s : pushout_cocone f g), t.inr ‚â´ desc s = s.inr)
  (uniq : ‚àÄ (s : pushout_cocone f g) (m : t.X ‚ü∂ s.X)
    (w : ‚àÄ j : walking_span, t.Œπ.app j ‚â´ m = s.Œπ.app j), m = desc s) :
  is_colimit t :=
{ desc := desc,
  fac' := Œª s j, option.cases_on j (by { simp [‚Üê s.w fst, ‚Üê t.w fst, fac_left s] } )
                    (Œª j', walking_pair.cases_on j' (fac_left s) (fac_right s)),
  uniq' := uniq }

/-- This is another convenient method to verify that a pushout cocone is a colimit cocone. It
    only asks for a proof of facts that carry any mathematical content, and allows access to the
    same `s` for all parts. -/
def is_colimit_aux' (t : pushout_cocone f g)
  (create : Œ† (s : pushout_cocone f g),
    {l // t.inl ‚â´ l = s.inl ‚àß t.inr ‚â´ l = s.inr ‚àß
            ‚àÄ {m}, t.inl ‚â´ m = s.inl ‚Üí t.inr ‚â´ m = s.inr ‚Üí m = l}) :
is_colimit t :=
is_colimit_aux t
  (Œª s, (create s).1)
  (Œª s, (create s).2.1)
  (Œª s, (create s).2.2.1)
  (Œª s m w, (create s).2.2.2 (w walking_cospan.left) (w walking_cospan.right))

/-- A pushout cocone on `f` and `g` is determined by morphisms `inl : Y ‚ü∂ W` and `inr : Z ‚ü∂ W` such
    that `f ‚â´ inl = g ‚Ü† inr`. -/
@[simps]
def mk {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) : pushout_cocone f g :=
{ X := W,
  Œπ := { app := Œª j, option.cases_on j (f ‚â´ inl) (Œª j', walking_pair.cases_on j' inl inr) } }

@[simp] lemma mk_Œπ_app_left {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) :
  (mk inl inr eq).Œπ.app walking_span.left = inl := rfl
@[simp] lemma mk_Œπ_app_right {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) :
  (mk inl inr eq).Œπ.app walking_span.right = inr := rfl
@[simp] lemma mk_Œπ_app_zero {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) :
  (mk inl inr eq).Œπ.app walking_span.zero = f ‚â´ inl := rfl

@[simp] lemma mk_inl {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) :
  (mk inl inr eq).inl = inl := rfl
@[simp] lemma mk_inr {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) :
  (mk inl inr eq).inr = inr := rfl

@[reassoc] lemma condition (t : pushout_cocone f g) : f ‚â´ (inl t) = g ‚â´ (inr t) :=
(t.w fst).trans (t.w snd).symm

/-- To check whether a morphism is coequalized by the maps of a pushout cocone, it suffices to check
  it for `inl t` and `inr t` -/
lemma coequalizer_ext (t : pushout_cocone f g) {W : C} {k l : t.X ‚ü∂ W}
  (h‚ÇÄ : inl t ‚â´ k = inl t ‚â´ l) (h‚ÇÅ : inr t ‚â´ k = inr t ‚â´ l) :
  ‚àÄ (j : walking_span), t.Œπ.app j ‚â´ k = t.Œπ.app j ‚â´ l
| (some walking_pair.left) := h‚ÇÄ
| (some walking_pair.right) := h‚ÇÅ
| none := by rw [‚Üê t.w fst, category.assoc, category.assoc, h‚ÇÄ]

lemma is_colimit.hom_ext {t : pushout_cocone f g} (ht : is_colimit t) {W : C} {k l : t.X ‚ü∂ W}
  (h‚ÇÄ : inl t ‚â´ k = inl t ‚â´ l) (h‚ÇÅ : inr t ‚â´ k = inr t ‚â´ l) : k = l :=
ht.hom_ext $ coequalizer_ext _ h‚ÇÄ h‚ÇÅ

/-- If `t` is a colimit pushout cocone over `f` and `g` and `h : Y ‚ü∂ W` and `k : Z ‚ü∂ W` are
    morphisms satisfying `f ‚â´ h = g ‚â´ k`, then we have a factorization `l : t.X ‚ü∂ W` such that
    `inl t ‚â´ l = h` and `inr t ‚â´ l = k`. -/
def is_colimit.desc' {t : pushout_cocone f g} (ht : is_colimit t) {W : C} (h : Y ‚ü∂ W) (k : Z ‚ü∂ W)
  (w : f ‚â´ h = g ‚â´ k) : {l : t.X ‚ü∂ W // inl t ‚â´ l = h ‚àß inr t ‚â´ l = k } :=
‚ü®ht.desc $ pushout_cocone.mk _ _ w, ht.fac _ _, ht.fac _ _‚ü©

lemma epi_inr_of_is_pushout_of_epi {t : pushout_cocone f g} (ht : is_colimit t) [epi f] :
  epi t.inr :=
‚ü®Œª W h k i, is_colimit.hom_ext ht (by simp [‚Üêcancel_epi f, t.condition_assoc, i]) i‚ü©

lemma epi_inl_of_is_pushout_of_epi {t : pushout_cocone f g} (ht : is_colimit t) [epi g] :
  epi t.inl :=
‚ü®Œª W h k i, is_colimit.hom_ext ht i (by simp [‚Üêcancel_epi g, ‚Üêt.condition_assoc, i])‚ü©

/--
This is a more convenient formulation to show that a `pushout_cocone` constructed using
`pushout_cocone.mk` is a colimit cocone.
-/
def is_colimit.mk {W : C} {inl : Y ‚ü∂ W} {inr : Z ‚ü∂ W} (eq : f ‚â´ inl = g ‚â´ inr)
  (desc : Œ† (s : pushout_cocone f g), W ‚ü∂ s.X)
  (fac_left : ‚àÄ (s : pushout_cocone f g), inl ‚â´ desc s = s.inl)
  (fac_right : ‚àÄ (s : pushout_cocone f g), inr ‚â´ desc s = s.inr)
  (uniq : ‚àÄ (s : pushout_cocone f g) (m : W ‚ü∂ s.X)
    (w_inl : inl ‚â´ m = s.inl) (w_inr : inr ‚â´ m = s.inr), m = desc s) :
  is_colimit (mk inl inr eq) :=
is_colimit_aux _ desc fac_left fac_right
  (Œª s m w, uniq s m (w walking_cospan.left) (w walking_cospan.right))

/-- The flip of a pushout square is a pushout square. -/
def flip_is_colimit {W : C} {h : Y ‚ü∂ W} {k : Z ‚ü∂ W}
  {comm : f ‚â´ h = g ‚â´ k} (t : is_colimit (mk _ _ comm.symm)) :
  is_colimit (mk _ _ comm) :=
is_colimit_aux' _ $ Œª s,
begin
  refine ‚ü®(is_colimit.desc' t _ _ s.condition.symm).1,
          (is_colimit.desc' t _ _ _).2.2,
          (is_colimit.desc' t _ _ _).2.1, Œª m m‚ÇÅ m‚ÇÇ, t.hom_ext _‚ü©,
  apply (mk k h _).coequalizer_ext,
  { rwa (is_colimit.desc' t _ _ _).2.1 },
  { rwa (is_colimit.desc' t _ _ _).2.2 },
end

/--
The pushout cocone `(ùüô X, ùüô X)` for the pair `(f, f)` is a colimit if `f` is an epi. The converse is
shown in `epi_of_is_colimit_mk_id_id`.
-/
def is_colimit_mk_id_id (f : X ‚ü∂ Y) [epi f] :
  is_colimit (mk (ùüô Y) (ùüô Y) rfl : pushout_cocone f f) :=
is_colimit.mk _
  (Œª s, s.inl)
  (Œª s, category.id_comp _)
  (Œª s, by rw [‚Üêcancel_epi f, category.id_comp, s.condition])
  (Œª s m m‚ÇÅ m‚ÇÇ, by simpa using m‚ÇÅ)

/--
`f` is an epi if the pushout cocone `(ùüô X, ùüô X)` is a colimit for the pair `(f, f)`.
The converse is given in `pushout_cocone.is_colimit_mk_id_id`.
-/
lemma epi_of_is_colimit_mk_id_id (f : X ‚ü∂ Y)
  (t : is_colimit (mk (ùüô Y) (ùüô Y) rfl : pushout_cocone f f)) :
  epi f :=
‚ü®Œª Z g h eq, by { rcases pushout_cocone.is_colimit.desc' t _ _ eq with ‚ü®_, rfl, rfl‚ü©, refl }‚ü©

/-- Suppose `f` and `g` are two morphisms with a common domain and `s` is a colimit cocone over the
    diagram formed by `f` and `g`. Suppose `f` and `g` both factor through an epimorphism `h` via
    `x` and `y`, respectively. Then `s` is also a colimit cocone over the diagram formed by `x` and
    `y`.  -/
def is_colimit_of_factors (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (h : X ‚ü∂ W) [epi h]
  (x : W ‚ü∂ Y) (y : W ‚ü∂ Z) (hhx : h ‚â´ x = f) (hhy : h ‚â´ y = g) (s : pushout_cocone f g)
  (hs : is_colimit s) : is_colimit (pushout_cocone.mk _ _ (show x ‚â´ s.inl = y ‚â´ s.inr,
    from (cancel_epi h).1 $ by rw [reassoc_of hhx, reassoc_of hhy, s.condition])) :=
pushout_cocone.is_colimit_aux' _ $ Œª t,
  ‚ü®hs.desc (pushout_cocone.mk t.inl t.inr $
    by rw [‚Üêhhx, ‚Üêhhy, category.assoc, category.assoc, t.condition]),
  ‚ü®hs.fac _ walking_span.left, hs.fac _ walking_span.right, Œª r hr hr',
  begin
    apply pushout_cocone.is_colimit.hom_ext hs;
    simp only [pushout_cocone.mk_inl, pushout_cocone.mk_inr] at ‚ä¢ hr hr';
    simp only [hr, hr'];
    symmetry,
    exacts [hs.fac _ walking_span.left, hs.fac _ walking_span.right]
  end‚ü©‚ü©

/-- If `W` is the pushout of `f, g`,
it is also the pushout of `h ‚â´ f, h ‚â´ g` for any epi `h`. -/
def is_colimit_of_epi_comp (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (h : W ‚ü∂ X) [epi h]
  (s : pushout_cocone f g) (H : is_colimit s) :
  is_colimit (pushout_cocone.mk _ _ (show (h ‚â´ f) ‚â´ s.inl = (h ‚â´ g) ‚â´ s.inr,
    by rw [category.assoc, category.assoc, s.condition])) :=
begin
  apply pushout_cocone.is_colimit_aux',
  intro s,
  rcases pushout_cocone.is_colimit.desc' H s.inl s.inr
    ((cancel_epi h).mp (by simpa using s.condition)) with ‚ü®l, h‚ÇÅ, h‚ÇÇ‚ü©,
  refine ‚ü®l,h‚ÇÅ,h‚ÇÇ,_‚ü©,
  intros m hm‚ÇÅ hm‚ÇÇ,
  exact (pushout_cocone.is_colimit.hom_ext H (hm‚ÇÅ.trans h‚ÇÅ.symm) (hm‚ÇÇ.trans h‚ÇÇ.symm) : _)
end

end pushout_cocone

/-- This is a helper construction that can be useful when verifying that a category has all
    pullbacks. Given `F : walking_cospan ‚•§ C`, which is really the same as
    `cospan (F.map inl) (F.map inr)`, and a pullback cone on `F.map inl` and `F.map inr`, we
    get a cone on `F`.

    If you're thinking about using this, have a look at `has_pullbacks_of_has_limit_cospan`,
    which you may find to be an easier way of achieving your goal. -/
@[simps]
def cone.of_pullback_cone
  {F : walking_cospan ‚•§ C} (t : pullback_cone (F.map inl) (F.map inr)) : cone F :=
{ X := t.X,
  œÄ := t.œÄ ‚â´ (diagram_iso_cospan F).inv }

/-- This is a helper construction that can be useful when verifying that a category has all
    pushout. Given `F : walking_span ‚•§ C`, which is really the same as
    `span (F.map fst) (F.mal snd)`, and a pushout cocone on `F.map fst` and `F.map snd`,
    we get a cocone on `F`.

    If you're thinking about using this, have a look at `has_pushouts_of_has_colimit_span`, which
    you may find to be an easiery way of achieving your goal.  -/
@[simps]
def cocone.of_pushout_cocone
  {F : walking_span ‚•§ C} (t : pushout_cocone (F.map fst) (F.map snd)) : cocone F :=
{ X := t.X,
  Œπ := (diagram_iso_span F).hom ‚â´ t.Œπ }

/-- Given `F : walking_cospan ‚•§ C`, which is really the same as `cospan (F.map inl) (F.map inr)`,
    and a cone on `F`, we get a pullback cone on `F.map inl` and `F.map inr`. -/
@[simps]
def pullback_cone.of_cone
  {F : walking_cospan ‚•§ C} (t : cone F) : pullback_cone (F.map inl) (F.map inr) :=
{ X := t.X,
  œÄ := t.œÄ ‚â´ (diagram_iso_cospan F).hom }

/-- A diagram `walking_cospan ‚•§ C` is isomorphic to some `pullback_cone.mk` after
composing with `diagram_iso_cospan`. -/
@[simps] def pullback_cone.iso_mk {F : walking_cospan ‚•§ C} (t : cone F) :
  (cones.postcompose (diagram_iso_cospan.{v} _).hom).obj t ‚âÖ
    pullback_cone.mk (t.œÄ.app walking_cospan.left) (t.œÄ.app walking_cospan.right)
    ((t.œÄ.naturality inl).symm.trans (t.œÄ.naturality inr : _)) :=
cones.ext (iso.refl _) $ by rintro (_|(_|_)); { dsimp, simp }

/-- Given `F : walking_span ‚•§ C`, which is really the same as `span (F.map fst) (F.map snd)`,
    and a cocone on `F`, we get a pushout cocone on `F.map fst` and `F.map snd`. -/
@[simps]
def pushout_cocone.of_cocone
  {F : walking_span ‚•§ C} (t : cocone F) : pushout_cocone (F.map fst) (F.map snd) :=
{ X := t.X,
  Œπ := (diagram_iso_span F).inv ‚â´ t.Œπ }

/-- A diagram `walking_span ‚•§ C` is isomorphic to some `pushout_cocone.mk` after composing with
`diagram_iso_span`. -/
@[simps] def pushout_cocone.iso_mk {F : walking_span ‚•§ C} (t : cocone F) :
  (cocones.precompose (diagram_iso_span.{v} _).inv).obj t ‚âÖ
    pushout_cocone.mk (t.Œπ.app walking_span.left) (t.Œπ.app walking_span.right)
    ((t.Œπ.naturality fst).trans (t.Œπ.naturality snd).symm) :=
cocones.ext (iso.refl _) $ by rintro (_|(_|_)); { dsimp, simp }
/--
`has_pullback f g` represents a particular choice of limiting cone
for the pair of morphisms `f : X ‚ü∂ Z` and `g : Y ‚ü∂ Z`.
-/
abbreviation has_pullback {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) := has_limit (cospan f g)
/--
`has_pushout f g` represents a particular choice of colimiting cocone
for the pair of morphisms `f : X ‚ü∂ Y` and `g : X ‚ü∂ Z`.
-/
abbreviation has_pushout {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) := has_colimit (span f g)

/-- `pullback f g` computes the pullback of a pair of morphisms with the same target. -/
abbreviation pullback {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [has_pullback f g] :=
limit (cospan f g)
/-- `pushout f g` computes the pushout of a pair of morphisms with the same source. -/
abbreviation pushout {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [has_pushout f g] :=
colimit (span f g)

/-- The first projection of the pullback of `f` and `g`. -/
abbreviation pullback.fst {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [has_pullback f g] :
  pullback f g ‚ü∂ X :=
limit.œÄ (cospan f g) walking_cospan.left

/-- The second projection of the pullback of `f` and `g`. -/
abbreviation pullback.snd {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [has_pullback f g] :
  pullback f g ‚ü∂ Y :=
limit.œÄ (cospan f g) walking_cospan.right

/-- The first inclusion into the pushout of `f` and `g`. -/
abbreviation pushout.inl {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [has_pushout f g] :
  Y ‚ü∂ pushout f g :=
colimit.Œπ (span f g) walking_span.left

/-- The second inclusion into the pushout of `f` and `g`. -/
abbreviation pushout.inr {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [has_pushout f g] :
  Z ‚ü∂ pushout f g :=
colimit.Œπ (span f g) walking_span.right

/-- A pair of morphisms `h : W ‚ü∂ X` and `k : W ‚ü∂ Y` satisfying `h ‚â´ f = k ‚â´ g` induces a morphism
    `pullback.lift : W ‚ü∂ pullback f g`. -/
abbreviation pullback.lift {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [has_pullback f g]
  (h : W ‚ü∂ X) (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) : W ‚ü∂ pullback f g :=
limit.lift _ (pullback_cone.mk h k w)

/-- A pair of morphisms `h : Y ‚ü∂ W` and `k : Z ‚ü∂ W` satisfying `f ‚â´ h = g ‚â´ k` induces a morphism
    `pushout.desc : pushout f g ‚ü∂ W`. -/
abbreviation pushout.desc {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [has_pushout f g]
  (h : Y ‚ü∂ W) (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) : pushout f g ‚ü∂ W :=
colimit.desc _ (pushout_cocone.mk h k w)

@[simp, reassoc]
lemma pullback.lift_fst {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [has_pullback f g]
  (h : W ‚ü∂ X) (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) : pullback.lift h k w ‚â´ pullback.fst = h :=
limit.lift_œÄ _ _

@[simp, reassoc]
lemma pullback.lift_snd {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [has_pullback f g]
  (h : W ‚ü∂ X) (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) : pullback.lift h k w ‚â´ pullback.snd = k :=
limit.lift_œÄ _ _

@[simp, reassoc]
lemma pushout.inl_desc {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [has_pushout f g]
  (h : Y ‚ü∂ W) (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) : pushout.inl ‚â´ pushout.desc h k w = h :=
colimit.Œπ_desc _ _

@[simp, reassoc]
lemma pushout.inr_desc {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [has_pushout f g]
  (h : Y ‚ü∂ W) (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) : pushout.inr ‚â´ pushout.desc h k w = k :=
colimit.Œπ_desc _ _

/-- A pair of morphisms `h : W ‚ü∂ X` and `k : W ‚ü∂ Y` satisfying `h ‚â´ f = k ‚â´ g` induces a morphism
    `l : W ‚ü∂ pullback f g` such that `l ‚â´ pullback.fst = h` and `l ‚â´ pullback.snd = k`. -/
def pullback.lift' {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [has_pullback f g]
  (h : W ‚ü∂ X) (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) :
  {l : W ‚ü∂ pullback f g // l ‚â´ pullback.fst = h ‚àß l ‚â´ pullback.snd = k} :=
‚ü®pullback.lift h k w, pullback.lift_fst _ _ _, pullback.lift_snd _ _ _‚ü©

/-- A pair of morphisms `h : Y ‚ü∂ W` and `k : Z ‚ü∂ W` satisfying `f ‚â´ h = g ‚â´ k` induces a morphism
    `l : pushout f g ‚ü∂ W` such that `pushout.inl ‚â´ l = h` and `pushout.inr ‚â´ l = k`. -/
def pullback.desc' {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [has_pushout f g]
  (h : Y ‚ü∂ W) (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) :
  {l : pushout f g ‚ü∂ W // pushout.inl ‚â´ l = h ‚àß pushout.inr ‚â´ l = k} :=
‚ü®pushout.desc h k w, pushout.inl_desc _ _ _, pushout.inr_desc _ _ _‚ü©

@[reassoc]
lemma pullback.condition {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [has_pullback f g] :
  (pullback.fst : pullback f g ‚ü∂ X) ‚â´ f = pullback.snd ‚â´ g :=
pullback_cone.condition _

@[reassoc]
lemma pushout.condition {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [has_pushout f g] :
  f ‚â´ (pushout.inl : Y ‚ü∂ pushout f g) = g ‚â´ pushout.inr :=
pushout_cocone.condition _

/--
Given such a diagram, then there is a natural morphism `W √ó‚Çõ X ‚ü∂ Y √ó‚Çú Z`.

    W  ‚ü∂  Y
      ‚Üò      ‚Üò
        S  ‚ü∂  T
      ‚Üó      ‚Üó
    X  ‚ü∂  Z

-/
abbreviation pullback.map {W X Y Z S T : C} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) [has_pullback f‚ÇÅ f‚ÇÇ]
  (g‚ÇÅ : Y ‚ü∂ T) (g‚ÇÇ : Z ‚ü∂ T) [has_pullback g‚ÇÅ g‚ÇÇ] (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T)
  (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ pullback g‚ÇÅ g‚ÇÇ :=
pullback.lift (pullback.fst ‚â´ i‚ÇÅ) (pullback.snd ‚â´ i‚ÇÇ)
  (by simp [‚Üê eq‚ÇÅ, ‚Üê eq‚ÇÇ, pullback.condition_assoc])


/--
Given such a diagram, then there is a natural morphism `W ‚®ø‚Çõ X ‚ü∂ Y ‚®ø‚Çú Z`.

        W  ‚ü∂  Y
      ‚Üó      ‚Üó
    S  ‚ü∂  T
      ‚Üò      ‚Üò
        X  ‚ü∂  Z

-/
abbreviation pushout.map {W X Y Z S T : C} (f‚ÇÅ : S ‚ü∂ W) (f‚ÇÇ : S ‚ü∂ X) [has_pushout f‚ÇÅ f‚ÇÇ]
  (g‚ÇÅ : T ‚ü∂ Y) (g‚ÇÇ : T ‚ü∂ Z) [has_pushout g‚ÇÅ g‚ÇÇ] (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T)
  (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÅ = i‚ÇÉ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÇ = i‚ÇÉ ‚â´ g‚ÇÇ) : pushout f‚ÇÅ f‚ÇÇ ‚ü∂ pushout g‚ÇÅ g‚ÇÇ :=
pushout.desc (i‚ÇÅ ‚â´ pushout.inl) (i‚ÇÇ ‚â´ pushout.inr)
  (by { simp only [‚Üê category.assoc, eq‚ÇÅ, eq‚ÇÇ], simp [pushout.condition] })


/-- Two morphisms into a pullback are equal if their compositions with the pullback morphisms are
    equal -/
@[ext] lemma pullback.hom_ext {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [has_pullback f g]
  {W : C} {k l : W ‚ü∂ pullback f g} (h‚ÇÄ : k ‚â´ pullback.fst = l ‚â´ pullback.fst)
  (h‚ÇÅ : k ‚â´ pullback.snd = l ‚â´ pullback.snd) : k = l :=
limit.hom_ext $ pullback_cone.equalizer_ext _ h‚ÇÄ h‚ÇÅ

/-- The pullback cone built from the pullback projections is a pullback. -/
def pullback_is_pullback {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [has_pullback f g] :
  is_limit (pullback_cone.mk (pullback.fst : pullback f g ‚ü∂ _) pullback.snd pullback.condition) :=
pullback_cone.is_limit.mk _ (Œª s, pullback.lift s.fst s.snd s.condition)
  (by simp) (by simp) (by tidy)

/-- The pullback of a monomorphism is a monomorphism -/
instance pullback.fst_of_mono {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [has_pullback f g]
  [mono g] : mono (pullback.fst : pullback f g ‚ü∂ X) :=
pullback_cone.mono_fst_of_is_pullback_of_mono (limit.is_limit _)

/-- The pullback of a monomorphism is a monomorphism -/
instance pullback.snd_of_mono {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [has_pullback f g]
  [mono f] : mono (pullback.snd : pullback f g ‚ü∂ Y) :=
pullback_cone.mono_snd_of_is_pullback_of_mono (limit.is_limit _)

/-- The map `X √ó[Z] Y ‚ü∂ X √ó Y` is mono. -/
instance mono_pullback_to_prod {C : Type*} [category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)
  [has_pullback f g] [has_binary_product X Y] :
  mono (prod.lift pullback.fst pullback.snd : pullback f g ‚ü∂ _) :=
‚ü®Œª W i‚ÇÅ i‚ÇÇ h, begin
  ext,
  { simpa using congr_arg (Œª f, f ‚â´ prod.fst) h },
  { simpa using congr_arg (Œª f, f ‚â´ prod.snd) h }
end‚ü©

/-- Two morphisms out of a pushout are equal if their compositions with the pushout morphisms are
    equal -/
@[ext] lemma pushout.hom_ext {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [has_pushout f g]
  {W : C} {k l : pushout f g ‚ü∂ W} (h‚ÇÄ : pushout.inl ‚â´ k = pushout.inl ‚â´ l)
  (h‚ÇÅ : pushout.inr ‚â´ k = pushout.inr ‚â´ l) : k = l :=
colimit.hom_ext $ pushout_cocone.coequalizer_ext _ h‚ÇÄ h‚ÇÅ

/-- The pushout cocone built from the pushout coprojections is a pushout. -/
def pushout_is_pushout {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [has_pushout f g] :
  is_colimit (pushout_cocone.mk (pushout.inl : _ ‚ü∂ pushout f g) pushout.inr pushout.condition) :=
pushout_cocone.is_colimit.mk _ (Œª s, pushout.desc s.inl s.inr s.condition)
  (by simp) (by simp) (by tidy)

/-- The pushout of an epimorphism is an epimorphism -/
instance pushout.inl_of_epi {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [has_pushout f g] [epi g] :
  epi (pushout.inl : Y ‚ü∂ pushout f g) :=
pushout_cocone.epi_inl_of_is_pushout_of_epi (colimit.is_colimit _)

/-- The pushout of an epimorphism is an epimorphism -/
instance pushout.inr_of_epi {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [has_pushout f g] [epi f] :
  epi (pushout.inr : Z ‚ü∂ pushout f g) :=
pushout_cocone.epi_inr_of_is_pushout_of_epi (colimit.is_colimit _)

/-- The map ` X ‚®ø Y ‚ü∂ X ‚®ø[Z] Y` is epi. -/
instance epi_coprod_to_pushout {C : Type*} [category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)
  [has_pushout f g] [has_binary_coproduct Y Z] :
  epi (coprod.desc pushout.inl pushout.inr : _ ‚ü∂ pushout f g) :=
‚ü®Œª W i‚ÇÅ i‚ÇÇ h, begin
  ext,
  { simpa using congr_arg (Œª f, coprod.inl ‚â´ f) h },
  { simpa using congr_arg (Œª f, coprod.inr ‚â´ f) h }
end‚ü©

instance pullback.map_is_iso {W X Y Z S T : C} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) [has_pullback f‚ÇÅ f‚ÇÇ]
  (g‚ÇÅ : Y ‚ü∂ T) (g‚ÇÇ : Z ‚ü∂ T) [has_pullback g‚ÇÅ g‚ÇÇ] (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T)
  (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) [is_iso i‚ÇÅ] [is_iso i‚ÇÇ] [is_iso i‚ÇÉ] :
  is_iso (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) :=
begin
  refine ‚ü®‚ü®pullback.map _ _ _ _ (inv i‚ÇÅ) (inv i‚ÇÇ) (inv i‚ÇÉ) _ _, _, _‚ü©‚ü©,
  { rw [is_iso.comp_inv_eq, category.assoc, eq‚ÇÅ, is_iso.inv_hom_id_assoc] },
  { rw [is_iso.comp_inv_eq, category.assoc, eq‚ÇÇ, is_iso.inv_hom_id_assoc] },
  tidy
end

/-- If `f‚ÇÅ = f‚ÇÇ` and `g‚ÇÅ = g‚ÇÇ`, we may construct a canonical
isomorphism `pullback f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ` -/
@[simps hom]
def pullback.congr_hom {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
  pullback f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ :=
as_iso $ pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simp [h‚ÇÅ]) (by simp [h‚ÇÇ])

@[simp]
lemma pullback.congr_hom_inv {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z}
  (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pullback f‚ÇÅ g‚ÇÅ] [has_pullback f‚ÇÇ g‚ÇÇ] :
  (pullback.congr_hom h‚ÇÅ h‚ÇÇ).inv =
    pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simp [h‚ÇÅ]) (by simp [h‚ÇÇ]) :=
begin
  apply pullback.hom_ext,
  { erw pullback.lift_fst,
    rw iso.inv_comp_eq,
    erw pullback.lift_fst_assoc,
    rw [category.comp_id, category.comp_id] },
  { erw pullback.lift_snd,
    rw iso.inv_comp_eq,
    erw pullback.lift_snd_assoc,
    rw [category.comp_id, category.comp_id] },
end

instance pushout.map_is_iso {W X Y Z S T : C} (f‚ÇÅ : S ‚ü∂ W) (f‚ÇÇ : S ‚ü∂ X) [has_pushout f‚ÇÅ f‚ÇÇ]
  (g‚ÇÅ : T ‚ü∂ Y) (g‚ÇÇ : T ‚ü∂ Z) [has_pushout g‚ÇÅ g‚ÇÇ] (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T)
  (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÅ = i‚ÇÉ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÇ = i‚ÇÉ ‚â´ g‚ÇÇ) [is_iso i‚ÇÅ] [is_iso i‚ÇÇ] [is_iso i‚ÇÉ] :
  is_iso (pushout.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) :=
begin
  refine ‚ü®‚ü®pushout.map _ _ _ _ (inv i‚ÇÅ) (inv i‚ÇÇ) (inv i‚ÇÉ) _ _, _, _‚ü©‚ü©,
  { rw [is_iso.comp_inv_eq, category.assoc, eq‚ÇÅ, is_iso.inv_hom_id_assoc] },
  { rw [is_iso.comp_inv_eq, category.assoc, eq‚ÇÇ, is_iso.inv_hom_id_assoc] },
  tidy
end

/-- If `f‚ÇÅ = f‚ÇÇ` and `g‚ÇÅ = g‚ÇÇ`, we may construct a canonical
isomorphism `pushout f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ` -/
@[simps hom]
def pushout.congr_hom {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Y} {g‚ÇÅ g‚ÇÇ : X ‚ü∂ Z}
  (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pushout f‚ÇÅ g‚ÇÅ] [has_pushout f‚ÇÇ g‚ÇÇ] :
  pushout f‚ÇÅ g‚ÇÅ ‚âÖ pushout f‚ÇÇ g‚ÇÇ :=
as_iso $ pushout.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simp [h‚ÇÅ]) (by simp [h‚ÇÇ])

@[simp]
lemma pushout.congr_hom_inv {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Y} {g‚ÇÅ g‚ÇÇ : X ‚ü∂ Z}
  (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [has_pushout f‚ÇÅ g‚ÇÅ] [has_pushout f‚ÇÇ g‚ÇÇ] :
  (pushout.congr_hom h‚ÇÅ h‚ÇÇ).inv =
    pushout.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simp [h‚ÇÅ]) (by simp [h‚ÇÇ]) :=
begin
  apply pushout.hom_ext,
  { erw pushout.inl_desc,
    rw [iso.comp_inv_eq, category.id_comp],
    erw pushout.inl_desc,
    rw category.id_comp },
  { erw pushout.inr_desc,
    rw [iso.comp_inv_eq, category.id_comp],
    erw pushout.inr_desc,
    rw category.id_comp }
end

section

variables {D : Type u‚ÇÇ} [category.{v} D] (G : C ‚•§ D)

/--
The comparison morphism for the pullback of `f,g`.
This is an isomorphism iff `G` preserves the pullback of `f,g`; see
`category_theory/limits/preserves/shapes/pullbacks.lean`
-/
def pullback_comparison (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)
  [has_pullback f g] [has_pullback (G.map f) (G.map g)] :
  G.obj (pullback f g) ‚ü∂ pullback (G.map f) (G.map g) :=
pullback.lift (G.map pullback.fst) (G.map pullback.snd)
  (by simp only [‚ÜêG.map_comp, pullback.condition])

@[simp, reassoc]
lemma pullback_comparison_comp_fst (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)
  [has_pullback f g] [has_pullback (G.map f) (G.map g)] :
  pullback_comparison G f g ‚â´ pullback.fst = G.map pullback.fst :=
pullback.lift_fst _ _ _

@[simp, reassoc]
lemma pullback_comparison_comp_snd (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)
  [has_pullback f g] [has_pullback (G.map f) (G.map g)] :
  pullback_comparison G f g ‚â´ pullback.snd = G.map pullback.snd :=
pullback.lift_snd _ _ _

@[simp, reassoc]
lemma map_lift_pullback_comparison (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)
  [has_pullback f g] [has_pullback (G.map f) (G.map g)]
  {W : C} {h : W ‚ü∂ X} {k : W ‚ü∂ Y} (w : h ‚â´ f = k ‚â´ g) :
    G.map (pullback.lift _ _ w) ‚â´ pullback_comparison G f g =
      pullback.lift (G.map h) (G.map k) (by simp only [‚ÜêG.map_comp, w]) :=
by { ext; simp [‚Üê G.map_comp] }

/--
The comparison morphism for the pushout of `f,g`.
This is an isomorphism iff `G` preserves the pushout of `f,g`; see
`category_theory/limits/preserves/shapes/pullbacks.lean`
-/
def pushout_comparison (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)
  [has_pushout f g] [has_pushout (G.map f) (G.map g)] :
  pushout (G.map f) (G.map g) ‚ü∂ G.obj (pushout f g) :=
pushout.desc (G.map pushout.inl) (G.map pushout.inr)
  (by simp only [‚ÜêG.map_comp, pushout.condition])

@[simp, reassoc]
lemma inl_comp_pushout_comparison (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)
  [has_pushout f g] [has_pushout (G.map f) (G.map g)] :
  pushout.inl ‚â´ pushout_comparison G f g = G.map pushout.inl :=
pushout.inl_desc _ _ _

@[simp, reassoc]
lemma inr_comp_pushout_comparison (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)
  [has_pushout f g] [has_pushout (G.map f) (G.map g)] :
  pushout.inr ‚â´ pushout_comparison G f g = G.map pushout.inr :=
pushout.inr_desc _ _ _

@[simp, reassoc]
lemma pushout_comparison_map_desc (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)
  [has_pushout f g] [has_pushout (G.map f) (G.map g)]
  {W : C} {h : Y ‚ü∂ W} {k : Z ‚ü∂ W} (w : f ‚â´ h = g ‚â´ k) :
    pushout_comparison G f g ‚â´ G.map (pushout.desc _ _ w) =
      pushout.desc (G.map h) (G.map k) (by simp only [‚ÜêG.map_comp, w]) :=
by { ext; simp [‚Üê G.map_comp] }

end

section pullback_symmetry

open walking_cospan

variables (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)

/-- Making this a global instance would make the typeclass seach go in an infinite loop. -/
lemma has_pullback_symmetry [has_pullback f g] : has_pullback g f :=
‚ü®‚ü®‚ü®pullback_cone.mk _ _ pullback.condition.symm,
  pullback_cone.flip_is_limit (pullback_is_pullback _ _)‚ü©‚ü©‚ü©

local attribute [instance] has_pullback_symmetry

/-- The isomorphism `X √ó[Z] Y ‚âÖ Y √ó[Z] X`. -/
def pullback_symmetry [has_pullback f g] :
  pullback f g ‚âÖ pullback g f :=
is_limit.cone_point_unique_up_to_iso
  (pullback_cone.flip_is_limit (pullback_is_pullback f g) :
    is_limit (pullback_cone.mk _ _ pullback.condition.symm))
  (limit.is_limit _)

@[simp, reassoc] lemma pullback_symmetry_hom_comp_fst [has_pullback f g] :
  (pullback_symmetry f g).hom ‚â´ pullback.fst = pullback.snd := by simp [pullback_symmetry]

@[simp, reassoc] lemma pullback_symmetry_hom_comp_snd [has_pullback f g] :
  (pullback_symmetry f g).hom ‚â´ pullback.snd = pullback.fst := by simp [pullback_symmetry]

@[simp, reassoc] lemma pullback_symmetry_inv_comp_fst [has_pullback f g] :
  (pullback_symmetry f g).inv ‚â´ pullback.fst = pullback.snd := by simp [iso.inv_comp_eq]

@[simp, reassoc] lemma pullback_symmetry_inv_comp_snd [has_pullback f g] :
  (pullback_symmetry f g).inv ‚â´ pullback.snd = pullback.fst := by simp [iso.inv_comp_eq]

end pullback_symmetry

section pushout_symmetry

open walking_cospan

variables (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)

/-- Making this a global instance would make the typeclass seach go in an infinite loop. -/
lemma has_pushout_symmetry [has_pushout f g] : has_pushout g f :=
‚ü®‚ü®‚ü®pushout_cocone.mk _ _ pushout.condition.symm,
  pushout_cocone.flip_is_colimit (pushout_is_pushout _ _)‚ü©‚ü©‚ü©

local attribute [instance] has_pushout_symmetry

/-- The isomorphism `Y ‚®ø[X] Z ‚âÖ Z ‚®ø[X] Y`. -/
def pushout_symmetry [has_pushout f g] :
  pushout f g ‚âÖ pushout g f :=
is_colimit.cocone_point_unique_up_to_iso
  (pushout_cocone.flip_is_colimit (pushout_is_pushout f g) :
    is_colimit (pushout_cocone.mk _ _ pushout.condition.symm))
  (colimit.is_colimit _)

@[simp, reassoc] lemma inl_comp_pushout_symmetry_hom [has_pushout f g] :
  pushout.inl ‚â´ (pushout_symmetry f g).hom = pushout.inr :=
(colimit.is_colimit (span f g)).comp_cocone_point_unique_up_to_iso_hom
  (pushout_cocone.flip_is_colimit (pushout_is_pushout g f)) _

@[simp, reassoc] lemma inr_comp_pushout_symmetry_hom [has_pushout f g] :
  pushout.inr ‚â´ (pushout_symmetry f g).hom = pushout.inl :=
(colimit.is_colimit (span f g)).comp_cocone_point_unique_up_to_iso_hom
  (pushout_cocone.flip_is_colimit (pushout_is_pushout g f)) _

@[simp, reassoc] lemma inl_comp_pushout_symmetry_inv [has_pushout f g] :
  pushout.inl ‚â´ (pushout_symmetry f g).inv = pushout.inr := by simp [iso.comp_inv_eq]

@[simp, reassoc] lemma inr_comp_pushout_symmetry_inv [has_pushout f g] :
  pushout.inr ‚â´ (pushout_symmetry f g).inv = pushout.inl := by simp [iso.comp_inv_eq]

end pushout_symmetry

section pullback_left_iso

open walking_cospan

/-- The pullback of `f, g` is also the pullback of `f ‚â´ i, g ‚â´ i` for any mono `i`. -/
noncomputable
def pullback_is_pullback_of_comp_mono (f : X ‚ü∂ W) (g : Y ‚ü∂ W) (i : W ‚ü∂ Z)
  [mono i] [has_pullback f g] :
  is_limit (pullback_cone.mk pullback.fst pullback.snd _) :=
pullback_cone.is_limit_of_comp_mono f g i _ (limit.is_limit (cospan f g))

instance has_pullback_of_comp_mono (f : X ‚ü∂ W) (g : Y ‚ü∂ W) (i : W ‚ü∂ Z)
  [mono i] [has_pullback f g] : has_pullback (f ‚â´ i) (g ‚â´ i) :=
‚ü®‚ü®‚ü®_,pullback_is_pullback_of_comp_mono f g i‚ü©‚ü©‚ü©

variables (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [is_iso f]

/-- If `f : X ‚ü∂ Z` is iso, then `X √ó[Z] Y ‚âÖ Y`. This is the explicit limit cone. -/
def pullback_cone_of_left_iso : pullback_cone f g :=
pullback_cone.mk (g ‚â´ inv f) (ùüô _) $ by simp

@[simp] lemma pullback_cone_of_left_iso_X :
  (pullback_cone_of_left_iso f g).X = Y := rfl

@[simp] lemma pullback_cone_of_left_iso_fst :
  (pullback_cone_of_left_iso f g).fst = g ‚â´ inv f := rfl

@[simp] lemma pullback_cone_of_left_iso_snd :
  (pullback_cone_of_left_iso f g).snd = ùüô _ := rfl

@[simp] lemma pullback_cone_of_left_iso_œÄ_app_none :
  (pullback_cone_of_left_iso f g).œÄ.app none = g := by { delta pullback_cone_of_left_iso, simp }

@[simp] lemma pullback_cone_of_left_iso_œÄ_app_left :
  (pullback_cone_of_left_iso f g).œÄ.app left = g ‚â´ inv f := rfl

@[simp] lemma pullback_cone_of_left_iso_œÄ_app_right :
  (pullback_cone_of_left_iso f g).œÄ.app right = ùüô _ := rfl

/-- Verify that the constructed limit cone is indeed a limit. -/
def pullback_cone_of_left_iso_is_limit :
  is_limit (pullback_cone_of_left_iso f g) :=
pullback_cone.is_limit_aux' _ (Œª s, ‚ü®s.snd, by simp [‚Üê s.condition_assoc]‚ü©)

lemma has_pullback_of_left_iso : has_pullback f g :=
‚ü®‚ü®‚ü®_, pullback_cone_of_left_iso_is_limit f g‚ü©‚ü©‚ü©

local attribute [instance] has_pullback_of_left_iso

instance pullback_snd_iso_of_left_iso : is_iso (pullback.snd : pullback f g ‚ü∂ _) :=
begin
  refine ‚ü®‚ü®pullback.lift (g ‚â´ inv f) (ùüô _) (by simp), _, by simp‚ü©‚ü©,
  ext,
  { simp [‚Üê pullback.condition_assoc] },
  { simp [pullback.condition_assoc] },
end

variables (i : Z ‚ü∂ W) [mono i]

instance has_pullback_of_right_factors_mono (f : X ‚ü∂ Z) : has_pullback i (f ‚â´ i) :=
by { nth_rewrite 0 ‚Üê category.id_comp i, apply_instance }

instance pullback_snd_iso_of_right_factors_mono (f : X ‚ü∂ Z) :
  is_iso (pullback.snd : pullback i (f ‚â´ i) ‚ü∂ _) :=
begin
  convert (congr_arg is_iso (show _ ‚â´ pullback.snd = _,
    from limit.iso_limit_cone_hom_œÄ ‚ü®_,pullback_is_pullback_of_comp_mono (ùüô _) f i‚ü©
      walking_cospan.right)).mp infer_instance;
    exact (category.id_comp _).symm
end

end pullback_left_iso

section pullback_right_iso

open walking_cospan

variables (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [is_iso g]

/-- If `g : Y ‚ü∂ Z` is iso, then `X √ó[Z] Y ‚âÖ X`. This is the explicit limit cone. -/
def pullback_cone_of_right_iso : pullback_cone f g :=
pullback_cone.mk (ùüô _) (f ‚â´ inv g) $ by simp

@[simp] lemma pullback_cone_of_right_iso_X :
  (pullback_cone_of_right_iso f g).X = X := rfl

@[simp] lemma pullback_cone_of_right_iso_fst :
  (pullback_cone_of_right_iso f g).fst = ùüô _ := rfl

@[simp] lemma pullback_cone_of_right_iso_snd :
  (pullback_cone_of_right_iso f g).snd = f ‚â´ inv g := rfl

@[simp] lemma pullback_cone_of_right_iso_œÄ_app_none :
  (pullback_cone_of_right_iso f g).œÄ.app none = f := category.id_comp _

@[simp] lemma pullback_cone_of_right_iso_œÄ_app_left :
  (pullback_cone_of_right_iso f g).œÄ.app left = ùüô _ := rfl

@[simp] lemma pullback_cone_of_right_iso_œÄ_app_right :
  (pullback_cone_of_right_iso f g).œÄ.app right = f ‚â´ inv g := rfl

/-- Verify that the constructed limit cone is indeed a limit. -/
def pullback_cone_of_right_iso_is_limit :
  is_limit (pullback_cone_of_right_iso f g) :=
pullback_cone.is_limit_aux' _ (Œª s, ‚ü®s.fst, by simp [s.condition_assoc]‚ü©)

lemma has_pullback_of_right_iso : has_pullback f g :=
‚ü®‚ü®‚ü®_, pullback_cone_of_right_iso_is_limit f g‚ü©‚ü©‚ü©

local attribute [instance] has_pullback_of_right_iso

instance pullback_snd_iso_of_right_iso : is_iso (pullback.fst : pullback f g ‚ü∂ _) :=
begin
  refine ‚ü®‚ü®pullback.lift (ùüô _) (f ‚â´ inv g) (by simp), _, by simp‚ü©‚ü©,
  ext,
  { simp },
  { simp [pullback.condition_assoc] },
end

variables (i : Z ‚ü∂ W) [mono i]

instance has_pullback_of_left_factors_mono (f : X ‚ü∂ Z) : has_pullback (f ‚â´ i) i :=
by { nth_rewrite 1 ‚Üê category.id_comp i, apply_instance }

instance pullback_snd_iso_of_left_factors_mono (f : X ‚ü∂ Z) :
  is_iso (pullback.fst : pullback (f ‚â´ i) i ‚ü∂ _) :=
begin
  convert (congr_arg is_iso (show _ ‚â´ pullback.fst = _,
    from limit.iso_limit_cone_hom_œÄ ‚ü®_,pullback_is_pullback_of_comp_mono f (ùüô _) i‚ü©
      walking_cospan.left)).mp infer_instance;
    exact (category.id_comp _).symm
end

end pullback_right_iso

section pushout_left_iso

open walking_span

/-- The pushout of `f, g` is also the pullback of `h ‚â´ f, h ‚â´ g` for any epi `h`. -/
noncomputable
def pushout_is_pushout_of_epi_comp (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (h : W ‚ü∂ X)
  [epi h] [has_pushout f g] :
  is_colimit (pushout_cocone.mk pushout.inl pushout.inr _) :=
pushout_cocone.is_colimit_of_epi_comp f g h _ (colimit.is_colimit (span f g))

instance has_pushout_of_epi_comp (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (h : W ‚ü∂ X)
  [epi h] [has_pushout f g] : has_pushout (h ‚â´ f) (h ‚â´ g) :=
‚ü®‚ü®‚ü®_,pushout_is_pushout_of_epi_comp f g h‚ü©‚ü©‚ü©

variables (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [is_iso f]

/-- If `f : X ‚ü∂ Y` is iso, then `Y ‚®ø[X] Z ‚âÖ Z`. This is the explicit colimit cocone. -/
def pushout_cocone_of_left_iso : pushout_cocone f g :=
pushout_cocone.mk (inv f ‚â´ g) (ùüô _) $ by simp

@[simp] lemma pushout_cocone_of_left_iso_X :
  (pushout_cocone_of_left_iso f g).X = Z := rfl

@[simp] lemma pushout_cocone_of_left_iso_inl :
  (pushout_cocone_of_left_iso f g).inl = inv f ‚â´ g := rfl

@[simp] lemma pushout_cocone_of_left_iso_inr :
  (pushout_cocone_of_left_iso f g).inr = ùüô _ := rfl

@[simp] lemma pushout_cocone_of_left_iso_Œπ_app_none :
  (pushout_cocone_of_left_iso f g).Œπ.app none = g := by { delta pushout_cocone_of_left_iso, simp }

@[simp] lemma pushout_cocone_of_left_iso_Œπ_app_left :
  (pushout_cocone_of_left_iso f g).Œπ.app left = inv f ‚â´ g := rfl

@[simp] lemma pushout_cocone_of_left_iso_Œπ_app_right :
  (pushout_cocone_of_left_iso f g).Œπ.app right = ùüô _ := rfl

/-- Verify that the constructed cocone is indeed a colimit. -/
def pushout_cocone_of_left_iso_is_limit :
  is_colimit (pushout_cocone_of_left_iso f g) :=
pushout_cocone.is_colimit_aux' _ (Œª s, ‚ü®s.inr, by simp [‚Üê s.condition]‚ü©)

lemma has_pushout_of_left_iso : has_pushout f g :=
‚ü®‚ü®‚ü®_, pushout_cocone_of_left_iso_is_limit f g‚ü©‚ü©‚ü©

local attribute [instance] has_pushout_of_left_iso

instance pushout_inr_iso_of_left_iso : is_iso (pushout.inr : _ ‚ü∂ pushout f g) :=
begin
  refine ‚ü®‚ü®pushout.desc (inv f ‚â´ g) (ùüô _) (by simp), (by simp), _‚ü©‚ü©,
  ext,
  { simp [‚Üê pushout.condition] },
  { simp [pushout.condition_assoc] },
end

variables (h : W ‚ü∂ X) [epi h]

instance has_pushout_of_right_factors_epi (f : X ‚ü∂ Y) : has_pushout h (h ‚â´ f) :=
by { nth_rewrite 0 ‚Üê category.comp_id h, apply_instance }

instance pushout_inr_iso_of_right_factors_epi (f : X ‚ü∂ Y) :
  is_iso (pushout.inr : _ ‚ü∂ pushout h (h ‚â´ f)) :=
begin
  convert (congr_arg is_iso (show pushout.inr ‚â´ _ = _,
    from colimit.iso_colimit_cocone_Œπ_inv ‚ü®_, pushout_is_pushout_of_epi_comp (ùüô _) f h‚ü©
      walking_span.right)).mp infer_instance;
    exact (category.comp_id _).symm
end

end pushout_left_iso

section pushout_right_iso

open walking_span

variables (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [is_iso g]

/-- If `f : X ‚ü∂ Z` is iso, then `Y ‚®ø[X] Z ‚âÖ Y`. This is the explicit colimit cocone. -/
def pushout_cocone_of_right_iso : pushout_cocone f g :=
pushout_cocone.mk (ùüô _) (inv g ‚â´ f) $ by simp

@[simp] lemma pushout_cocone_of_right_iso_X :
  (pushout_cocone_of_right_iso f g).X = Y := rfl

@[simp] lemma pushout_cocone_of_right_iso_inl :
  (pushout_cocone_of_right_iso f g).inl = ùüô _ := rfl

@[simp] lemma pushout_cocone_of_right_iso_inr :
  (pushout_cocone_of_right_iso f g).inr = inv g ‚â´ f := rfl

@[simp] lemma pushout_cocone_of_right_iso_Œπ_app_none :
  (pushout_cocone_of_right_iso f g).Œπ.app none = f := by { delta pushout_cocone_of_right_iso, simp }

@[simp] lemma pushout_cocone_of_right_iso_Œπ_app_left :
  (pushout_cocone_of_right_iso f g).Œπ.app left = ùüô _ := rfl

@[simp] lemma pushout_cocone_of_right_iso_Œπ_app_right :
  (pushout_cocone_of_right_iso f g).Œπ.app right = inv g ‚â´ f := rfl

/-- Verify that the constructed cocone is indeed a colimit. -/
def pushout_cocone_of_right_iso_is_limit :
  is_colimit (pushout_cocone_of_right_iso f g) :=
pushout_cocone.is_colimit_aux' _ (Œª s, ‚ü®s.inl, by simp [‚Üês.condition]‚ü©)

lemma has_pushout_of_right_iso : has_pushout f g :=
‚ü®‚ü®‚ü®_, pushout_cocone_of_right_iso_is_limit f g‚ü©‚ü©‚ü©

local attribute [instance] has_pushout_of_right_iso

instance pushout_inl_iso_of_right_iso : is_iso (pushout.inl : _ ‚ü∂ pushout f g) :=
begin
  refine ‚ü®‚ü®pushout.desc (ùüô _) (inv g ‚â´ f) (by simp), (by simp), _‚ü©‚ü©,
  ext,
  { simp [‚Üêpushout.condition] },
  { simp [pushout.condition] },
end

variables (h : W ‚ü∂ X) [epi h]

instance has_pushout_of_left_factors_epi (f : X ‚ü∂ Y) : has_pushout (h ‚â´ f) h :=
by { nth_rewrite 1 ‚Üê category.comp_id h, apply_instance }

instance pushout_inl_iso_of_left_factors_epi (f : X ‚ü∂ Y) :
  is_iso (pushout.inl : _ ‚ü∂ pushout (h ‚â´ f) h) :=
begin
  convert (congr_arg is_iso (show pushout.inl ‚â´ _ = _,
    from colimit.iso_colimit_cocone_Œπ_inv ‚ü®_, pushout_is_pushout_of_epi_comp f (ùüô _) h‚ü©
      walking_span.left)).mp infer_instance;
    exact (category.comp_id _).symm
end

end pushout_right_iso

section

open walking_cospan

variable (f : X ‚ü∂ Y)

instance has_kernel_pair_of_mono [mono f] : has_pullback f f :=
‚ü®‚ü®‚ü®_, pullback_cone.is_limit_mk_id_id f‚ü©‚ü©‚ü©

lemma fst_eq_snd_of_mono_eq [mono f] : (pullback.fst : pullback f f ‚ü∂ _) = pullback.snd :=
((pullback_cone.is_limit_mk_id_id f).fac (get_limit_cone (cospan f f)).cone left).symm.trans
  ((pullback_cone.is_limit_mk_id_id f).fac (get_limit_cone (cospan f f)).cone right : _)

@[simp] lemma pullback_symmetry_hom_of_mono_eq [mono f] :
  (pullback_symmetry f f).hom = ùüô _ := by ext; simp [fst_eq_snd_of_mono_eq]

instance fst_iso_of_mono_eq [mono f] : is_iso (pullback.fst : pullback f f ‚ü∂ _) :=
begin
  refine ‚ü®‚ü®pullback.lift (ùüô _) (ùüô _) (by simp), _, by simp‚ü©‚ü©,
  ext,
  { simp },
  { simp [fst_eq_snd_of_mono_eq] }
end

instance snd_iso_of_mono_eq [mono f] : is_iso (pullback.snd : pullback f f ‚ü∂ _) :=
by { rw ‚Üê fst_eq_snd_of_mono_eq, apply_instance }

end

section

open walking_span

variable (f : X ‚ü∂ Y)

instance has_cokernel_pair_of_epi [epi f] : has_pushout f f :=
‚ü®‚ü®‚ü®_, pushout_cocone.is_colimit_mk_id_id f‚ü©‚ü©‚ü©

lemma inl_eq_inr_of_epi_eq [epi f] : (pushout.inl : _ ‚ü∂ pushout f f) = pushout.inr :=
((pushout_cocone.is_colimit_mk_id_id f).fac (get_colimit_cocone (span f f)).cocone left).symm.trans
  ((pushout_cocone.is_colimit_mk_id_id f).fac (get_colimit_cocone (span f f)).cocone right : _)

@[simp] lemma pullback_symmetry_hom_of_epi_eq [epi f] :
  (pushout_symmetry f f).hom = ùüô _ := by ext; simp [inl_eq_inr_of_epi_eq]

instance inl_iso_of_epi_eq [epi f] : is_iso (pushout.inl : _ ‚ü∂ pushout f f) :=
begin
  refine ‚ü®‚ü®pushout.desc (ùüô _) (ùüô _) (by simp), by simp, _‚ü©‚ü©,
  ext,
  { simp },
  { simp [inl_eq_inr_of_epi_eq] }
end

instance inr_iso_of_epi_eq [epi f] : is_iso (pushout.inr : _ ‚ü∂ pushout f f) :=
by { rw ‚Üê inl_eq_inr_of_epi_eq, apply_instance }

end

section paste_lemma

variables {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Y‚ÇÉ)
variables (i‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (i‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (i‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ)
variables (h‚ÇÅ : i‚ÇÅ ‚â´ g‚ÇÅ = f‚ÇÅ ‚â´ i‚ÇÇ) (h‚ÇÇ : i‚ÇÇ ‚â´ g‚ÇÇ = f‚ÇÇ ‚â´ i‚ÇÉ)

/--
Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the big square is a pullback if both the small squares are.
-/
def big_square_is_pullback (H : is_limit (pullback_cone.mk _ _ h‚ÇÇ))
  (H' : is_limit (pullback_cone.mk _ _ h‚ÇÅ)) :
  is_limit (pullback_cone.mk _ _ (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ,
      by rw [‚Üê category.assoc, h‚ÇÅ, category.assoc, h‚ÇÇ, category.assoc])) :=
begin
  fapply pullback_cone.is_limit_aux',
  intro s,
  have : (s.fst ‚â´ g‚ÇÅ) ‚â´ g‚ÇÇ = s.snd ‚â´ i‚ÇÉ := by rw [‚Üê s.condition, category.assoc],
  rcases pullback_cone.is_limit.lift' H (s.fst ‚â´ g‚ÇÅ) s.snd this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©,
  rcases pullback_cone.is_limit.lift' H' s.fst l‚ÇÅ hl‚ÇÅ.symm with ‚ü®l‚ÇÇ, hl‚ÇÇ, hl‚ÇÇ'‚ü©,
  use l‚ÇÇ,
  use hl‚ÇÇ,
  use show l‚ÇÇ ‚â´ f‚ÇÅ ‚â´ f‚ÇÇ = s.snd, by { rw [‚Üê hl‚ÇÅ', ‚Üê hl‚ÇÇ', category.assoc], refl },
  intros m hm‚ÇÅ hm‚ÇÇ,
  apply pullback_cone.is_limit.hom_ext H',
  { erw [hm‚ÇÅ, hl‚ÇÇ] },
  { apply pullback_cone.is_limit.hom_ext H,
    { erw [category.assoc, ‚Üê h‚ÇÅ, ‚Üê category.assoc, hm‚ÇÅ, ‚Üê hl‚ÇÇ,
      category.assoc, category.assoc, h‚ÇÅ], refl },
    { erw [category.assoc, hm‚ÇÇ, ‚Üê hl‚ÇÅ', ‚Üê hl‚ÇÇ'] } }
end

/--
Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the big square is a pushout if both the small squares are.
-/
def big_square_is_pushout (H : is_colimit (pushout_cocone.mk _ _ h‚ÇÇ))
  (H' : is_colimit (pushout_cocone.mk _ _ h‚ÇÅ)) :
  is_colimit (pushout_cocone.mk _ _ (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ,
      by rw [‚Üê category.assoc, h‚ÇÅ, category.assoc, h‚ÇÇ, category.assoc])) :=
begin
  fapply pushout_cocone.is_colimit_aux',
  intro s,
  have : i‚ÇÅ ‚â´ s.inl = f‚ÇÅ ‚â´ (f‚ÇÇ ‚â´ s.inr) := by rw [s.condition, category.assoc],
  rcases pushout_cocone.is_colimit.desc' H' s.inl (f‚ÇÇ ‚â´ s.inr) this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©,
  rcases pushout_cocone.is_colimit.desc' H l‚ÇÅ s.inr hl‚ÇÅ' with ‚ü®l‚ÇÇ, hl‚ÇÇ, hl‚ÇÇ'‚ü©,
  use l‚ÇÇ,
  use show (g‚ÇÅ ‚â´ g‚ÇÇ) ‚â´ l‚ÇÇ = s.inl, by { rw [‚Üê hl‚ÇÅ, ‚Üê hl‚ÇÇ, category.assoc], refl },
  use hl‚ÇÇ',
  intros m hm‚ÇÅ hm‚ÇÇ,
  apply pushout_cocone.is_colimit.hom_ext H,
  { apply pushout_cocone.is_colimit.hom_ext H',
    { erw [‚Üê category.assoc, hm‚ÇÅ, hl‚ÇÇ, hl‚ÇÅ] },
    { erw [‚Üê category.assoc, h‚ÇÇ, category.assoc, hm‚ÇÇ, ‚Üê hl‚ÇÇ',
      ‚Üê category.assoc, ‚Üê category.assoc, ‚Üê h‚ÇÇ], refl } },
  { erw [hm‚ÇÇ, hl‚ÇÇ'] }
end

/--
Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the left square is a pullback if the right square and the big square are.
-/
def left_square_is_pullback (H : is_limit (pullback_cone.mk _ _ h‚ÇÇ))
  (H' : is_limit (pullback_cone.mk _ _ (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ,
      by rw [‚Üê category.assoc, h‚ÇÅ, category.assoc, h‚ÇÇ, category.assoc]))) :
  is_limit (pullback_cone.mk _ _ h‚ÇÅ) :=
begin
  fapply pullback_cone.is_limit_aux',
  intro s,
  have : s.fst ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (s.snd ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ :=
  by { rw [‚Üê category.assoc, s.condition, category.assoc, category.assoc, h‚ÇÇ] },
  rcases pullback_cone.is_limit.lift' H' s.fst (s.snd ‚â´ f‚ÇÇ) this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©,
  use l‚ÇÅ,
  use hl‚ÇÅ,
  split,
  { apply pullback_cone.is_limit.hom_ext H,
    { erw [category.assoc, ‚Üê h‚ÇÅ, ‚Üê category.assoc, hl‚ÇÅ, s.condition], refl },
    { erw [category.assoc, hl‚ÇÅ'], refl } },
  { intros m hm‚ÇÅ hm‚ÇÇ,
    apply pullback_cone.is_limit.hom_ext H',
    { erw [hm‚ÇÅ, hl‚ÇÅ] },
    { erw [hl‚ÇÅ', ‚Üê hm‚ÇÇ], exact (category.assoc _ _ _).symm } }
end

/--
Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the right square is a pushout if the left square and the big square are.
-/
def right_square_is_pushout (H : is_colimit (pushout_cocone.mk _ _ h‚ÇÅ))
  (H' : is_colimit (pushout_cocone.mk _ _ (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ,
      by rw [‚Üê category.assoc, h‚ÇÅ, category.assoc, h‚ÇÇ, category.assoc]))) :
  is_colimit (pushout_cocone.mk _ _ h‚ÇÇ) :=
begin
  fapply pushout_cocone.is_colimit_aux',
  intro s,
  have : i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ s.inl = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ s.inr :=
  by { rw [category.assoc, ‚Üê s.condition, ‚Üê category.assoc, ‚Üê category.assoc, h‚ÇÅ] },
  rcases pushout_cocone.is_colimit.desc' H' (g‚ÇÅ ‚â´ s.inl) s.inr this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©,
  dsimp at *,
  use l‚ÇÅ,
  refine ‚ü®_,_,_‚ü©,
  { apply pushout_cocone.is_colimit.hom_ext H,
    { erw [‚Üê category.assoc, hl‚ÇÅ], refl },
    { erw [‚Üê category.assoc, h‚ÇÇ, category.assoc, hl‚ÇÅ', s.condition] } },
  { exact hl‚ÇÅ' },
  { intros m hm‚ÇÅ hm‚ÇÇ,
    apply pushout_cocone.is_colimit.hom_ext H',
    { erw [hl‚ÇÅ, category.assoc, hm‚ÇÅ] },
    { erw [hm‚ÇÇ, hl‚ÇÅ'] } }
end

end paste_lemma

section

variables (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (f' : W ‚ü∂ X)
variables [has_pullback f g] [has_pullback f' (pullback.fst : pullback f g ‚ü∂ _)]
variables [has_pullback (f' ‚â´ f) g]

/-- The canonical isomorphism `W √ó[X] (X √ó[Z] Y) ‚âÖ W √ó[Z] Y` -/
noncomputable
def pullback_right_pullback_fst_iso :
  pullback f' (pullback.fst : pullback f g ‚ü∂ _) ‚âÖ pullback (f' ‚â´ f) g :=
begin
  let := big_square_is_pullback
    (pullback.snd : pullback f' (pullback.fst : pullback f g ‚ü∂ _) ‚ü∂ _) pullback.snd
    f' f pullback.fst pullback.fst g pullback.condition pullback.condition
    (pullback_is_pullback _ _) (pullback_is_pullback _ _),
  exact (this.cone_point_unique_up_to_iso (pullback_is_pullback _ _) : _)
end

@[simp, reassoc]
lemma pullback_right_pullback_fst_iso_hom_fst :
  (pullback_right_pullback_fst_iso f g f').hom ‚â´ pullback.fst = pullback.fst :=
is_limit.cone_point_unique_up_to_iso_hom_comp _ _ walking_cospan.left

@[simp, reassoc]
lemma pullback_right_pullback_fst_iso_hom_snd :
  (pullback_right_pullback_fst_iso f g f').hom ‚â´ pullback.snd = pullback.snd ‚â´ pullback.snd :=
is_limit.cone_point_unique_up_to_iso_hom_comp _ _ walking_cospan.right

@[simp, reassoc]
lemma pullback_right_pullback_fst_iso_inv_fst :
  (pullback_right_pullback_fst_iso f g f').inv ‚â´ pullback.fst = pullback.fst :=
is_limit.cone_point_unique_up_to_iso_inv_comp _ _ walking_cospan.left

@[simp, reassoc]
lemma pullback_right_pullback_fst_iso_inv_snd_snd :
  (pullback_right_pullback_fst_iso f g f').inv ‚â´ pullback.snd ‚â´ pullback.snd = pullback.snd :=
is_limit.cone_point_unique_up_to_iso_inv_comp _ _ walking_cospan.right

@[simp, reassoc]
lemma pullback_right_pullback_fst_iso_inv_snd_fst :
  (pullback_right_pullback_fst_iso f g f').inv ‚â´ pullback.snd ‚â´ pullback.fst = pullback.fst ‚â´ f' :=
begin
  rw ‚Üê pullback.condition,
  exact pullback_right_pullback_fst_iso_inv_fst_assoc _ _ _ _
end

end

section

variables (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (g' : Z ‚ü∂ W)
variables [has_pushout f g] [has_pushout (pushout.inr : _ ‚ü∂ pushout f g) g']
variables [has_pushout f (g ‚â´ g')]

/-- The canonical isomorphism `(Y ‚®ø[X] Z) ‚®ø[Z] W ‚âÖ Y √ó[X] W` -/
noncomputable
def pushout_left_pushout_inr_iso :
  pushout (pushout.inr : _ ‚ü∂ pushout f g) g' ‚âÖ pushout f (g ‚â´ g') :=
((big_square_is_pushout g g' _ _ f _ _ pushout.condition pushout.condition
  (pushout_is_pushout _ _) (pushout_is_pushout _ _))
  .cocone_point_unique_up_to_iso (pushout_is_pushout _ _) : _)

@[simp, reassoc]
lemma inl_pushout_left_pushout_inr_iso_inv :
  pushout.inl ‚â´ (pushout_left_pushout_inr_iso f g g').inv = pushout.inl ‚â´ pushout.inl :=
((big_square_is_pushout g g' _ _ f _ _ pushout.condition pushout.condition
  (pushout_is_pushout _ _) (pushout_is_pushout _ _))
  .comp_cocone_point_unique_up_to_iso_inv (pushout_is_pushout _ _) walking_span.left : _)

@[simp, reassoc]
lemma inr_pushout_left_pushout_inr_iso_hom :
  pushout.inr ‚â´ (pushout_left_pushout_inr_iso f g g').hom = pushout.inr :=
((big_square_is_pushout g g' _ _ f _ _ pushout.condition pushout.condition
  (pushout_is_pushout _ _) (pushout_is_pushout _ _))
  .comp_cocone_point_unique_up_to_iso_hom (pushout_is_pushout _ _) walking_span.right : _)

@[simp, reassoc]
lemma inr_pushout_left_pushout_inr_iso_inv :
  pushout.inr ‚â´ (pushout_left_pushout_inr_iso f g g').inv = pushout.inr :=
by rw [iso.comp_inv_eq, inr_pushout_left_pushout_inr_iso_hom]

@[simp, reassoc]
lemma inl_inl_pushout_left_pushout_inr_iso_hom :
  pushout.inl ‚â´ pushout.inl ‚â´ (pushout_left_pushout_inr_iso f g g').hom = pushout.inl :=
by rw [‚Üê category.assoc, ‚Üê iso.eq_comp_inv, inl_pushout_left_pushout_inr_iso_inv]

@[simp, reassoc]
lemma inr_inl_pushout_left_pushout_inr_iso_hom :
  pushout.inr ‚â´ pushout.inl ‚â´ (pushout_left_pushout_inr_iso f g g').hom = g' ‚â´ pushout.inr :=
by rw [‚Üê category.assoc, ‚Üê iso.eq_comp_inv, category.assoc,
  inr_pushout_left_pushout_inr_iso_inv, pushout.condition]

end

section pullback_assoc

/-
The objects and morphisms are as follows:

           Z‚ÇÇ - g‚ÇÑ -> X‚ÇÉ
           |          |
           g‚ÇÉ         f‚ÇÑ
           ‚à®          ‚à®
Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ
|          |
g‚ÇÅ         f‚ÇÇ
‚à®          ‚à®
X‚ÇÅ - f‚ÇÅ -> Y‚ÇÅ

where the two squares are pullbacks.

We can then construct the pullback squares

W  - l‚ÇÇ -> Z‚ÇÇ - g‚ÇÑ -> X‚ÇÉ
|                     |
l‚ÇÅ                    f‚ÇÑ
‚à®                     ‚à®
Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ

and

W' - l‚ÇÇ' -> Z‚ÇÇ
|           |
l‚ÇÅ'         g‚ÇÉ
‚à®           ‚à®
Z‚ÇÅ          X‚ÇÇ
|           |
g‚ÇÅ          f‚ÇÇ
‚à®           ‚à®
X‚ÇÅ -  f‚ÇÅ -> Y‚ÇÅ

We will show that both `W` and `W'` are pullbacks over `g‚ÇÅ, g‚ÇÇ`, and thus we may construct a
canonical isomorphism between them. -/

variables {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÉ : X‚ÇÇ ‚ü∂ Y‚ÇÇ)
variables (f‚ÇÑ : X‚ÇÉ ‚ü∂ Y‚ÇÇ) [has_pullback f‚ÇÅ f‚ÇÇ] [has_pullback f‚ÇÉ f‚ÇÑ]

include f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ

local notation `Z‚ÇÅ` := pullback f‚ÇÅ f‚ÇÇ
local notation `Z‚ÇÇ` := pullback f‚ÇÉ f‚ÇÑ
local notation `g‚ÇÅ` := (pullback.fst : Z‚ÇÅ ‚ü∂ X‚ÇÅ)
local notation `g‚ÇÇ` := (pullback.snd : Z‚ÇÅ ‚ü∂ X‚ÇÇ)
local notation `g‚ÇÉ` := (pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ)
local notation `g‚ÇÑ` := (pullback.snd : Z‚ÇÇ ‚ü∂ X‚ÇÉ)
local notation `W`  := pullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ
local notation `W'` := pullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)
local notation `l‚ÇÅ` := (pullback.fst : W ‚ü∂ Z‚ÇÅ)
local notation `l‚ÇÇ` := (pullback.lift (pullback.fst ‚â´ g‚ÇÇ) pullback.snd
    ((category.assoc _ _ _).trans pullback.condition) : W ‚ü∂ Z‚ÇÇ)
local notation `l‚ÇÅ'`:= (pullback.lift pullback.fst (pullback.snd ‚â´ g‚ÇÉ)
    (pullback.condition.trans (category.assoc _ _ _).symm) : W' ‚ü∂ Z‚ÇÅ)
local notation `l‚ÇÇ'`:= (pullback.snd : W' ‚ü∂ Z‚ÇÇ)

/-- `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ` is the pullback `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
def pullback_pullback_left_is_pullback [has_pullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] :
is_limit (pullback_cone.mk l‚ÇÅ l‚ÇÇ (show l‚ÇÅ ‚â´ g‚ÇÇ = l‚ÇÇ ‚â´ g‚ÇÉ, from (pullback.lift_fst _ _ _).symm)) :=
begin
  apply left_square_is_pullback,
  exact pullback_is_pullback f‚ÇÉ f‚ÇÑ,
  convert pullback_is_pullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ,
  rw pullback.lift_snd
end

/-- `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ` is the pullback `X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
def pullback_assoc_is_pullback [has_pullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] :
is_limit (pullback_cone.mk (l‚ÇÅ ‚â´ g‚ÇÅ) l‚ÇÇ (show (l‚ÇÅ ‚â´ g‚ÇÅ) ‚â´ f‚ÇÅ = l‚ÇÇ ‚â´ (g‚ÇÉ ‚â´ f‚ÇÇ),
  by rw [pullback.lift_fst_assoc, category.assoc, category.assoc, pullback.condition])) :=
begin
  apply pullback_cone.flip_is_limit,
  apply big_square_is_pullback,
  { apply pullback_cone.flip_is_limit,
    exact pullback_is_pullback f‚ÇÅ f‚ÇÇ },
  { apply pullback_cone.flip_is_limit,
    apply pullback_pullback_left_is_pullback },
  { exact pullback.lift_fst _ _ _ },
  { exact pullback.condition.symm }
end

lemma has_pullback_assoc [has_pullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] :
has_pullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ) :=
‚ü®‚ü®‚ü®_, pullback_assoc_is_pullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ‚ü©‚ü©‚ü©

/-- `X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)` is the pullback `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
def pullback_pullback_right_is_pullback [has_pullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)] :
is_limit (pullback_cone.mk l‚ÇÅ' l‚ÇÇ' (show l‚ÇÅ' ‚â´ g‚ÇÇ = l‚ÇÇ' ‚â´ g‚ÇÉ, from pullback.lift_snd _ _ _)) :=
begin
  apply pullback_cone.flip_is_limit,
  apply left_square_is_pullback,
  { apply pullback_cone.flip_is_limit,
    exact pullback_is_pullback f‚ÇÅ f‚ÇÇ },
  { apply pullback_cone.flip_is_limit,
    convert pullback_is_pullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ),
    rw pullback.lift_fst },
  { exact pullback.condition.symm }
end

/-- `X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)` is the pullback `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ`. -/
def pullback_assoc_symm_is_pullback [has_pullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)] :
is_limit (pullback_cone.mk l‚ÇÅ' (l‚ÇÇ' ‚â´ g‚ÇÑ) (show l‚ÇÅ' ‚â´ (g‚ÇÇ ‚â´ f‚ÇÉ) = (l‚ÇÇ' ‚â´ g‚ÇÑ) ‚â´ f‚ÇÑ,
  by rw [pullback.lift_snd_assoc, category.assoc, category.assoc, pullback.condition])) :=
begin
  apply big_square_is_pullback,
  exact pullback_is_pullback f‚ÇÉ f‚ÇÑ,
  apply pullback_pullback_right_is_pullback
end

lemma has_pullback_assoc_symm [has_pullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)] :
has_pullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ :=
‚ü®‚ü®‚ü®_, pullback_assoc_symm_is_pullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ‚ü©‚ü©‚ü©

variables [has_pullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] [has_pullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)]

/-- The canonical isomorphism `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ ‚âÖ X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
noncomputable
def pullback_assoc :
  pullback (pullback.snd ‚â´ f‚ÇÉ : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ _) f‚ÇÑ ‚âÖ
    pullback f‚ÇÅ (pullback.fst ‚â´ f‚ÇÇ : pullback f‚ÇÉ f‚ÇÑ ‚ü∂ _) :=
(pullback_pullback_left_is_pullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).cone_point_unique_up_to_iso
(pullback_pullback_right_is_pullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ)

@[simp, reassoc]
lemma pullback_assoc_inv_fst_fst :
  (pullback_assoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).inv ‚â´ pullback.fst ‚â´ pullback.fst = pullback.fst :=
begin
  transitivity l‚ÇÅ' ‚â´ pullback.fst,
  rw ‚Üê category.assoc,
  congr' 1,
  exact is_limit.cone_point_unique_up_to_iso_inv_comp _ _ walking_cospan.left,
  exact pullback.lift_fst _ _ _,
end

@[simp, reassoc]
lemma pullback_assoc_hom_fst :
  (pullback_assoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).hom ‚â´ pullback.fst = pullback.fst ‚â´ pullback.fst :=
by rw [‚Üê iso.eq_inv_comp, pullback_assoc_inv_fst_fst]

@[simp, reassoc]
lemma pullback_assoc_hom_snd_fst :
  (pullback_assoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).hom ‚â´ pullback.snd ‚â´ pullback.fst = pullback.fst ‚â´ pullback.snd :=
begin
  transitivity l‚ÇÇ ‚â´ pullback.fst,
  rw ‚Üê category.assoc,
  congr' 1,
  exact is_limit.cone_point_unique_up_to_iso_hom_comp _ _ walking_cospan.right,
  exact pullback.lift_fst _ _ _,
end

@[simp, reassoc]
lemma pullback_assoc_hom_snd_snd :
  (pullback_assoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).hom ‚â´ pullback.snd ‚â´ pullback.snd = pullback.snd :=
begin
  transitivity l‚ÇÇ ‚â´ pullback.snd,
  rw ‚Üê category.assoc,
  congr' 1,
  exact is_limit.cone_point_unique_up_to_iso_hom_comp _ _ walking_cospan.right,
  exact pullback.lift_snd _ _ _,
end

@[simp, reassoc]
lemma pullback_assoc_inv_fst_snd :
  (pullback_assoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).inv ‚â´ pullback.fst ‚â´ pullback.snd = pullback.snd ‚â´ pullback.fst :=
by rw [iso.inv_comp_eq, pullback_assoc_hom_snd_fst]

@[simp, reassoc]
lemma pullback_assoc_inv_snd :
  (pullback_assoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).inv ‚â´ pullback.snd = pullback.snd ‚â´ pullback.snd :=
by rw [iso.inv_comp_eq, pullback_assoc_hom_snd_snd]

end pullback_assoc


section pushout_assoc

/-
The objects and morphisms are as follows:

           Z‚ÇÇ - g‚ÇÑ -> X‚ÇÉ
           |          |
           g‚ÇÉ         f‚ÇÑ
           ‚à®          ‚à®
Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ
|          |
g‚ÇÅ         f‚ÇÇ
‚à®          ‚à®
X‚ÇÅ - f‚ÇÅ -> Y‚ÇÅ

where the two squares are pushouts.

We can then construct the pushout squares

Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ
|                     |
g‚ÇÅ                    l‚ÇÇ
‚à®                     ‚à®
X‚ÇÅ - f‚ÇÅ -> Y‚ÇÅ - l‚ÇÅ -> W

and

Z‚ÇÇ - g‚ÇÑ  -> X‚ÇÉ
|           |
g‚ÇÉ          f‚ÇÑ
‚à®           ‚à®
X‚ÇÇ          Y‚ÇÇ
|           |
f‚ÇÇ          l‚ÇÇ'
‚à®           ‚à®
Y‚ÇÅ - l‚ÇÅ' -> W'

We will show that both `W` and `W'` are pushouts over `f‚ÇÇ, f‚ÇÉ`, and thus we may construct a
canonical isomorphism between them. -/

variables {X‚ÇÅ X‚ÇÇ X‚ÇÉ Z‚ÇÅ Z‚ÇÇ : C} (g‚ÇÅ : Z‚ÇÅ ‚ü∂ X‚ÇÅ) (g‚ÇÇ : Z‚ÇÅ ‚ü∂ X‚ÇÇ) (g‚ÇÉ : Z‚ÇÇ ‚ü∂ X‚ÇÇ)
variables (g‚ÇÑ : Z‚ÇÇ ‚ü∂ X‚ÇÉ) [has_pushout g‚ÇÅ g‚ÇÇ] [has_pushout g‚ÇÉ g‚ÇÑ]

include g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ

local notation `Y‚ÇÅ` := pushout g‚ÇÅ g‚ÇÇ
local notation `Y‚ÇÇ` := pushout g‚ÇÉ g‚ÇÑ
local notation `f‚ÇÅ` := (pushout.inl : X‚ÇÅ ‚ü∂ Y‚ÇÅ)
local notation `f‚ÇÇ` := (pushout.inr : X‚ÇÇ ‚ü∂ Y‚ÇÅ)
local notation `f‚ÇÉ` := (pushout.inl : X‚ÇÇ ‚ü∂ Y‚ÇÇ)
local notation `f‚ÇÑ` := (pushout.inr : X‚ÇÉ ‚ü∂ Y‚ÇÇ)
local notation `W`  := pushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)
local notation `W'` := pushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ
local notation `l‚ÇÅ` := (pushout.desc pushout.inl (f‚ÇÉ ‚â´ pushout.inr)
  (pushout.condition.trans (category.assoc _ _ _)) : Y‚ÇÅ ‚ü∂ W)
local notation `l‚ÇÇ` := (pushout.inr : Y‚ÇÇ ‚ü∂ W)
local notation `l‚ÇÅ'`:= (pushout.inl : Y‚ÇÅ ‚ü∂ W')
local notation `l‚ÇÇ'`:= (pushout.desc (f‚ÇÇ ‚â´ pushout.inl) pushout.inr
    ((category.assoc _ _ _).symm.trans pushout.condition) : Y‚ÇÇ ‚ü∂ W')

/-- `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ` is the pushout `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
def pushout_pushout_left_is_pushout [has_pushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] :
  is_colimit (pushout_cocone.mk l‚ÇÅ' l‚ÇÇ'
    (show f‚ÇÇ ‚â´ l‚ÇÅ' = f‚ÇÉ ‚â´ l‚ÇÇ', from (pushout.inl_desc _ _ _).symm)) :=
begin
  apply pushout_cocone.flip_is_colimit,
  apply right_square_is_pushout,
  { apply pushout_cocone.flip_is_colimit,
    exact pushout_is_pushout _ _ },
  { apply pushout_cocone.flip_is_colimit,
    convert pushout_is_pushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ,
    exact pushout.inr_desc _ _ _ },
  { exact pushout.condition.symm }
end

/-- `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ` is the pushout `X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
def pushout_assoc_is_pushout [has_pushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] :
  is_colimit (pushout_cocone.mk (f‚ÇÅ ‚â´ l‚ÇÅ') l‚ÇÇ' (show g‚ÇÅ ‚â´ (f‚ÇÅ ‚â´ l‚ÇÅ') = (g‚ÇÇ ‚â´ f‚ÇÉ) ‚â´ l‚ÇÇ',
  by rw [category.assoc, pushout.inl_desc, pushout.condition_assoc])) :=
begin
  apply big_square_is_pushout,
  { apply pushout_pushout_left_is_pushout },
  { exact pushout_is_pushout _ _ }
end

lemma has_pushout_assoc [has_pushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] :
  has_pushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ) :=
‚ü®‚ü®‚ü®_, pushout_assoc_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ‚ü©‚ü©‚ü©

/-- `X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)` is the pushout `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
def pushout_pushout_right_is_pushout [has_pushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)] :
is_colimit (pushout_cocone.mk l‚ÇÅ l‚ÇÇ (show f‚ÇÇ ‚â´ l‚ÇÅ = f‚ÇÉ ‚â´ l‚ÇÇ, from pushout.inr_desc _ _ _)) :=
begin
  apply right_square_is_pushout,
  { exact pushout_is_pushout _ _ },
  { convert pushout_is_pushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ),
    rw pushout.inl_desc }
end

/-- `X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)` is the pushout `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ`. -/
def pushout_assoc_symm_is_pushout [has_pushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)] :
  is_colimit (pushout_cocone.mk l‚ÇÅ (f‚ÇÑ ‚â´ l‚ÇÇ) ((show (g‚ÇÉ ‚â´ f‚ÇÇ) ‚â´ l‚ÇÅ = g‚ÇÑ ‚â´ (f‚ÇÑ ‚â´ l‚ÇÇ),
    by rw [category.assoc, pushout.inr_desc, pushout.condition_assoc]))) :=
begin
  apply pushout_cocone.flip_is_colimit,
  apply big_square_is_pushout,
  { apply pushout_cocone.flip_is_colimit,
    apply pushout_pushout_right_is_pushout },
  { apply pushout_cocone.flip_is_colimit,
    exact pushout_is_pushout _ _ },
  { exact pushout.condition.symm },
  { exact (pushout.inr_desc _ _ _).symm }
end

lemma has_pushout_assoc_symm [has_pushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)] :
  has_pushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ :=
‚ü®‚ü®‚ü®_, pushout_assoc_symm_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ‚ü©‚ü©‚ü©

variables [has_pushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] [has_pushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)]


/-- The canonical isomorphism `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ ‚âÖ X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
noncomputable
def pushout_assoc :
  pushout (g‚ÇÉ ‚â´ pushout.inr : _ ‚ü∂ pushout g‚ÇÅ g‚ÇÇ) g‚ÇÑ ‚âÖ
    pushout g‚ÇÅ (g‚ÇÇ ‚â´ pushout.inl : _ ‚ü∂ pushout g‚ÇÉ g‚ÇÑ) :=
(pushout_pushout_left_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).cocone_point_unique_up_to_iso
(pushout_pushout_right_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ)

@[simp, reassoc]
lemma inl_inl_pushout_assoc_hom :
  pushout.inl ‚â´ pushout.inl ‚â´ (pushout_assoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).hom = pushout.inl :=
begin
  transitivity f‚ÇÅ ‚â´ l‚ÇÅ,
  { congr' 1,
    exact (pushout_pushout_left_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ)
      .comp_cocone_point_unique_up_to_iso_hom _ walking_cospan.left },
  { exact pushout.inl_desc _ _ _ }
end

@[simp, reassoc]
lemma inr_inl_pushout_assoc_hom :
  pushout.inr ‚â´ pushout.inl ‚â´ (pushout_assoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).hom = pushout.inl ‚â´ pushout.inr :=
begin
  transitivity f‚ÇÇ ‚â´ l‚ÇÅ,
  { congr' 1,
    exact (pushout_pushout_left_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ)
      .comp_cocone_point_unique_up_to_iso_hom _ walking_cospan.left },
  { exact pushout.inr_desc _ _ _ }
end

@[simp, reassoc]
lemma inr_inr_pushout_assoc_inv :
  pushout.inr ‚â´ pushout.inr ‚â´ (pushout_assoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).inv = pushout.inr :=
begin
  transitivity f‚ÇÑ ‚â´ l‚ÇÇ',
  { congr' 1,
    exact (pushout_pushout_left_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).comp_cocone_point_unique_up_to_iso_inv
      (pushout_pushout_right_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ) walking_cospan.right },
  { exact pushout.inr_desc _ _ _ }
end

@[simp, reassoc]
lemma inl_pushout_assoc_inv :
  pushout.inl ‚â´ (pushout_assoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).inv = pushout.inl ‚â´ pushout.inl :=
by rw [iso.comp_inv_eq, category.assoc, inl_inl_pushout_assoc_hom]

@[simp, reassoc]
lemma inl_inr_pushout_assoc_inv :
  pushout.inl ‚â´ pushout.inr ‚â´ (pushout_assoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).inv = pushout.inr ‚â´ pushout.inl :=
by rw [‚Üê category.assoc, iso.comp_inv_eq, category.assoc, inr_inl_pushout_assoc_hom]

@[simp, reassoc]
lemma inr_pushout_assoc_hom :
  pushout.inr ‚â´  (pushout_assoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).hom = pushout.inr ‚â´ pushout.inr :=
by rw [‚Üê iso.eq_comp_inv, category.assoc, inr_inr_pushout_assoc_inv]


end pushout_assoc

variables (C)

/--
`has_pullbacks` represents a choice of pullback for every pair of morphisms

See https://stacks.math.columbia.edu/tag/001W
-/
abbreviation has_pullbacks := has_limits_of_shape walking_cospan.{v} C

/-- `has_pushouts` represents a choice of pushout for every pair of morphisms -/
abbreviation has_pushouts := has_colimits_of_shape walking_span.{v} C

/-- If `C` has all limits of diagrams `cospan f g`, then it has all pullbacks -/
lemma has_pullbacks_of_has_limit_cospan
  [Œ† {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}, has_limit (cospan f g)] :
  has_pullbacks C :=
{ has_limit := Œª F, has_limit_of_iso (diagram_iso_cospan F).symm }

/-- If `C` has all colimits of diagrams `span f g`, then it has all pushouts -/
lemma has_pushouts_of_has_colimit_span
  [Œ† {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z}, has_colimit (span f g)] :
  has_pushouts C :=
{ has_colimit := Œª F, has_colimit_of_iso (diagram_iso_span F) }

end category_theory.limits
