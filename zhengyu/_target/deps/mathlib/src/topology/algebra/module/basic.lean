/-
Copyright (c) 2019 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jan-David Salchow, S√©bastien Gou√´zel, Jean Lo, Yury Kudryashov, Fr√©d√©ric Dupuis,
  Heather Macbeth
-/
import topology.algebra.ring
import topology.algebra.mul_action
import topology.uniform_space.uniform_embedding
import algebra.algebra.basic
import linear_algebra.projection
import linear_algebra.pi
import linear_algebra.determinant

/-!
# Theory of topological modules and continuous linear maps.

We use the class `has_continuous_smul` for topological (semi) modules and topological vector spaces.

In this file we define continuous (semi-)linear maps, as semilinear maps between topological
modules which are continuous. The set of continuous semilinear maps between the topological
`R‚ÇÅ`-module `M` and `R‚ÇÇ`-module `M‚ÇÇ` with respect to the `ring_hom` `œÉ` is denoted by `M ‚ÜíSL[œÉ] M‚ÇÇ`.
Plain linear maps are denoted by `M ‚ÜíL[R] M‚ÇÇ` and star-linear maps by `M ‚ÜíL‚ãÜ[R] M‚ÇÇ`.

The corresponding notation for equivalences is `M ‚âÉSL[œÉ] M‚ÇÇ`, `M ‚âÉL[R] M‚ÇÇ` and `M ‚âÉL‚ãÜ[R] M‚ÇÇ`.
-/

open filter
open_locale topological_space big_operators filter

universes u v w u'

section

variables {R : Type*} {M : Type*}
[ring R] [topological_space R]
[topological_space M] [add_comm_group M]
[module R M]

lemma has_continuous_smul.of_nhds_zero [topological_ring R] [topological_add_group M]
  (hmul : tendsto (Œª p : R √ó M, p.1 ‚Ä¢ p.2) (ùìù 0 √ó·∂† (ùìù 0)) (ùìù 0))
  (hmulleft : ‚àÄ m : M, tendsto (Œª a : R, a ‚Ä¢ m) (ùìù 0) (ùìù 0))
  (hmulright : ‚àÄ a : R, tendsto (Œª m : M, a ‚Ä¢ m) (ùìù 0) (ùìù 0)) : has_continuous_smul R M :=
‚ü®begin
  rw continuous_iff_continuous_at,
  rintros ‚ü®a‚ÇÄ, m‚ÇÄ‚ü©,
  have key : ‚àÄ p : R √ó M,
    p.1 ‚Ä¢ p.2 = a‚ÇÄ ‚Ä¢ m‚ÇÄ + ((p.1 - a‚ÇÄ) ‚Ä¢ m‚ÇÄ + a‚ÇÄ ‚Ä¢ (p.2 - m‚ÇÄ) + (p.1 - a‚ÇÄ) ‚Ä¢ (p.2 - m‚ÇÄ)),
  { rintro ‚ü®a, m‚ü©,
    simp [sub_smul, smul_sub],
    abel },
  rw funext key, clear key,
  refine tendsto_const_nhds.add (tendsto.add (tendsto.add _ _) _),
  { rw [sub_self, zero_smul],
    apply (hmulleft m‚ÇÄ).comp,
    rw [show (Œª p : R √ó M, p.1 - a‚ÇÄ) = (Œª a, a - a‚ÇÄ) ‚àò prod.fst, by {ext, refl }, nhds_prod_eq],
    have : tendsto (Œª a, a - a‚ÇÄ) (ùìù a‚ÇÄ) (ùìù 0),
    { rw ‚Üê sub_self a‚ÇÄ,
      exact tendsto_id.sub tendsto_const_nhds },
    exact this.comp tendsto_fst  },
  { rw [sub_self, smul_zero],
    apply (hmulright a‚ÇÄ).comp,
    rw [show (Œª p : R √ó M, p.2 - m‚ÇÄ) = (Œª m, m - m‚ÇÄ) ‚àò prod.snd, by {ext, refl }, nhds_prod_eq],
    have : tendsto (Œª m, m - m‚ÇÄ) (ùìù m‚ÇÄ) (ùìù 0),
    { rw ‚Üê sub_self m‚ÇÄ,
      exact tendsto_id.sub tendsto_const_nhds },
    exact this.comp tendsto_snd },
  { rw [sub_self, zero_smul, nhds_prod_eq,
        show (Œª p : R √ó M, (p.fst - a‚ÇÄ) ‚Ä¢ (p.snd - m‚ÇÄ)) =
             (Œª  p : R √ó M, p.1 ‚Ä¢ p.2) ‚àò (prod.map (Œª a, a - a‚ÇÄ) (Œª m, m - m‚ÇÄ)), by { ext, refl }],
    apply hmul.comp (tendsto.prod_map _ _);
    { rw ‚Üê sub_self ,
      exact tendsto_id.sub tendsto_const_nhds } },
end‚ü©
end

section
variables {R : Type*} {M : Type*}
[ring R] [topological_space R]
[topological_space M] [add_comm_group M] [has_continuous_add M]
[module R M] [has_continuous_smul R M]

/-- If `M` is a topological module over `R` and `0` is a limit of invertible elements of `R`, then
`‚ä§` is the only submodule of `M` with a nonempty interior.
This is the case, e.g., if `R` is a nondiscrete normed field. -/
lemma submodule.eq_top_of_nonempty_interior'
  [ne_bot (ùìù[{x : R | is_unit x}] 0)]
  (s : submodule R M) (hs : (interior (s:set M)).nonempty) :
  s = ‚ä§ :=
begin
  rcases hs with ‚ü®y, hy‚ü©,
  refine (submodule.eq_top_iff'.2 $ Œª x, _),
  rw [mem_interior_iff_mem_nhds] at hy,
  have : tendsto (Œª c:R, y + c ‚Ä¢ x) (ùìù[{x : R | is_unit x}] 0) (ùìù (y + (0:R) ‚Ä¢ x)),
    from tendsto_const_nhds.add ((tendsto_nhds_within_of_tendsto_nhds tendsto_id).smul
      tendsto_const_nhds),
  rw [zero_smul, add_zero] at this,
  obtain ‚ü®_, hu : y + _ ‚Ä¢ _ ‚àà s, u, rfl‚ü© :=
    nonempty_of_mem (inter_mem (mem_map.1 (this hy)) self_mem_nhds_within),
  have hy' : y ‚àà ‚Üës := mem_of_mem_nhds hy,
  rwa [s.add_mem_iff_right hy', ‚Üêunits.smul_def, s.smul_mem_iff' u] at hu,
end

variables (R M)

/-- Let `R` be a topological ring such that zero is not an isolated point (e.g., a nondiscrete
normed field, see `normed_field.punctured_nhds_ne_bot`). Let `M` be a nontrivial module over `R`
such that `c ‚Ä¢ x = 0` implies `c = 0 ‚à® x = 0`. Then `M` has no isolated points. We formulate this
using `ne_bot (ùìù[‚â†] x)`.

This lemma is not an instance because Lean would need to find `[has_continuous_smul ?m_1 M]` with
unknown `?m_1`. We register this as an instance for `R = ‚Ñù` in `real.punctured_nhds_module_ne_bot`.
One can also use `haveI := module.punctured_nhds_ne_bot R M` in a proof.
-/
lemma module.punctured_nhds_ne_bot [nontrivial M] [ne_bot (ùìù[‚â†] (0 : R))]
  [no_zero_smul_divisors R M] (x : M) :
  ne_bot (ùìù[‚â†] x) :=
begin
  rcases exists_ne (0 : M) with ‚ü®y, hy‚ü©,
  suffices : tendsto (Œª c : R, x + c ‚Ä¢ y) (ùìù[‚â†] 0) (ùìù[‚â†] x), from this.ne_bot,
  refine tendsto.inf _ (tendsto_principal_principal.2 $ _),
  { convert tendsto_const_nhds.add ((@tendsto_id R _).smul_const y),
    rw [zero_smul, add_zero] },
  { intros c hc,
    simpa [hy] using hc }
end

end

section lattice_ops

variables {Œπ R M‚ÇÅ M‚ÇÇ : Type*} [semiring R] [add_comm_monoid M‚ÇÅ] [add_comm_monoid M‚ÇÇ]
  [module R M‚ÇÅ] [module R M‚ÇÇ] [u : topological_space R] {t : topological_space M‚ÇÇ}
  [has_continuous_smul R M‚ÇÇ] (f : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ)

lemma has_continuous_smul_induced :
  @has_continuous_smul R M‚ÇÅ _ u (t.induced f) :=
{ continuous_smul :=
    begin
      letI : topological_space M‚ÇÅ := t.induced f,
      refine continuous_induced_rng _,
      simp_rw [function.comp, f.map_smul],
      refine continuous_fst.smul (continuous_induced_dom.comp continuous_snd)
    end }

end lattice_ops

namespace submodule

variables {Œ± Œ≤ : Type*} [topological_space Œ≤]

instance [topological_space Œ±] [semiring Œ±] [add_comm_monoid Œ≤] [module Œ± Œ≤]
  [has_continuous_smul Œ± Œ≤] (S : submodule Œ± Œ≤) :
  has_continuous_smul Œ± S :=
{ continuous_smul :=
  begin
    rw embedding_subtype_coe.to_inducing.continuous_iff,
    exact continuous_fst.smul
      (continuous_subtype_coe.comp continuous_snd)
  end }

instance [ring Œ±] [add_comm_group Œ≤] [module Œ± Œ≤] [topological_add_group Œ≤] (S : submodule Œ± Œ≤) :
  topological_add_group S :=
S.to_add_subgroup.topological_add_group

end submodule

section closure
variables {R : Type u} {M : Type v}
[semiring R] [topological_space R]
[topological_space M] [add_comm_monoid M]
[module R M] [has_continuous_smul R M]

lemma submodule.closure_smul_self_subset (s : submodule R M) :
  (Œª p : R √ó M, p.1 ‚Ä¢ p.2) '' ((set.univ : set R) √óÀ¢ closure (s : set M))
  ‚äÜ closure (s : set M) :=
calc
(Œª p : R √ó M, p.1 ‚Ä¢ p.2) '' ((set.univ : set R) √óÀ¢ closure (s : set M))
    = (Œª p : R √ó M, p.1 ‚Ä¢ p.2) '' (closure ((set.univ : set R) √óÀ¢ (s : set M))) :
  by simp [closure_prod_eq]
... ‚äÜ closure ((Œª p : R √ó M, p.1 ‚Ä¢ p.2) '' ((set.univ : set R) √óÀ¢ (s : set M))) :
  image_closure_subset_closure_image continuous_smul
... = closure s : begin
  congr,
  ext x,
  refine ‚ü®_, Œª hx, ‚ü®‚ü®1, x‚ü©, ‚ü®set.mem_univ _, hx‚ü©, one_smul R _‚ü©‚ü©,
  rintros ‚ü®‚ü®c, y‚ü©, ‚ü®hc, hy‚ü©, rfl‚ü©,
  simp [s.smul_mem c hy]
end

lemma submodule.closure_smul_self_eq (s : submodule R M) :
  (Œª p : R √ó M, p.1 ‚Ä¢ p.2) '' ((set.univ : set R) √óÀ¢ closure (s : set M))
  = closure (s : set M) :=
set.subset.antisymm s.closure_smul_self_subset
  (Œª x hx, ‚ü®‚ü®1, x‚ü©, ‚ü®set.mem_univ _, hx‚ü©, one_smul R _‚ü©)

variables [has_continuous_add M]

/-- The (topological-space) closure of a submodule of a topological `R`-module `M` is itself
a submodule. -/
def submodule.topological_closure (s : submodule R M) : submodule R M :=
{ carrier := closure (s : set M),
  smul_mem' := Œª c x hx, s.closure_smul_self_subset ‚ü®‚ü®c, x‚ü©, ‚ü®set.mem_univ _, hx‚ü©, rfl‚ü©,
  ..s.to_add_submonoid.topological_closure }

@[simp] lemma submodule.topological_closure_coe (s : submodule R M) :
  (s.topological_closure : set M) = closure (s : set M) :=
rfl

instance submodule.topological_closure_has_continuous_smul (s : submodule R M) :
  has_continuous_smul R (s.topological_closure) :=
{ continuous_smul :=
  begin
    apply continuous_induced_rng,
    change continuous (Œª p : R √ó s.topological_closure, p.1 ‚Ä¢ (p.2 : M)),
    continuity,
  end,
  ..s.to_add_submonoid.topological_closure_has_continuous_add }

lemma submodule.submodule_topological_closure (s : submodule R M) :
  s ‚â§ s.topological_closure :=
subset_closure

lemma submodule.is_closed_topological_closure (s : submodule R M) :
  is_closed (s.topological_closure : set M) :=
by convert is_closed_closure

lemma submodule.topological_closure_minimal
  (s : submodule R M) {t : submodule R M} (h : s ‚â§ t) (ht : is_closed (t : set M)) :
  s.topological_closure ‚â§ t :=
closure_minimal h ht

lemma submodule.topological_closure_mono {s : submodule R M} {t : submodule R M} (h : s ‚â§ t) :
  s.topological_closure ‚â§ t.topological_closure :=
s.topological_closure_minimal (h.trans t.submodule_topological_closure)
  t.is_closed_topological_closure

end closure

/-- Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M‚ÇÇ` will be topological modules over the topological
ring `R`. -/
structure continuous_linear_map
  {R : Type*} {S : Type*} [semiring R] [semiring S] (œÉ : R ‚Üí+* S)
  (M : Type*) [topological_space M] [add_comm_monoid M]
  (M‚ÇÇ : Type*) [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ]
  [module R M] [module S M‚ÇÇ]
  extends M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ :=
(cont : continuous to_fun . tactic.interactive.continuity')

notation M ` ‚ÜíSL[`:25 œÉ `] ` M‚ÇÇ := continuous_linear_map œÉ M M‚ÇÇ
notation M ` ‚ÜíL[`:25 R `] ` M‚ÇÇ := continuous_linear_map (ring_hom.id R) M M‚ÇÇ
notation M ` ‚ÜíL‚ãÜ[`:25 R `] ` M‚ÇÇ := continuous_linear_map (star_ring_end R) M M‚ÇÇ

/-- Continuous linear equivalences between modules. We only put the type classes that are necessary
for the definition, although in applications `M` and `M‚ÇÇ` will be topological modules over the
topological ring `R`. -/
@[nolint has_inhabited_instance]
structure continuous_linear_equiv
  {R : Type*} {S : Type*} [semiring R] [semiring S] (œÉ : R ‚Üí+* S)
  {œÉ' : S ‚Üí+* R} [ring_hom_inv_pair œÉ œÉ'] [ring_hom_inv_pair œÉ' œÉ]
  (M : Type*) [topological_space M] [add_comm_monoid M]
  (M‚ÇÇ : Type*) [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ]
  [module R M] [module S M‚ÇÇ]
  extends M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ :=
(continuous_to_fun  : continuous to_fun . tactic.interactive.continuity')
(continuous_inv_fun : continuous inv_fun . tactic.interactive.continuity')

notation M ` ‚âÉSL[`:50 œÉ `] ` M‚ÇÇ := continuous_linear_equiv œÉ M M‚ÇÇ
notation M ` ‚âÉL[`:50 R `] ` M‚ÇÇ := continuous_linear_equiv (ring_hom.id R) M M‚ÇÇ
notation M ` ‚âÉL‚ãÜ[`:50 R `] ` M‚ÇÇ := continuous_linear_equiv (star_ring_end R) M M‚ÇÇ

section pointwise_limits

variables
{M‚ÇÅ M‚ÇÇ Œ± R S : Type*}
[topological_space M‚ÇÇ] [t2_space M‚ÇÇ] [semiring R] [semiring S]
[add_comm_monoid M‚ÇÅ] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÅ] [module S M‚ÇÇ]
[topological_space S] [has_continuous_smul S M‚ÇÇ]

section

variables (M‚ÇÅ M‚ÇÇ) (œÉ : R ‚Üí+* S)

lemma is_closed_set_of_map_smul : is_closed {f : M‚ÇÅ ‚Üí M‚ÇÇ | ‚àÄ c x, f (c ‚Ä¢ x) = œÉ c ‚Ä¢ f x} :=
begin
  simp only [set.set_of_forall],
  exact is_closed_Inter (Œª c, is_closed_Inter (Œª x, is_closed_eq (continuous_apply _)
    (continuous_const.smul (continuous_apply _))))
end

end

variables [has_continuous_add M‚ÇÇ] {œÉ : R ‚Üí+* S} {l : filter Œ±}

/-- Constructs a bundled linear map from a function and a proof that this function belongs to the
closure of the set of linear maps. -/
@[simps { fully_applied := ff }] def linear_map_of_mem_closure_range_coe (f : M‚ÇÅ ‚Üí M‚ÇÇ)
  (hf : f ‚àà closure (set.range (coe_fn : (M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí (M‚ÇÅ ‚Üí M‚ÇÇ)))) :
  M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ :=
{ to_fun := f,
  map_smul' := (is_closed_set_of_map_smul M‚ÇÅ M‚ÇÇ œÉ).closure_subset_iff.2
    (set.range_subset_iff.2 linear_map.map_smul‚Çõ‚Çó) hf,
  .. add_monoid_hom_of_mem_closure_range_coe f hf }

/-- Construct a bundled linear map from a pointwise limit of linear maps -/
@[simps { fully_applied := ff }]
def linear_map_of_tendsto (f : M‚ÇÅ ‚Üí M‚ÇÇ) (g : Œ± ‚Üí M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ) [l.ne_bot]
  (h : tendsto (Œª a x, g a x) l (ùìù f)) : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ :=
linear_map_of_mem_closure_range_coe f $ mem_closure_of_tendsto h $
  eventually_of_forall $ Œª a, set.mem_range_self _

variables (M‚ÇÅ M‚ÇÇ œÉ)

lemma linear_map.is_closed_range_coe :
  is_closed (set.range (coe_fn : (M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ) ‚Üí (M‚ÇÅ ‚Üí M‚ÇÇ))) :=
is_closed_of_closure_subset $ Œª f hf, ‚ü®linear_map_of_mem_closure_range_coe f hf, rfl‚ü©

end pointwise_limits

namespace continuous_linear_map

section semiring
/-!
### Properties that hold for non-necessarily commutative semirings.
-/

variables
{R‚ÇÅ : Type*} {R‚ÇÇ : Type*} {R‚ÇÉ : Type*} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [semiring R‚ÇÉ]
{œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ}
{M‚ÇÅ : Type*} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ]
{M'‚ÇÅ : Type*} [topological_space M'‚ÇÅ] [add_comm_monoid M'‚ÇÅ]
{M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ]
{M‚ÇÉ : Type*} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ]
{M‚ÇÑ : Type*} [topological_space M‚ÇÑ] [add_comm_monoid M‚ÇÑ]
[module R‚ÇÅ M‚ÇÅ] [module R‚ÇÅ M'‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] [module R‚ÇÉ M‚ÇÉ]

/-- Coerce continuous linear maps to linear maps. -/
instance : has_coe (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) := ‚ü®to_linear_map‚ü©

-- make the coercion the preferred form
@[simp] lemma to_linear_map_eq_coe (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : f.to_linear_map = f := rfl

theorem coe_injective : function.injective (coe : (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí (M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)) :=
by { intros f g H, cases f, cases g, congr' }

instance : add_monoid_hom_class (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) M‚ÇÅ M‚ÇÇ :=
{ coe := Œª f, f.to_fun,
  coe_injective' := Œª f g h, coe_injective (fun_like.coe_injective h),
  map_add := Œª f, map_add f.to_linear_map,
  map_zero := Œª f, linear_map.map_zero f }

/-- Coerce continuous linear maps to functions. -/
-- see Note [function coercion]
instance to_fun : has_coe_to_fun (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (Œª _, M‚ÇÅ ‚Üí M‚ÇÇ) := ‚ü®Œª f, f.to_fun‚ü©

@[simp] lemma coe_mk (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (h) : (mk f h : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = f := rfl
@[simp] lemma coe_mk' (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (h) : (mk f h : M‚ÇÅ ‚Üí M‚ÇÇ) = f := rfl

@[continuity]
protected lemma continuous (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : continuous f := f.2

@[simp, norm_cast] lemma coe_inj {f g : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} :
  (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = g ‚Üî f = g :=
coe_injective.eq_iff

theorem coe_fn_injective : @function.injective (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (M‚ÇÅ ‚Üí M‚ÇÇ) coe_fn :=
fun_like.coe_injective

/-- See Note [custom simps projection]. We need to specify this projection explicitly in this case,
  because it is a composition of multiple projections. -/
def simps.apply (h : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí M‚ÇÇ := h

/-- See Note [custom simps projection]. -/
def simps.coe (h : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ := h

initialize_simps_projections continuous_linear_map
  (to_linear_map_to_fun ‚Üí apply, to_linear_map ‚Üí coe)

@[ext] theorem ext {f g : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=
fun_like.ext f g h

theorem ext_iff {f g : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} : f = g ‚Üî ‚àÄ x, f x = g x :=
fun_like.ext_iff

variables (f g : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (c : R‚ÇÅ) (h : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (x y z : M‚ÇÅ) (f‚Çó : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M'‚ÇÅ)

-- make some straightforward lemmas available to `simp`.
protected lemma map_zero : f (0 : M‚ÇÅ) = 0 := map_zero f
protected lemma map_add  : f (x + y) = f x + f y := map_add f x y
@[simp] lemma map_smul‚Çõ‚Çó : f (c ‚Ä¢ x) = (œÉ‚ÇÅ‚ÇÇ c) ‚Ä¢ f x := (to_linear_map _).map_smul‚Çõ‚Çó _ _

@[simp] lemma map_smul [module R‚ÇÅ M‚ÇÇ] (f : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ)(c : R‚ÇÅ) (x : M‚ÇÅ) : f (c ‚Ä¢ x) = c ‚Ä¢ f x :=
by simp only [ring_hom.id_apply, map_smul‚Çõ‚Çó]

@[simp, priority 900]
lemma map_smul_of_tower {R S : Type*} [semiring S] [has_scalar R M‚ÇÅ]
  [module S M‚ÇÅ] [has_scalar R M‚ÇÇ] [module S M‚ÇÇ]
  [linear_map.compatible_smul M‚ÇÅ M‚ÇÇ R S] (f : M‚ÇÅ ‚ÜíL[S] M‚ÇÇ) (c : R) (x : M‚ÇÅ) :
  f (c ‚Ä¢ x) = c ‚Ä¢ f x :=
linear_map.compatible_smul.map_smul f c x

protected lemma map_sum {Œπ : Type*} (s : finset Œπ) (g : Œπ ‚Üí M‚ÇÅ) :
  f (‚àë i in s, g i) = ‚àë i in s, f (g i) := f.to_linear_map.map_sum

@[simp, norm_cast] lemma coe_coe : ((f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : (M‚ÇÅ ‚Üí M‚ÇÇ)) = (f : M‚ÇÅ ‚Üí M‚ÇÇ) := rfl

@[ext] theorem ext_ring [topological_space R‚ÇÅ] {f g : R‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ} (h : f 1 = g 1) : f = g :=
coe_inj.1 $ linear_map.ext_ring h

theorem ext_ring_iff [topological_space R‚ÇÅ] {f g : R‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ} : f = g ‚Üî f 1 = g 1 :=
‚ü®Œª h, h ‚ñ∏ rfl, ext_ring‚ü©

/-- If two continuous linear maps are equal on a set `s`, then they are equal on the closure
of the `submodule.span` of this set. -/
lemma eq_on_closure_span [t2_space M‚ÇÇ] {s : set M‚ÇÅ} {f g : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (h : set.eq_on f g s) :
  set.eq_on f g (closure (submodule.span R‚ÇÅ s : set M‚ÇÅ)) :=
(linear_map.eq_on_span' h).closure f.continuous g.continuous

/-- If the submodule generated by a set `s` is dense in the ambient module, then two continuous
linear maps equal on `s` are equal. -/
lemma ext_on [t2_space M‚ÇÇ] {s : set M‚ÇÅ} (hs : dense (submodule.span R‚ÇÅ s : set M‚ÇÅ))
  {f g : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (h : set.eq_on f g s) :
  f = g :=
ext $ Œª x, eq_on_closure_span h (hs x)

/-- Under a continuous linear map, the image of the `topological_closure` of a submodule is
contained in the `topological_closure` of its image. -/
lemma _root_.submodule.topological_closure_map [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] [topological_space R‚ÇÅ]
  [topological_space R‚ÇÇ] [has_continuous_smul R‚ÇÅ M‚ÇÅ] [has_continuous_add M‚ÇÅ]
  [has_continuous_smul R‚ÇÇ M‚ÇÇ] [has_continuous_add M‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : submodule R‚ÇÅ M‚ÇÅ) :
  (s.topological_closure.map (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ))
  ‚â§ (s.map (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)).topological_closure :=
image_closure_subset_closure_image f.continuous

/-- Under a dense continuous linear map, a submodule whose `topological_closure` is `‚ä§` is sent to
another such submodule.  That is, the image of a dense set under a map with dense range is dense.
-/
lemma _root_.dense_range.topological_closure_map_submodule [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ]
  [topological_space R‚ÇÅ] [topological_space R‚ÇÇ] [has_continuous_smul R‚ÇÅ M‚ÇÅ] [has_continuous_add M‚ÇÅ]
  [has_continuous_smul R‚ÇÇ M‚ÇÇ] [has_continuous_add M‚ÇÇ] {f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (hf' : dense_range f)
  {s : submodule R‚ÇÅ M‚ÇÅ} (hs : s.topological_closure = ‚ä§) :
  (s.map (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)).topological_closure = ‚ä§ :=
begin
  rw set_like.ext'_iff at hs ‚ä¢,
  simp only [submodule.topological_closure_coe, submodule.top_coe, ‚Üê dense_iff_closure_eq] at hs ‚ä¢,
  exact hf'.dense_image f.continuous hs
end

/-- The continuous map that is constantly zero. -/
instance: has_zero (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) := ‚ü®‚ü®0, continuous_zero‚ü©‚ü©
instance : inhabited (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) := ‚ü®0‚ü©

@[simp] lemma default_def : (default : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = 0 := rfl
@[simp] lemma zero_apply : (0 : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) x = 0 := rfl
@[simp, norm_cast] lemma coe_zero : ((0 : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = 0 := rfl
/- no simp attribute on the next line as simp does not always simplify `0 x` to `0`
when `0` is the zero function, while it does for the zero continuous linear map,
and this is the most important property we care about. -/
@[norm_cast] lemma coe_zero' : ((0 : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí M‚ÇÇ) = 0 := rfl

instance unique_of_left [subsingleton M‚ÇÅ] : unique (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :=
coe_injective.unique

instance unique_of_right [subsingleton M‚ÇÇ] : unique (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :=
coe_injective.unique

section

variables (R‚ÇÅ M‚ÇÅ)

/-- the identity map as a continuous linear map. -/
def id : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ :=
‚ü®linear_map.id, continuous_id‚ü©

end

instance : has_one (M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) := ‚ü®id R‚ÇÅ M‚ÇÅ‚ü©

lemma one_def : (1 : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) = id R‚ÇÅ M‚ÇÅ := rfl
lemma id_apply : id R‚ÇÅ M‚ÇÅ x = x := rfl
@[simp, norm_cast] lemma coe_id : (id R‚ÇÅ M‚ÇÅ : M‚ÇÅ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÅ) = linear_map.id := rfl
@[simp, norm_cast] lemma coe_id' : (id R‚ÇÅ M‚ÇÅ : M‚ÇÅ ‚Üí M‚ÇÅ) = _root_.id := rfl

@[simp, norm_cast] lemma coe_eq_id {f : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ} :
  (f : M‚ÇÅ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÅ) = linear_map.id ‚Üî f = id _ _ :=
by rw [‚Üê coe_id, coe_inj]

@[simp] lemma one_apply : (1 : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) x = x := rfl

section add
variables [has_continuous_add M‚ÇÇ]

instance : has_add (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :=
‚ü®Œª f g, ‚ü®f + g, f.2.add g.2‚ü©‚ü©

lemma continuous_nsmul (n : ‚Ñï) : continuous (Œª (x : M‚ÇÇ), n ‚Ä¢ x) :=
begin
  induction n with n ih,
  { simp [continuous_const] },
  { simp [nat.succ_eq_add_one, add_smul], exact ih.add continuous_id }
end

@[continuity]
lemma continuous.nsmul {Œ± : Type*} [topological_space Œ±] {n : ‚Ñï} {f : Œ± ‚Üí M‚ÇÇ} (hf : continuous f) :
  continuous (Œª (x : Œ±), n ‚Ä¢ (f x)) :=
(continuous_nsmul n).comp hf

@[simp] lemma add_apply : (f + g) x = f x + g x := rfl
@[simp, norm_cast] lemma coe_add : (((f + g) : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = f + g := rfl
@[norm_cast] lemma coe_add' : (((f + g) : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí M‚ÇÇ) = (f : M‚ÇÅ ‚Üí M‚ÇÇ) + g := rfl

instance : add_comm_monoid (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :=
{ zero := (0 : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ),
  add := (+),
  zero_add := by intros; ext; apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm],
  add_zero := by intros; ext; apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm],
  add_comm := by intros; ext; apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm],
  add_assoc := by intros; ext; apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm],
  nsmul := Œª n f,
    { to_fun := Œª x, n ‚Ä¢ (f x),
      map_add' := by simp,
      map_smul' := by simp [smul_comm n] },
  nsmul_zero' := Œª f, by { ext, simp },
  nsmul_succ' := Œª n f, by { ext, simp [nat.succ_eq_one_add, add_smul] } }

@[simp, norm_cast] lemma coe_sum {Œπ : Type*} (t : finset Œπ) (f : Œπ ‚Üí M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  ‚Üë(‚àë d in t, f d) = (‚àë d in t, f d : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :=
(add_monoid_hom.mk (coe : (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí (M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)) rfl (Œª _ _, rfl)).map_sum _ _

@[simp, norm_cast] lemma coe_sum' {Œπ : Type*} (t : finset Œπ) (f : Œπ ‚Üí M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  ‚áë(‚àë d in t, f d) = ‚àë d in t, f d :=
by simp only [‚Üê coe_coe, coe_sum, linear_map.coe_fn_sum]

lemma sum_apply {Œπ : Type*} (t : finset Œπ) (f : Œπ ‚Üí M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (b : M‚ÇÅ) :
  (‚àë d in t, f d) b = ‚àë d in t, f d b :=
by simp only [coe_sum', finset.sum_apply]

end add

variables {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ]

/-- Composition of bounded linear maps. -/
def comp (g : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ :=
‚ü®(g : M‚ÇÇ ‚Üí‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ).comp ‚Üëf, g.2.comp f.2‚ü©

infixr ` ‚àòL `:80 := @continuous_linear_map.comp _ _ _ _ _ _ (ring_hom.id _) (ring_hom.id _)
  _ _ _ _ _ _ _ _ _ _ _ _ (ring_hom.id _) ring_hom_comp_triple.ids

@[simp, norm_cast] lemma coe_comp :
  ((h.comp f) : (M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ)) = (h : M‚ÇÇ ‚Üí‚Çõ‚Çó[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ).comp (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) := rfl

include œÉ‚ÇÅ‚ÇÉ
@[simp, norm_cast] lemma coe_comp' : ((h.comp f) : (M‚ÇÅ ‚Üí M‚ÇÉ)) = (h : M‚ÇÇ ‚Üí M‚ÇÉ) ‚àò f := rfl

lemma comp_apply (g : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x : M‚ÇÅ) : (g.comp f) x = g (f x) := rfl
omit œÉ‚ÇÅ‚ÇÉ

@[simp] theorem comp_id : f.comp (id R‚ÇÅ M‚ÇÅ) = f :=
ext $ Œª x, rfl

@[simp] theorem id_comp : (id R‚ÇÇ M‚ÇÇ).comp f = f :=
ext $ Œª x, rfl

include œÉ‚ÇÅ‚ÇÉ
@[simp] theorem comp_zero (g : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) : g.comp (0 : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = 0 :=
by { ext, simp }

@[simp] theorem zero_comp : (0 : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ).comp f = 0 :=
by { ext, simp }

@[simp] lemma comp_add [has_continuous_add M‚ÇÇ] [has_continuous_add M‚ÇÉ]
  (g : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (f‚ÇÅ f‚ÇÇ : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  g.comp (f‚ÇÅ + f‚ÇÇ) = g.comp f‚ÇÅ + g.comp f‚ÇÇ :=
by { ext, simp }

@[simp] lemma add_comp [has_continuous_add M‚ÇÉ]
  (g‚ÇÅ g‚ÇÇ : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  (g‚ÇÅ + g‚ÇÇ).comp f = g‚ÇÅ.comp f + g‚ÇÇ.comp f :=
by { ext, simp }
omit œÉ‚ÇÅ‚ÇÉ

theorem comp_assoc {R‚ÇÑ : Type*} [semiring R‚ÇÑ] [module R‚ÇÑ M‚ÇÑ] {œÉ‚ÇÅ‚ÇÑ : R‚ÇÅ ‚Üí+* R‚ÇÑ} {œÉ‚ÇÇ‚ÇÑ : R‚ÇÇ ‚Üí+* R‚ÇÑ}
  {œÉ‚ÇÉ‚ÇÑ : R‚ÇÉ ‚Üí+* R‚ÇÑ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÑ œÉ‚ÇÅ‚ÇÑ] [ring_hom_comp_triple œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÉ‚ÇÑ œÉ‚ÇÇ‚ÇÑ]
  [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÑ œÉ‚ÇÅ‚ÇÑ] (h : M‚ÇÉ ‚ÜíSL[œÉ‚ÇÉ‚ÇÑ] M‚ÇÑ) (g : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ)
  (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  (h.comp g).comp f = h.comp (g.comp f) :=
rfl

instance : has_mul (M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) := ‚ü®comp‚ü©

lemma mul_def (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) : f * g = f.comp g := rfl

@[simp] lemma coe_mul (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) : ‚áë(f * g) = f ‚àò g := rfl

lemma mul_apply (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) := rfl

/-- The cartesian product of two bounded linear maps, as a bounded linear map. -/
protected def prod [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) :
  M‚ÇÅ ‚ÜíL[R‚ÇÅ] (M‚ÇÇ √ó M‚ÇÉ) :=
‚ü®(f‚ÇÅ : M‚ÇÅ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÇ).prod f‚ÇÇ, f‚ÇÅ.2.prod_mk f‚ÇÇ.2‚ü©

@[simp, norm_cast] lemma coe_prod [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ)
  (f‚ÇÇ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) :
  (f‚ÇÅ.prod f‚ÇÇ : M‚ÇÅ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÇ √ó M‚ÇÉ) = linear_map.prod f‚ÇÅ f‚ÇÇ :=
rfl

@[simp, norm_cast] lemma prod_apply [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ)
  (f‚ÇÇ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) (x : M‚ÇÅ) :
  f‚ÇÅ.prod f‚ÇÇ x = (f‚ÇÅ x, f‚ÇÇ x) :=
rfl

section

variables (R‚ÇÅ M‚ÇÅ M‚ÇÇ)

/-- The left injection into a product is a continuous linear map. -/
def inl [module R‚ÇÅ M‚ÇÇ] : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ √ó M‚ÇÇ := (id R‚ÇÅ M‚ÇÅ).prod 0

/-- The right injection into a product is a continuous linear map. -/
def inr [module R‚ÇÅ M‚ÇÇ] : M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÅ √ó M‚ÇÇ := (0 : M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÅ).prod (id R‚ÇÅ M‚ÇÇ)

end

@[simp] lemma inl_apply [module R‚ÇÅ M‚ÇÇ] (x : M‚ÇÅ) : inl R‚ÇÅ M‚ÇÅ M‚ÇÇ x = (x, 0) := rfl
@[simp] lemma inr_apply [module R‚ÇÅ M‚ÇÇ] (x : M‚ÇÇ) : inr R‚ÇÅ M‚ÇÅ M‚ÇÇ x = (0, x) := rfl

@[simp, norm_cast] lemma coe_inl [module R‚ÇÅ M‚ÇÇ] :
  (inl R‚ÇÅ M‚ÇÅ M‚ÇÇ : M‚ÇÅ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÅ √ó M‚ÇÇ) = linear_map.inl R‚ÇÅ M‚ÇÅ M‚ÇÇ := rfl
@[simp, norm_cast] lemma coe_inr [module R‚ÇÅ M‚ÇÇ] :
  (inr R‚ÇÅ M‚ÇÅ M‚ÇÇ : M‚ÇÇ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÅ √ó M‚ÇÇ) = linear_map.inr R‚ÇÅ M‚ÇÅ M‚ÇÇ := rfl

/-- Kernel of a continuous linear map. -/
def ker (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : submodule R‚ÇÅ M‚ÇÅ := (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).ker

@[norm_cast] lemma ker_coe : (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).ker = f.ker := rfl

@[simp] lemma mem_ker {f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} {x} : x ‚àà f.ker ‚Üî f x = 0 := linear_map.mem_ker

lemma is_closed_ker [t1_space M‚ÇÇ] : is_closed (f.ker : set M‚ÇÅ) :=
continuous_iff_is_closed.1 f.cont _ is_closed_singleton

@[simp] lemma apply_ker (x : f.ker) : f x = 0 := mem_ker.1 x.2

lemma is_complete_ker {M' : Type*} [uniform_space M'] [complete_space M'] [add_comm_monoid M']
  [module R‚ÇÅ M'] [t1_space M‚ÇÇ] (f : M' ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  is_complete (f.ker : set M') :=
f.is_closed_ker.is_complete

instance complete_space_ker {M' : Type*} [uniform_space M'] [complete_space M'] [add_comm_monoid M']
  [module R‚ÇÅ M'] [t1_space M‚ÇÇ] (f : M' ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  complete_space f.ker :=
f.is_closed_ker.complete_space_coe

@[simp] lemma ker_prod [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] (f : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) :
  ker (f.prod g) = ker f ‚äì ker g :=
linear_map.ker_prod f g

/-- Range of a continuous linear map. -/
def range [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : submodule R‚ÇÇ M‚ÇÇ :=
(f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).range

lemma range_coe [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] : (f.range : set M‚ÇÇ) = set.range f :=
linear_map.range_coe _
lemma mem_range [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] {f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} {y} : y ‚àà f.range ‚Üî ‚àÉ x, f x = y :=
linear_map.mem_range

lemma mem_range_self [ring_hom_surjective œÉ‚ÇÅ‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x : M‚ÇÅ) : f x ‚àà f.range :=
mem_range.2 ‚ü®x, rfl‚ü©

lemma range_prod_le [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] (f : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) :
  range (f.prod g) ‚â§ (range f).prod (range g) :=
(f : M‚ÇÅ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÇ).range_prod_le g

/-- Restrict codomain of a continuous linear map. -/
def cod_restrict (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (p : submodule R‚ÇÇ M‚ÇÇ) (h : ‚àÄ x, f x ‚àà p) :
  M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] p :=
{ cont := continuous_subtype_mk h f.continuous,
  to_linear_map := (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).cod_restrict p h}

@[norm_cast] lemma coe_cod_restrict (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (p : submodule R‚ÇÇ M‚ÇÇ) (h : ‚àÄ x, f x ‚àà p) :
  (f.cod_restrict p h : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] p) = (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).cod_restrict p h :=
rfl

@[simp] lemma coe_cod_restrict_apply (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (p : submodule R‚ÇÇ M‚ÇÇ) (h : ‚àÄ x, f x ‚àà p)
  (x) :
  (f.cod_restrict p h x : M‚ÇÇ) = f x :=
rfl

@[simp] lemma ker_cod_restrict (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (p : submodule R‚ÇÇ M‚ÇÇ) (h : ‚àÄ x, f x ‚àà p) :
  ker (f.cod_restrict p h) = ker f :=
(f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).ker_cod_restrict p h

/-- Embedding of a submodule into the ambient space as a continuous linear map. -/
def subtype_val (p : submodule R‚ÇÅ M‚ÇÅ) : p ‚ÜíL[R‚ÇÅ] M‚ÇÅ :=
{ cont := continuous_subtype_val,
  to_linear_map := p.subtype }

@[simp, norm_cast] lemma coe_subtype_val (p : submodule R‚ÇÅ M‚ÇÅ) :
  (subtype_val p : p ‚Üí‚Çó[R‚ÇÅ] M‚ÇÅ) = p.subtype :=
rfl

@[simp, norm_cast] lemma subtype_val_apply (p : submodule R‚ÇÅ M‚ÇÅ) (x : p) :
  (subtype_val p : p ‚Üí M‚ÇÅ) x = x :=
rfl

variables (R‚ÇÅ M‚ÇÅ M‚ÇÇ)

/-- `prod.fst` as a `continuous_linear_map`. -/
def fst [module R‚ÇÅ M‚ÇÇ] : M‚ÇÅ √ó M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÅ :=
{ cont := continuous_fst, to_linear_map := linear_map.fst R‚ÇÅ M‚ÇÅ M‚ÇÇ }

/-- `prod.snd` as a `continuous_linear_map`. -/
def snd [module R‚ÇÅ M‚ÇÇ] : M‚ÇÅ √ó M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÇ :=
{ cont := continuous_snd, to_linear_map := linear_map.snd R‚ÇÅ M‚ÇÅ M‚ÇÇ }

variables {R‚ÇÅ M‚ÇÅ M‚ÇÇ}

@[simp, norm_cast] lemma coe_fst [module R‚ÇÅ M‚ÇÇ] :
  (fst R‚ÇÅ M‚ÇÅ M‚ÇÇ : M‚ÇÅ √ó M‚ÇÇ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÅ) = linear_map.fst R‚ÇÅ M‚ÇÅ M‚ÇÇ := rfl

@[simp, norm_cast] lemma coe_fst' [module R‚ÇÅ M‚ÇÇ] : (fst R‚ÇÅ M‚ÇÅ M‚ÇÇ : M‚ÇÅ √ó M‚ÇÇ ‚Üí M‚ÇÅ) = prod.fst := rfl

@[simp, norm_cast] lemma coe_snd [module R‚ÇÅ M‚ÇÇ] :
  (snd R‚ÇÅ M‚ÇÅ M‚ÇÇ : M‚ÇÅ √ó M‚ÇÇ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÇ) = linear_map.snd R‚ÇÅ M‚ÇÅ M‚ÇÇ := rfl

@[simp, norm_cast] lemma coe_snd' [module R‚ÇÅ M‚ÇÇ] : (snd R‚ÇÅ M‚ÇÅ M‚ÇÇ : M‚ÇÅ √ó M‚ÇÇ ‚Üí M‚ÇÇ) = prod.snd := rfl

@[simp] lemma fst_prod_snd [module R‚ÇÅ M‚ÇÇ] : (fst R‚ÇÅ M‚ÇÅ M‚ÇÇ).prod (snd R‚ÇÅ M‚ÇÅ M‚ÇÇ) = id R‚ÇÅ (M‚ÇÅ √ó M‚ÇÇ) :=
  ext $ Œª ‚ü®x, y‚ü©, rfl

@[simp] lemma fst_comp_prod [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] (f : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) :
  (fst R‚ÇÅ M‚ÇÇ M‚ÇÉ).comp (f.prod g) = f :=
ext $ Œª x, rfl

@[simp] lemma snd_comp_prod [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] (f : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) :
  (snd R‚ÇÅ M‚ÇÇ M‚ÇÉ).comp (f.prod g) = g :=
ext $ Œª x, rfl

/-- `prod.map` of two continuous linear maps. -/
def prod_map [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [module R‚ÇÅ M‚ÇÑ] (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÉ ‚ÜíL[R‚ÇÅ] M‚ÇÑ) :
  (M‚ÇÅ √ó M‚ÇÉ) ‚ÜíL[R‚ÇÅ] (M‚ÇÇ √ó M‚ÇÑ) :=
(f‚ÇÅ.comp (fst R‚ÇÅ M‚ÇÅ M‚ÇÉ)).prod (f‚ÇÇ.comp (snd R‚ÇÅ M‚ÇÅ M‚ÇÉ))

@[simp, norm_cast] lemma coe_prod_map [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [module R‚ÇÅ M‚ÇÑ]
  (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÉ ‚ÜíL[R‚ÇÅ] M‚ÇÑ) :
  (f‚ÇÅ.prod_map f‚ÇÇ : (M‚ÇÅ √ó M‚ÇÉ) ‚Üí‚Çó[R‚ÇÅ] (M‚ÇÇ √ó M‚ÇÑ))
  = ((f‚ÇÅ : M‚ÇÅ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÇ).prod_map (f‚ÇÇ : M‚ÇÉ ‚Üí‚Çó[R‚ÇÅ] M‚ÇÑ)) :=
rfl

@[simp, norm_cast] lemma coe_prod_map' [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [module R‚ÇÅ M‚ÇÑ]
  (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÉ ‚ÜíL[R‚ÇÅ] M‚ÇÑ) :
  ‚áë(f‚ÇÅ.prod_map f‚ÇÇ) = prod.map f‚ÇÅ f‚ÇÇ :=
rfl

/-- The continuous linear map given by `(x, y) ‚Ü¶ f‚ÇÅ x + f‚ÇÇ y`. -/
def coprod [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [has_continuous_add M‚ÇÉ] (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ)
  (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) :
  (M‚ÇÅ √ó M‚ÇÇ) ‚ÜíL[R‚ÇÅ] M‚ÇÉ :=
‚ü®linear_map.coprod f‚ÇÅ f‚ÇÇ, (f‚ÇÅ.cont.comp continuous_fst).add (f‚ÇÇ.cont.comp continuous_snd)‚ü©

@[norm_cast, simp] lemma coe_coprod [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [has_continuous_add M‚ÇÉ]
  (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) :
  (f‚ÇÅ.coprod f‚ÇÇ : (M‚ÇÅ √ó M‚ÇÇ) ‚Üí‚Çó[R‚ÇÅ] M‚ÇÉ) = linear_map.coprod f‚ÇÅ f‚ÇÇ :=
rfl

@[simp] lemma coprod_apply [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [has_continuous_add M‚ÇÉ]
  (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) (x) :
  f‚ÇÅ.coprod f‚ÇÇ x = f‚ÇÅ x.1 + f‚ÇÇ x.2 := rfl

lemma range_coprod [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [has_continuous_add M‚ÇÉ] (f‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÉ)
  (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R‚ÇÅ] M‚ÇÉ) :
  (f‚ÇÅ.coprod f‚ÇÇ).range = f‚ÇÅ.range ‚äî f‚ÇÇ.range :=
linear_map.range_coprod _ _

section

variables {R S : Type*} [semiring R] [semiring S] [module R M‚ÇÅ] [module R M‚ÇÇ] [module R S]
  [module S M‚ÇÇ] [is_scalar_tower R S M‚ÇÇ] [topological_space S] [has_continuous_smul S M‚ÇÇ]

/-- The linear map `Œª x, c x ‚Ä¢ f`.  Associates to a scalar-valued linear map and an element of
`M‚ÇÇ` the `M‚ÇÇ`-valued linear map obtained by multiplying the two (a.k.a. tensoring by `M‚ÇÇ`).
See also `continuous_linear_map.smul_right‚Çó` and `continuous_linear_map.smul_rightL`. -/
def smul_right (c : M‚ÇÅ ‚ÜíL[R] S) (f : M‚ÇÇ) : M‚ÇÅ ‚ÜíL[R] M‚ÇÇ :=
{ cont := c.2.smul continuous_const,
  ..c.to_linear_map.smul_right f }

@[simp]
lemma smul_right_apply {c : M‚ÇÅ ‚ÜíL[R] S} {f : M‚ÇÇ} {x : M‚ÇÅ} :
  (smul_right c f : M‚ÇÅ ‚Üí M‚ÇÇ) x = c x ‚Ä¢ f :=
rfl

end

section pointwise
open_locale pointwise

@[simp] lemma image_smul_set‚Çõ‚Çó (c : R‚ÇÅ) (s : set M‚ÇÅ) :
  f '' (c ‚Ä¢ s) = (œÉ‚ÇÅ‚ÇÇ c) ‚Ä¢ f '' s :=
f.to_linear_map.image_smul_set‚Çõ‚Çó c s

lemma image_smul_set (c : R‚ÇÅ) (s : set M‚ÇÅ) :
  f‚Çó '' (c ‚Ä¢ s) = c ‚Ä¢ f‚Çó '' s :=
f‚Çó.to_linear_map.image_smul_set c s

lemma preimage_smul_set‚Çõ‚Çó {c : R‚ÇÅ} (hc : is_unit c) (s : set M‚ÇÇ) :
  f ‚Åª¬π' (œÉ‚ÇÅ‚ÇÇ c ‚Ä¢ s) = c ‚Ä¢ f ‚Åª¬π' s :=
f.to_linear_map.preimage_smul_set‚Çõ‚Çó hc s

lemma preimage_smul_set {c : R‚ÇÅ} (hc : is_unit c) (s : set M'‚ÇÅ) :
  f‚Çó ‚Åª¬π' (c ‚Ä¢ s) = c ‚Ä¢ f‚Çó ‚Åª¬π' s :=
f‚Çó.to_linear_map.preimage_smul_set hc s

end pointwise

variables [module R‚ÇÅ M‚ÇÇ] [topological_space R‚ÇÅ] [has_continuous_smul R‚ÇÅ M‚ÇÇ]

@[simp]
lemma smul_right_one_one (c : R‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ) : smul_right (1 : R‚ÇÅ ‚ÜíL[R‚ÇÅ] R‚ÇÅ) (c 1) = c :=
by ext; simp [‚Üê continuous_linear_map.map_smul_of_tower]

@[simp]
lemma smul_right_one_eq_iff {f f' : M‚ÇÇ} :
  smul_right (1 : R‚ÇÅ ‚ÜíL[R‚ÇÅ] R‚ÇÅ) f = smul_right (1 : R‚ÇÅ ‚ÜíL[R‚ÇÅ] R‚ÇÅ) f' ‚Üî f = f' :=
by simp only [ext_ring_iff, smul_right_apply, one_apply, one_smul]

lemma smul_right_comp [has_continuous_mul R‚ÇÅ] {x : M‚ÇÇ} {c : R‚ÇÅ} :
  (smul_right (1 : R‚ÇÅ ‚ÜíL[R‚ÇÅ] R‚ÇÅ) x).comp (smul_right (1 : R‚ÇÅ ‚ÜíL[R‚ÇÅ] R‚ÇÅ) c) =
    smul_right (1 : R‚ÇÅ ‚ÜíL[R‚ÇÅ] R‚ÇÅ) (c ‚Ä¢ x) :=
by { ext, simp [mul_smul] }

end semiring

section pi
variables
  {R : Type*} [semiring R]
  {M : Type*} [topological_space M] [add_comm_monoid M] [module R M]
  {M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ]
  {Œπ : Type*} {œÜ : Œπ ‚Üí Type*} [‚àÄi, topological_space (œÜ i)] [‚àÄi, add_comm_monoid (œÜ i)]
  [‚àÄi, module R (œÜ i)]

/-- `pi` construction for continuous linear functions. From a family of continuous linear functions
it produces a continuous linear function into a family of topological modules. -/
def pi (f : Œ†i, M ‚ÜíL[R] œÜ i) : M ‚ÜíL[R] (Œ†i, œÜ i) :=
‚ü®linear_map.pi (Œª i, f i), continuous_pi (Œª i, (f i).continuous)‚ü©

@[simp] lemma coe_pi' (f : Œ† i, M ‚ÜíL[R] œÜ i) : ‚áë(pi f) = Œª c i, f i c := rfl
@[simp] lemma coe_pi (f : Œ† i, M ‚ÜíL[R] œÜ i) :
  (pi f : M ‚Üí‚Çó[R] Œ† i, œÜ i) = linear_map.pi (Œª i, f i) :=
rfl

lemma pi_apply (f : Œ†i, M ‚ÜíL[R] œÜ i) (c : M) (i : Œπ) :
  pi f c i = f i c := rfl

lemma pi_eq_zero (f : Œ†i, M ‚ÜíL[R] œÜ i) : pi f = 0 ‚Üî (‚àÄi, f i = 0) :=
by { simp only [ext_iff, pi_apply, function.funext_iff], exact forall_swap }

lemma pi_zero : pi (Œªi, 0 : Œ†i, M ‚ÜíL[R] œÜ i) = 0 := ext $ Œª _, rfl

lemma pi_comp (f : Œ†i, M ‚ÜíL[R] œÜ i) (g : M‚ÇÇ ‚ÜíL[R] M) : (pi f).comp g = pi (Œªi, (f i).comp g) := rfl

/-- The projections from a family of topological modules are continuous linear maps. -/
def proj (i : Œπ) : (Œ†i, œÜ i) ‚ÜíL[R] œÜ i :=
‚ü®linear_map.proj i, continuous_apply _‚ü©

@[simp] lemma proj_apply (i : Œπ) (b : Œ†i, œÜ i) : (proj i : (Œ†i, œÜ i) ‚ÜíL[R] œÜ i) b = b i := rfl

lemma proj_pi (f : Œ†i, M‚ÇÇ ‚ÜíL[R] œÜ i) (i : Œπ) : (proj i).comp (pi f) = f i :=
ext $ assume c, rfl

lemma infi_ker_proj : (‚®Öi, ker (proj i) : submodule R (Œ†i, œÜ i)) = ‚ä• :=
linear_map.infi_ker_proj

variables (R œÜ)

/-- If `I` and `J` are complementary index sets, the product of the kernels of the `J`th projections
of `œÜ` is linearly equivalent to the product over `I`. -/
def infi_ker_proj_equiv {I J : set Œπ} [decidable_pred (Œªi, i ‚àà I)]
  (hd : disjoint I J) (hu : set.univ ‚äÜ I ‚à™ J) :
  (‚®Öi ‚àà J, ker (proj i) : submodule R (Œ†i, œÜ i)) ‚âÉL[R] (Œ†i:I, œÜ i) :=
‚ü® linear_map.infi_ker_proj_equiv R œÜ hd hu,
  continuous_pi (Œª i, begin
    have := @continuous_subtype_coe _ _ (Œª x, x ‚àà (‚®Öi ‚àà J, ker (proj i) : submodule R (Œ†i, œÜ i))),
    have := continuous.comp (by exact continuous_apply i) this,
    exact this
  end),
  continuous_subtype_mk _ (continuous_pi (Œª i, begin
    dsimp, split_ifs; [apply continuous_apply, exact continuous_zero]
  end)) ‚ü©

end pi

section ring

variables
{R : Type*} [ring R] {R‚ÇÇ : Type*} [ring R‚ÇÇ]
{M : Type*} [topological_space M] [add_comm_group M]
{M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_group M‚ÇÇ]
{M‚ÇÉ : Type*} [topological_space M‚ÇÉ] [add_comm_group M‚ÇÉ]
{M‚ÇÑ : Type*} [topological_space M‚ÇÑ] [add_comm_group M‚ÇÑ]
[module R M] [module R‚ÇÇ M‚ÇÇ]
{œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}

section
variables (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M)

protected lemma map_neg : f (-x) = - (f x) := (to_linear_map _).map_neg _
protected lemma map_sub : f (x - y) = f x - f y := (to_linear_map _).map_sub _ _
@[simp] lemma sub_apply' (x : M) : ((f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) - g) x = f x - g x := rfl
end

section
variables [module R M‚ÇÇ] [module R M‚ÇÉ] [module R M‚ÇÑ]
variables (c : R) (f g : M ‚ÜíL[R] M‚ÇÇ) (h : M‚ÇÇ ‚ÜíL[R] M‚ÇÉ) (x y z : M)

lemma range_prod_eq  {f : M ‚ÜíL[R] M‚ÇÇ} {g : M ‚ÜíL[R] M‚ÇÉ} (h : ker f ‚äî ker g = ‚ä§) :
  range (f.prod g) = (range f).prod (range g) :=
linear_map.range_prod_eq h

lemma ker_prod_ker_le_ker_coprod [has_continuous_add M‚ÇÉ]
  (f : M ‚ÜíL[R] M‚ÇÉ) (g : M‚ÇÇ ‚ÜíL[R] M‚ÇÉ) :
  (ker f).prod (ker g) ‚â§ ker (f.coprod g) :=
linear_map.ker_prod_ker_le_ker_coprod f.to_linear_map g.to_linear_map

lemma ker_coprod_of_disjoint_range [has_continuous_add M‚ÇÉ]
  (f : M ‚ÜíL[R] M‚ÇÉ) (g : M‚ÇÇ ‚ÜíL[R] M‚ÇÉ) (hd : disjoint f.range g.range) :
  ker (f.coprod g) = (ker f).prod (ker g) :=
linear_map.ker_coprod_of_disjoint_range f.to_linear_map g.to_linear_map hd
end

section
variables [topological_add_group M‚ÇÇ]
variables (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M)

instance : has_neg (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) := ‚ü®Œª f, ‚ü®-f, f.2.neg‚ü©‚ü©

@[simp] lemma neg_apply : (-f) x = - (f x) := rfl

@[simp, norm_cast] lemma coe_neg :
  (((-f) : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = -(f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :=
rfl
@[norm_cast] lemma coe_neg' : (((-f) : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M ‚Üí M‚ÇÇ) = -(f : M ‚Üí M‚ÇÇ) := rfl

instance : has_sub (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) := ‚ü®Œª f g, ‚ü®f - g, f.2.sub g.2‚ü©‚ü©

lemma continuous_zsmul : ‚àÄ (n : ‚Ñ§), continuous (Œª (x : M‚ÇÇ), n ‚Ä¢ x)
| (n : ‚Ñï) := by { simp only [coe_nat_zsmul], exact continuous_nsmul _ }
| -[1+ n] := by { simp only [zsmul_neg_succ_of_nat], exact (continuous_nsmul _).neg }

@[continuity]
lemma continuous.zsmul {Œ± : Type*} [topological_space Œ±] {n : ‚Ñ§} {f : Œ± ‚Üí M‚ÇÇ} (hf : continuous f) :
  continuous (Œª (x : Œ±), n ‚Ä¢ (f x)) :=
(continuous_zsmul n).comp hf

instance : add_comm_group (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :=
by refine
{ zero := 0,
  add := (+),
  neg := has_neg.neg,
  sub := has_sub.sub,
  sub_eq_add_neg := _,
  nsmul := Œª n f,
    { to_fun := Œª x, n ‚Ä¢ (f x),
      map_add' := by simp,
      map_smul' := by simp [smul_comm n] },
  zsmul := Œª n f,
    { to_fun := Œª x, n ‚Ä¢ (f x),
      map_add' := by simp,
      map_smul' := by simp [smul_comm n] },
  zsmul_zero' := Œª f, by { ext, simp },
  zsmul_succ' := Œª n f, by { ext, simp [add_smul, add_comm] },
  zsmul_neg' := Œª n f, by { ext, simp [nat.succ_eq_add_one, add_smul] },
  .. continuous_linear_map.add_comm_monoid, .. };
intros; ext; apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm, sub_eq_add_neg]

lemma sub_apply (x : M) : (f - g) x = f x - g x := rfl
@[simp, norm_cast] lemma coe_sub : (((f - g) : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = f - g := rfl
@[simp, norm_cast] lemma coe_sub' : (((f - g) : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M ‚Üí M‚ÇÇ) = (f : M ‚Üí M‚ÇÇ) - g := rfl

end

instance [topological_add_group M] : ring (M ‚ÜíL[R] M) :=
{ mul := (*),
  one := 1,
  mul_one := Œª _, ext $ Œª _, rfl,
  one_mul := Œª _, ext $ Œª _, rfl,
  mul_assoc := Œª _ _ _, ext $ Œª _, rfl,
  left_distrib := Œª f g h, ext $ Œª x, map_add f (g x) (h x),
  right_distrib := Œª _ _ _, ext $ Œª _, linear_map.add_apply _ _ _,
  ..continuous_linear_map.add_comm_group }

lemma smul_right_one_pow [topological_space R] [topological_ring R] (c : R) (n : ‚Ñï) :
  (smul_right (1 : R ‚ÜíL[R] R) c)^n = smul_right (1 : R ‚ÜíL[R] R) (c^n) :=
begin
  induction n with n ihn,
  { ext, simp },
  { rw [pow_succ, ihn, mul_def, smul_right_comp, smul_eq_mul, pow_succ'] }
end

section
variables {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ]

/-- Given a right inverse `f‚ÇÇ : M‚ÇÇ ‚ÜíL[R] M` to `f‚ÇÅ : M ‚ÜíL[R] M‚ÇÇ`,
`proj_ker_of_right_inverse f‚ÇÅ f‚ÇÇ h` is the projection `M ‚ÜíL[R] f‚ÇÅ.ker` along `f‚ÇÇ.range`. -/
def proj_ker_of_right_inverse [topological_add_group M] (f‚ÇÅ : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÅ] M)
  (h : function.right_inverse f‚ÇÇ f‚ÇÅ) :
  M ‚ÜíL[R] f‚ÇÅ.ker :=
(id R M - f‚ÇÇ.comp f‚ÇÅ).cod_restrict f‚ÇÅ.ker $ Œª x, by simp [h (f‚ÇÅ x)]

@[simp] lemma coe_proj_ker_of_right_inverse_apply [topological_add_group M]
  (f‚ÇÅ : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÅ] M) (h : function.right_inverse f‚ÇÇ f‚ÇÅ) (x : M) :
  (f‚ÇÅ.proj_ker_of_right_inverse f‚ÇÇ h x : M) = x - f‚ÇÇ (f‚ÇÅ x) :=
rfl

@[simp] lemma proj_ker_of_right_inverse_apply_idem [topological_add_group M]
  (f‚ÇÅ : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÅ] M) (h : function.right_inverse f‚ÇÇ f‚ÇÅ) (x : f‚ÇÅ.ker) :
  f‚ÇÅ.proj_ker_of_right_inverse f‚ÇÇ h x = x :=
subtype.ext_iff_val.2 $ by simp

@[simp] lemma proj_ker_of_right_inverse_comp_inv [topological_add_group M]
  (f‚ÇÅ : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÅ] M) (h : function.right_inverse f‚ÇÇ f‚ÇÅ) (y : M‚ÇÇ) :
  f‚ÇÅ.proj_ker_of_right_inverse f‚ÇÇ h (f‚ÇÇ y) = 0 :=
subtype.ext_iff_val.2 $ by simp [h y]

end

end ring

section smul_monoid

-- The M's are used for semilinear maps, and the N's for plain linear maps
variables {R R‚ÇÇ R‚ÇÉ S S‚ÇÉ : Type*} [semiring R] [semiring R‚ÇÇ] [semiring R‚ÇÉ]
  [monoid S] [monoid S‚ÇÉ] [topological_space S] [topological_space S‚ÇÉ]
  {M : Type*} [topological_space M] [add_comm_monoid M] [module R M]
  {M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ]
  {M‚ÇÉ : Type*} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ] [module R‚ÇÉ M‚ÇÉ]
  {N‚ÇÇ : Type*} [topological_space N‚ÇÇ] [add_comm_monoid N‚ÇÇ] [module R N‚ÇÇ]
  {N‚ÇÉ : Type*} [topological_space N‚ÇÉ] [add_comm_monoid N‚ÇÉ] [module R N‚ÇÉ]
  [distrib_mul_action S‚ÇÉ M‚ÇÉ] [smul_comm_class R‚ÇÉ S‚ÇÉ M‚ÇÉ] [has_continuous_smul S‚ÇÉ M‚ÇÉ]
  [distrib_mul_action S N‚ÇÉ] [smul_comm_class R S N‚ÇÉ] [has_continuous_smul S N‚ÇÉ]
  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ]

instance : mul_action S‚ÇÉ (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ) :=
{ smul := Œª c f, ‚ü®c ‚Ä¢ f, (continuous_const.smul f.2 : continuous (Œª x, c ‚Ä¢ f x))‚ü©,
  one_smul := Œª f, ext $ Œª x, one_smul _ _,
  mul_smul := Œª a b f, ext $ Œª x, mul_smul _ _ _ }

variables (c : S‚ÇÉ) (h : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y z : M)
variables (h‚Çó : N‚ÇÇ ‚ÜíL[R] N‚ÇÉ) (f‚Çó g‚Çó : M ‚ÜíL[R] N‚ÇÇ)

include œÉ‚ÇÅ‚ÇÉ
@[simp] lemma smul_comp : (c ‚Ä¢ h).comp f = c ‚Ä¢ (h.comp f) := rfl
omit œÉ‚ÇÅ‚ÇÉ

variables [distrib_mul_action S‚ÇÉ M‚ÇÇ] [has_continuous_smul S‚ÇÉ M‚ÇÇ] [smul_comm_class R‚ÇÇ S‚ÇÉ M‚ÇÇ]
variables [distrib_mul_action S N‚ÇÇ] [has_continuous_smul S N‚ÇÇ] [smul_comm_class R S N‚ÇÇ]

lemma smul_apply : (c ‚Ä¢ f) x = c ‚Ä¢ (f x) := rfl
@[simp, norm_cast] lemma coe_smul : (((c ‚Ä¢ f) : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = c ‚Ä¢ f := rfl
@[simp, norm_cast] lemma coe_smul' : (((c ‚Ä¢ f) : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M ‚Üí M‚ÇÇ) = c ‚Ä¢ f := rfl

@[simp] lemma comp_smul [linear_map.compatible_smul N‚ÇÇ N‚ÇÉ S R] (c : S) :
  h‚Çó.comp (c ‚Ä¢ f‚Çó) = c ‚Ä¢ (h‚Çó.comp f‚Çó) :=
by { ext x, exact h‚Çó.map_smul_of_tower c (f‚Çó x) }

include œÉ‚ÇÅ‚ÇÉ
@[simp] lemma comp_smul‚Çõ‚Çó (c : R‚ÇÇ) [smul_comm_class R‚ÇÇ R‚ÇÇ M‚ÇÇ] [smul_comm_class R‚ÇÉ R‚ÇÉ M‚ÇÉ]
  [topological_space R‚ÇÇ] [has_continuous_smul R‚ÇÇ M‚ÇÇ] [topological_space R‚ÇÉ]
  [has_continuous_smul R‚ÇÉ M‚ÇÉ] :
  h.comp (c ‚Ä¢ f) = (œÉ‚ÇÇ‚ÇÉ c) ‚Ä¢ (h.comp f) :=
by { ext x, simp only [coe_smul', coe_comp', function.comp_app, pi.smul_apply, map_smul‚Çõ‚Çó] }
omit œÉ‚ÇÅ‚ÇÉ

instance {T : Type*} [monoid T] [topological_space T] [distrib_mul_action T M‚ÇÇ]
  [has_continuous_smul T M‚ÇÇ] [smul_comm_class R‚ÇÇ T M‚ÇÇ] [has_scalar S‚ÇÉ T]
  [is_scalar_tower S‚ÇÉ T M‚ÇÇ] : is_scalar_tower S‚ÇÉ T (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :=
‚ü®Œª a b f, ext $ Œª x, smul_assoc a b (f x)‚ü©

instance {T : Type*} [monoid T] [topological_space T] [distrib_mul_action T M‚ÇÇ]
  [has_continuous_smul T M‚ÇÇ] [smul_comm_class R‚ÇÇ T M‚ÇÇ] [smul_comm_class S‚ÇÉ T M‚ÇÇ] :
  smul_comm_class S‚ÇÉ T (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :=
‚ü®Œª a b f, ext $ Œª x, smul_comm a b (f x)‚ü©

instance [has_continuous_add M‚ÇÇ] : distrib_mul_action S‚ÇÉ (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :=
{ smul_add := Œª a f g, ext $ Œª x, smul_add a (f x) (g x),
  smul_zero := Œª a, ext $ Œª x, smul_zero _ }

end smul_monoid

section smul

-- The M's are used for semilinear maps, and the N's for plain linear maps
variables {R R‚ÇÇ R‚ÇÉ S S‚ÇÉ : Type*} [semiring R] [semiring R‚ÇÇ] [semiring R‚ÇÉ]
  [semiring S] [semiring S‚ÇÉ] [topological_space S] [topological_space S‚ÇÉ]
  {M : Type*} [topological_space M] [add_comm_monoid M] [module R M]
  {M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ]
  {M‚ÇÉ : Type*} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ] [module R‚ÇÉ M‚ÇÉ]
  {N‚ÇÇ : Type*} [topological_space N‚ÇÇ] [add_comm_monoid N‚ÇÇ] [module R N‚ÇÇ]
  {N‚ÇÉ : Type*} [topological_space N‚ÇÉ] [add_comm_monoid N‚ÇÉ] [module R N‚ÇÉ]
  [module S‚ÇÉ M‚ÇÉ] [smul_comm_class R‚ÇÉ S‚ÇÉ M‚ÇÉ] [has_continuous_smul S‚ÇÉ M‚ÇÉ]
  [module S N‚ÇÇ] [has_continuous_smul S N‚ÇÇ] [smul_comm_class R S N‚ÇÇ]
  [module S N‚ÇÉ] [smul_comm_class R S N‚ÇÉ] [has_continuous_smul S N‚ÇÉ]
  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ} [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ]
  (c : S) (h : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y z : M)

/-- `continuous_linear_map.prod` as an `equiv`. -/
@[simps apply] def prod_equiv : ((M ‚ÜíL[R] N‚ÇÇ) √ó (M ‚ÜíL[R] N‚ÇÉ)) ‚âÉ (M ‚ÜíL[R] N‚ÇÇ √ó N‚ÇÉ) :=
{ to_fun := Œª f, f.1.prod f.2,
  inv_fun := Œª f, ‚ü®(fst _ _ _).comp f, (snd _ _ _).comp f‚ü©,
  left_inv := Œª f, by ext; refl,
  right_inv := Œª f, by ext; refl }

lemma prod_ext_iff {f g : M √ó N‚ÇÇ ‚ÜíL[R] N‚ÇÉ} :
  f = g ‚Üî f.comp (inl _ _ _) = g.comp (inl _ _ _) ‚àß f.comp (inr _ _ _) = g.comp (inr _ _ _) :=
by { simp only [‚Üê coe_inj, linear_map.prod_ext_iff], refl }

@[ext] lemma prod_ext {f g : M √ó N‚ÇÇ ‚ÜíL[R] N‚ÇÉ} (hl : f.comp (inl _ _ _) = g.comp (inl _ _ _))
  (hr : f.comp (inr _ _ _) = g.comp (inr _ _ _)) : f = g :=
prod_ext_iff.2 ‚ü®hl, hr‚ü©

variables [has_continuous_add M‚ÇÇ] [has_continuous_add M‚ÇÉ] [has_continuous_add N‚ÇÇ]

instance : module S‚ÇÉ (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ) :=
{ zero_smul := Œª _, ext $ Œª _, zero_smul _ _,
  add_smul  := Œª _ _ _, ext $ Œª _, add_smul _ _ _ }

instance [module S‚ÇÉ·µê·µí·µñ M‚ÇÉ] [is_central_scalar S‚ÇÉ M‚ÇÉ] : is_central_scalar S‚ÇÉ (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ) :=
{ op_smul_eq_smul := Œª _ _, ext $ Œª _, op_smul_eq_smul _ _ }

variables (S) [has_continuous_add N‚ÇÉ]

/-- `continuous_linear_map.prod` as a `linear_equiv`. -/
@[simps apply] def prod‚Çó : ((M ‚ÜíL[R] N‚ÇÇ) √ó (M ‚ÜíL[R] N‚ÇÉ)) ‚âÉ‚Çó[S] (M ‚ÜíL[R] N‚ÇÇ √ó N‚ÇÉ) :=
{ map_add' := Œª f g, rfl,
  map_smul' := Œª c f, rfl,
  .. prod_equiv }

/-- The coercion from `M ‚ÜíL[R] M‚ÇÇ` to `M ‚Üí‚Çó[R] M‚ÇÇ`, as a linear map. -/
@[simps]
def coe_lm : (M ‚ÜíL[R] N‚ÇÉ) ‚Üí‚Çó[S] (M ‚Üí‚Çó[R] N‚ÇÉ) :=
{ to_fun := coe,
  map_add' := Œª f g, coe_add f g,
  map_smul' := Œª c f, coe_smul c f }

variables {S} (œÉ‚ÇÅ‚ÇÉ)

/-- The coercion from `M ‚ÜíSL[œÉ] M‚ÇÇ` to `M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ`, as a linear map. -/
@[simps]
def coe_lm‚Çõ‚Çó : (M ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ) ‚Üí‚Çó[S‚ÇÉ] (M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ) :=
{ to_fun := coe,
  map_add' := Œª f g, coe_add f g,
  map_smul' := Œª c f, coe_smul c f }

variables {œÉ‚ÇÅ‚ÇÉ}

end smul

section smul_right‚Çó

variables {R S T M M‚ÇÇ : Type*} [ring R] [ring S] [ring T] [module R S]
  [add_comm_group M‚ÇÇ] [module R M‚ÇÇ] [module S M‚ÇÇ] [is_scalar_tower R S M‚ÇÇ]
  [topological_space S] [topological_space M‚ÇÇ] [has_continuous_smul S M‚ÇÇ]
  [topological_space M] [add_comm_group M] [module R M] [topological_add_group M‚ÇÇ]
  [topological_space T] [module T M‚ÇÇ] [has_continuous_smul T M‚ÇÇ]
  [smul_comm_class R T M‚ÇÇ] [smul_comm_class S T M‚ÇÇ]

/-- Given `c : E ‚ÜíL[ùïú] ùïú`, `c.smul_right‚Çó` is the linear map from `F` to `E ‚ÜíL[ùïú] F`
sending `f` to `Œª e, c e ‚Ä¢ f`. See also `continuous_linear_map.smul_rightL`. -/
def smul_right‚Çó (c : M ‚ÜíL[R] S) : M‚ÇÇ ‚Üí‚Çó[T] (M ‚ÜíL[R] M‚ÇÇ) :=
{ to_fun := c.smul_right,
  map_add' := Œª x y, by { ext e, apply smul_add },
  map_smul' := Œª a x, by { ext e, dsimp, apply smul_comm } }

@[simp] lemma coe_smul_right‚Çó (c : M ‚ÜíL[R] S) :
  ‚áë(smul_right‚Çó c : M‚ÇÇ ‚Üí‚Çó[T] (M ‚ÜíL[R] M‚ÇÇ)) = c.smul_right := rfl

end smul_right‚Çó

section comm_ring

/-- The determinant of a continuous linear map, mainly as a convenience device to be able to
write `A.det` instead of `(A : M ‚Üí‚Çó[R] M).det`. -/
@[reducible] noncomputable def det {R : Type*} [comm_ring R] [is_domain R]
  {M : Type*} [topological_space M] [add_comm_group M] [module R M] (A : M ‚ÜíL[R] M) : R :=
linear_map.det (A : M ‚Üí‚Çó[R] M)

variables
{R : Type*} [comm_ring R] [topological_space R]
{M : Type*} [topological_space M] [add_comm_group M]
{M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_group M‚ÇÇ]
{M‚ÇÉ : Type*} [topological_space M‚ÇÉ] [add_comm_group M‚ÇÉ]
[module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] [has_continuous_smul R M‚ÇÉ]

variables [topological_add_group M‚ÇÇ] [has_continuous_smul R M‚ÇÇ]

instance : algebra R (M‚ÇÇ ‚ÜíL[R] M‚ÇÇ) :=
algebra.of_module smul_comp (Œª _ _ _, comp_smul _ _ _)

end comm_ring

section restrict_scalars

variables {A M M‚ÇÇ : Type*} [ring A] [add_comm_group M] [add_comm_group M‚ÇÇ]
  [module A M] [module A M‚ÇÇ] [topological_space M] [topological_space M‚ÇÇ]
  (R : Type*) [ring R] [module R M] [module R M‚ÇÇ] [linear_map.compatible_smul M M‚ÇÇ R A]

/-- If `A` is an `R`-algebra, then a continuous `A`-linear map can be interpreted as a continuous
`R`-linear map. We assume `linear_map.compatible_smul M M‚ÇÇ R A` to match assumptions of
`linear_map.map_smul_of_tower`. -/
def restrict_scalars (f : M ‚ÜíL[A] M‚ÇÇ) : M ‚ÜíL[R] M‚ÇÇ :=
‚ü®(f : M ‚Üí‚Çó[A] M‚ÇÇ).restrict_scalars R, f.continuous‚ü©

variable {R}

@[simp, norm_cast] lemma coe_restrict_scalars (f : M ‚ÜíL[A] M‚ÇÇ) :
  (f.restrict_scalars R : M ‚Üí‚Çó[R] M‚ÇÇ) = (f : M ‚Üí‚Çó[A] M‚ÇÇ).restrict_scalars R := rfl

@[simp] lemma coe_restrict_scalars' (f : M ‚ÜíL[A] M‚ÇÇ) : ‚áë(f.restrict_scalars R) = f := rfl

@[simp] lemma restrict_scalars_zero : (0 : M ‚ÜíL[A] M‚ÇÇ).restrict_scalars R = 0 := rfl

section
variable [topological_add_group M‚ÇÇ]

@[simp] lemma restrict_scalars_add (f g : M ‚ÜíL[A] M‚ÇÇ) :
  (f + g).restrict_scalars R = f.restrict_scalars R + g.restrict_scalars R := rfl

@[simp] lemma restrict_scalars_neg (f : M ‚ÜíL[A] M‚ÇÇ) :
  (-f).restrict_scalars R = -f.restrict_scalars R := rfl
end

variables {S : Type*} [ring S] [topological_space S] [module S M‚ÇÇ] [has_continuous_smul S M‚ÇÇ]
  [smul_comm_class A S M‚ÇÇ] [smul_comm_class R S M‚ÇÇ]

@[simp] lemma restrict_scalars_smul (c : S) (f : M ‚ÜíL[A] M‚ÇÇ) :
  (c ‚Ä¢ f).restrict_scalars R = c ‚Ä¢ f.restrict_scalars R := rfl

variables (A M M‚ÇÇ R S) [topological_add_group M‚ÇÇ]

/-- `continuous_linear_map.restrict_scalars` as a `linear_map`. See also
`continuous_linear_map.restrict_scalarsL`. -/
def restrict_scalars‚Çó : (M ‚ÜíL[A] M‚ÇÇ) ‚Üí‚Çó[S] (M ‚ÜíL[R] M‚ÇÇ) :=
{ to_fun := restrict_scalars R,
  map_add' := restrict_scalars_add,
  map_smul' := restrict_scalars_smul }

variables {A M M‚ÇÇ R S}

@[simp] lemma coe_restrict_scalars‚Çó : ‚áë(restrict_scalars‚Çó A M M‚ÇÇ R S) = restrict_scalars R := rfl

end restrict_scalars

end continuous_linear_map

namespace continuous_linear_equiv

section add_comm_monoid

variables {R‚ÇÅ : Type*} {R‚ÇÇ : Type*} {R‚ÇÉ : Type*} [semiring R‚ÇÅ] [semiring R‚ÇÇ] [semiring R‚ÇÉ]
{œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ]
{œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÉ‚ÇÇ : R‚ÇÉ ‚Üí+* R‚ÇÇ} [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÉ‚ÇÇ] [ring_hom_inv_pair œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÇ‚ÇÉ]
{œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÉ‚ÇÅ : R‚ÇÉ ‚Üí+* R‚ÇÅ} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÉ‚ÇÅ œÉ‚ÇÅ‚ÇÉ]
[ring_hom_comp_triple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] [ring_hom_comp_triple œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÉ‚ÇÅ]
{M‚ÇÅ : Type*} [topological_space M‚ÇÅ] [add_comm_monoid M‚ÇÅ]
{M'‚ÇÅ : Type*} [topological_space M'‚ÇÅ] [add_comm_monoid M'‚ÇÅ]
{M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_monoid M‚ÇÇ]
{M‚ÇÉ : Type*} [topological_space M‚ÇÉ] [add_comm_monoid M‚ÇÉ]
{M‚ÇÑ : Type*} [topological_space M‚ÇÑ] [add_comm_monoid M‚ÇÑ]
[module R‚ÇÅ M‚ÇÅ] [module R‚ÇÅ M'‚ÇÅ] [module R‚ÇÇ M‚ÇÇ] [module R‚ÇÉ M‚ÇÉ]

include œÉ‚ÇÇ‚ÇÅ
/-- A continuous linear equivalence induces a continuous linear map. -/
def to_continuous_linear_map (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ :=
{ cont := e.continuous_to_fun,
  ..e.to_linear_equiv.to_linear_map }

/-- Coerce continuous linear equivs to continuous linear maps. -/
instance : has_coe (M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) := ‚ü®to_continuous_linear_map‚ü©

/-- Coerce continuous linear equivs to maps. -/
-- see Note [function coercion]
instance : has_coe_to_fun (M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (Œª _, M‚ÇÅ ‚Üí M‚ÇÇ) := ‚ü®Œª f, f‚ü©

@[simp] theorem coe_def_rev (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : e.to_continuous_linear_map = e := rfl

theorem coe_apply (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (b : M‚ÇÅ) : (e : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) b = e b := rfl

@[simp] lemma coe_to_linear_equiv (f : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áëf.to_linear_equiv = f := rfl

@[simp, norm_cast] lemma coe_coe (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ((e : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí M‚ÇÇ) = e := rfl

lemma to_linear_equiv_injective :
  function.injective (to_linear_equiv : (M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí (M‚ÇÅ ‚âÉ‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ))
| ‚ü®e, _, _‚ü© ‚ü®e', _, _‚ü© rfl := rfl

@[ext] lemma ext {f g : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (h : (f : M‚ÇÅ ‚Üí M‚ÇÇ) = g) : f = g :=
to_linear_equiv_injective $ linear_equiv.ext $ congr_fun h

lemma coe_injective : function.injective (coe : (M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) ‚Üí (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)) :=
Œª e e' h, ext $ funext $ continuous_linear_map.ext_iff.1 h

@[simp, norm_cast] lemma coe_inj {e e' : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} : (e : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = e' ‚Üî e = e' :=
coe_injective.eq_iff

/-- A continuous linear equivalence induces a homeomorphism. -/
def to_homeomorph (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚âÉ‚Çú M‚ÇÇ := { to_equiv := e.to_linear_equiv.to_equiv, ..e }

@[simp] lemma coe_to_homeomorph (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áëe.to_homeomorph = e := rfl

lemma image_closure (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : set M‚ÇÅ) : e '' closure s = closure (e '' s) :=
e.to_homeomorph.image_closure s

lemma preimage_closure (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : set M‚ÇÇ) : e ‚Åª¬π' closure s = closure (e ‚Åª¬π' s) :=
e.to_homeomorph.preimage_closure s

@[simp] lemma is_closed_image (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) {s : set M‚ÇÅ} :
  is_closed (e '' s) ‚Üî is_closed s :=
e.to_homeomorph.is_closed_image

lemma map_nhds_eq (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x : M‚ÇÅ) : map e (ùìù x) = ùìù (e x) :=
e.to_homeomorph.map_nhds_eq x

-- Make some straightforward lemmas available to `simp`.
@[simp] lemma map_zero (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : e (0 : M‚ÇÅ) = 0 := (e : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).map_zero
@[simp] lemma map_add (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=
(e : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).map_add x y
@[simp] lemma map_smul‚Çõ‚Çó (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (c : R‚ÇÅ) (x : M‚ÇÅ) : e (c ‚Ä¢ x) = œÉ‚ÇÅ‚ÇÇ c ‚Ä¢ (e x) :=
(e : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).map_smul‚Çõ‚Çó c x
omit œÉ‚ÇÇ‚ÇÅ

@[simp] lemma map_smul [module R‚ÇÅ M‚ÇÇ] (e : M‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÇ) (c : R‚ÇÅ) (x : M‚ÇÅ) :
  e (c ‚Ä¢ x) = c ‚Ä¢ (e x) :=
(e : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ).map_smul c x

include œÉ‚ÇÇ‚ÇÅ
@[simp] lemma map_eq_zero_iff (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) {x : M‚ÇÅ} : e x = 0 ‚Üî x = 0 :=
e.to_linear_equiv.map_eq_zero_iff

attribute [continuity]
  continuous_linear_equiv.continuous_to_fun continuous_linear_equiv.continuous_inv_fun

@[continuity]
protected lemma continuous (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : continuous (e : M‚ÇÅ ‚Üí M‚ÇÇ) :=
e.continuous_to_fun

protected lemma continuous_on (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) {s : set M‚ÇÅ} : continuous_on (e : M‚ÇÅ ‚Üí M‚ÇÇ) s :=
e.continuous.continuous_on

protected lemma continuous_at (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) {x : M‚ÇÅ} : continuous_at (e : M‚ÇÅ ‚Üí M‚ÇÇ) x :=
e.continuous.continuous_at

protected lemma continuous_within_at (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) {s : set M‚ÇÅ} {x : M‚ÇÅ} :
  continuous_within_at (e : M‚ÇÅ ‚Üí M‚ÇÇ) s x :=
e.continuous.continuous_within_at

lemma comp_continuous_on_iff
  {Œ± : Type*} [topological_space Œ±] (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) {f : Œ± ‚Üí M‚ÇÅ} {s : set Œ±} :
  continuous_on (e ‚àò f) s ‚Üî continuous_on f s :=
e.to_homeomorph.comp_continuous_on_iff _ _

lemma comp_continuous_iff
  {Œ± : Type*} [topological_space Œ±] (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) {f : Œ± ‚Üí M‚ÇÅ} :
  continuous (e ‚àò f) ‚Üî continuous f :=
e.to_homeomorph.comp_continuous_iff
omit œÉ‚ÇÇ‚ÇÅ

/-- An extensionality lemma for `R ‚âÉL[R] M`. -/
lemma ext‚ÇÅ [topological_space R‚ÇÅ] {f g : R‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÅ} (h : f 1 = g 1) : f = g :=
ext $ funext $ Œª x, mul_one x ‚ñ∏ by rw [‚Üê smul_eq_mul, map_smul, h, map_smul]

section
variables (R‚ÇÅ M‚ÇÅ)

/-- The identity map as a continuous linear equivalence. -/
@[refl] protected def refl : M‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÅ :=
{ continuous_to_fun := continuous_id,
  continuous_inv_fun := continuous_id,
  .. linear_equiv.refl R‚ÇÅ M‚ÇÅ }
end

@[simp, norm_cast] lemma coe_refl :
  (continuous_linear_equiv.refl R‚ÇÅ M‚ÇÅ : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) = continuous_linear_map.id R‚ÇÅ M‚ÇÅ := rfl

@[simp, norm_cast] lemma coe_refl' :
  (continuous_linear_equiv.refl R‚ÇÅ M‚ÇÅ : M‚ÇÅ ‚Üí M‚ÇÅ) = id := rfl

/-- The inverse of a continuous linear equivalence as a continuous linear equivalence-/
@[symm] protected def symm (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÇ ‚âÉSL[œÉ‚ÇÇ‚ÇÅ] M‚ÇÅ :=
{ continuous_to_fun := e.continuous_inv_fun,
  continuous_inv_fun := e.continuous_to_fun,
  .. e.to_linear_equiv.symm }

include œÉ‚ÇÇ‚ÇÅ
@[simp] lemma symm_to_linear_equiv (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  e.symm.to_linear_equiv = e.to_linear_equiv.symm :=
by { ext, refl }

@[simp] lemma symm_to_homeomorph (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  e.to_homeomorph.symm = e.symm.to_homeomorph :=
rfl

/-- See Note [custom simps projection]. We need to specify this projection explicitly in this case,
  because it is a composition of multiple projections. -/
def simps.apply (h : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÅ ‚Üí M‚ÇÇ := h

/-- See Note [custom simps projection] -/
def simps.symm_apply (h : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : M‚ÇÇ ‚Üí M‚ÇÅ := h.symm

initialize_simps_projections continuous_linear_equiv
  (to_linear_equiv_to_fun ‚Üí apply, to_linear_equiv_inv_fun ‚Üí symm_apply)

lemma symm_map_nhds_eq (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x : M‚ÇÅ) : map e.symm (ùìù (e x)) = ùìù x :=
e.to_homeomorph.symm_map_nhds_eq x
omit œÉ‚ÇÇ‚ÇÅ

include œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÉ‚ÇÅ
/-- The composition of two continuous linear equivalences as a continuous linear equivalence. -/
@[trans] protected def trans (e‚ÇÅ : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (e‚ÇÇ : M‚ÇÇ ‚âÉSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ :=
{ continuous_to_fun := e‚ÇÇ.continuous_to_fun.comp e‚ÇÅ.continuous_to_fun,
  continuous_inv_fun := e‚ÇÅ.continuous_inv_fun.comp e‚ÇÇ.continuous_inv_fun,
  .. e‚ÇÅ.to_linear_equiv.trans e‚ÇÇ.to_linear_equiv }

include œÉ‚ÇÅ‚ÇÉ
@[simp] lemma trans_to_linear_equiv (e‚ÇÅ : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (e‚ÇÇ : M‚ÇÇ ‚âÉSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) :
  (e‚ÇÅ.trans e‚ÇÇ).to_linear_equiv = e‚ÇÅ.to_linear_equiv.trans e‚ÇÇ.to_linear_equiv :=
by { ext, refl }
omit œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÉ‚ÇÅ

/-- Product of two continuous linear equivalences. The map comes from `equiv.prod_congr`. -/
def prod [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [module R‚ÇÅ M‚ÇÑ] (e : M‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÇ) (e' : M‚ÇÉ ‚âÉL[R‚ÇÅ] M‚ÇÑ) :
  (M‚ÇÅ √ó M‚ÇÉ) ‚âÉL[R‚ÇÅ] (M‚ÇÇ √ó M‚ÇÑ) :=
{ continuous_to_fun := e.continuous_to_fun.prod_map e'.continuous_to_fun,
  continuous_inv_fun := e.continuous_inv_fun.prod_map e'.continuous_inv_fun,
  .. e.to_linear_equiv.prod e'.to_linear_equiv }

@[simp, norm_cast] lemma prod_apply [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [module R‚ÇÅ M‚ÇÑ] (e : M‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÇ)
  (e' : M‚ÇÉ ‚âÉL[R‚ÇÅ] M‚ÇÑ) (x) :
  e.prod e' x = (e x.1, e' x.2) := rfl

@[simp, norm_cast] lemma coe_prod [module R‚ÇÅ M‚ÇÇ] [module R‚ÇÅ M‚ÇÉ] [module R‚ÇÅ M‚ÇÑ] (e : M‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÇ)
  (e' : M‚ÇÉ ‚âÉL[R‚ÇÅ] M‚ÇÑ) :
  (e.prod e' : (M‚ÇÅ √ó M‚ÇÉ) ‚ÜíL[R‚ÇÅ] (M‚ÇÇ √ó M‚ÇÑ)) = (e : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÇ).prod_map (e' : M‚ÇÉ ‚ÜíL[R‚ÇÅ] M‚ÇÑ) :=
rfl

include œÉ‚ÇÇ‚ÇÅ
theorem bijective (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : function.bijective e :=
e.to_linear_equiv.to_equiv.bijective
theorem injective (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : function.injective e :=
e.to_linear_equiv.to_equiv.injective
theorem surjective (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : function.surjective e :=
e.to_linear_equiv.to_equiv.surjective

include œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÉ‚ÇÅ œÉ‚ÇÅ‚ÇÉ
@[simp] theorem trans_apply (e‚ÇÅ : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (e‚ÇÇ : M‚ÇÇ ‚âÉSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) (c : M‚ÇÅ) :
  (e‚ÇÅ.trans e‚ÇÇ) c = e‚ÇÇ (e‚ÇÅ c) :=
rfl
omit œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÉ‚ÇÅ œÉ‚ÇÅ‚ÇÉ

@[simp] theorem apply_symm_apply (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (c : M‚ÇÇ) : e (e.symm c) = c :=
e.1.right_inv c
@[simp] theorem symm_apply_apply (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (b : M‚ÇÅ) : e.symm (e b) = b := e.1.left_inv b

include œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÅ
@[simp] theorem symm_trans_apply (e‚ÇÅ : M‚ÇÇ ‚âÉSL[œÉ‚ÇÇ‚ÇÅ] M‚ÇÅ) (e‚ÇÇ : M‚ÇÉ ‚âÉSL[œÉ‚ÇÉ‚ÇÇ] M‚ÇÇ) (c : M‚ÇÅ) :
  (e‚ÇÇ.trans e‚ÇÅ).symm c = e‚ÇÇ.symm (e‚ÇÅ.symm c) :=
rfl
omit œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÅ

@[simp] theorem symm_image_image (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : set M‚ÇÅ) : e.symm '' (e '' s) = s :=
e.to_linear_equiv.to_equiv.symm_image_image s
@[simp] theorem image_symm_image (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : set M‚ÇÇ) : e '' (e.symm '' s) = s :=
e.symm.symm_image_image s

include œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÉ‚ÇÅ
@[simp, norm_cast]
lemma comp_coe (f : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f' : M‚ÇÇ ‚âÉSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) :
  (f' : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ).comp (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = (f.trans f' : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] M‚ÇÉ) :=
rfl
omit œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÉ‚ÇÅ œÉ‚ÇÇ‚ÇÅ

@[simp] theorem coe_comp_coe_symm (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  (e : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).comp (e.symm : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÅ] M‚ÇÅ) = continuous_linear_map.id R‚ÇÇ M‚ÇÇ :=
continuous_linear_map.ext e.apply_symm_apply

@[simp] theorem coe_symm_comp_coe (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  (e.symm : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÅ] M‚ÇÅ).comp (e : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) = continuous_linear_map.id R‚ÇÅ M‚ÇÅ :=
continuous_linear_map.ext e.symm_apply_apply

include œÉ‚ÇÇ‚ÇÅ
@[simp] lemma symm_comp_self (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  (e.symm : M‚ÇÇ ‚Üí M‚ÇÅ) ‚àò (e : M‚ÇÅ ‚Üí M‚ÇÇ) = id :=
by{ ext x, exact symm_apply_apply e x }

@[simp] lemma self_comp_symm (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) :
  (e : M‚ÇÅ ‚Üí M‚ÇÇ) ‚àò (e.symm : M‚ÇÇ ‚Üí M‚ÇÅ) = id :=
by{ ext x, exact apply_symm_apply e x }

@[simp] theorem symm_symm (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : e.symm.symm = e :=
by { ext x, refl }
omit œÉ‚ÇÇ‚ÇÅ

@[simp] lemma refl_symm :
 (continuous_linear_equiv.refl R‚ÇÅ M‚ÇÅ).symm = continuous_linear_equiv.refl R‚ÇÅ M‚ÇÅ :=
rfl

include œÉ‚ÇÇ‚ÇÅ
theorem symm_symm_apply (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x : M‚ÇÅ) : e.symm.symm x = e x :=
rfl

lemma symm_apply_eq (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) {x y} : e.symm x = y ‚Üî x = e y :=
e.to_linear_equiv.symm_apply_eq

lemma eq_symm_apply (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) {x y} : y = e.symm x ‚Üî e y = x :=
e.to_linear_equiv.eq_symm_apply

protected lemma image_eq_preimage (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : set M‚ÇÅ) : e '' s = e.symm ‚Åª¬π' s :=
e.to_linear_equiv.to_equiv.image_eq_preimage s

protected lemma image_symm_eq_preimage (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : set M‚ÇÇ) : e.symm '' s = e ‚Åª¬π' s :=
by rw [e.symm.image_eq_preimage, e.symm_symm]

@[simp] protected lemma symm_preimage_preimage (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : set M‚ÇÇ) :
  e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s := e.to_linear_equiv.to_equiv.symm_preimage_preimage s

@[simp] protected lemma preimage_symm_preimage (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : set M‚ÇÅ) :
  e ‚Åª¬π' (e.symm ‚Åª¬π' s) = s := e.symm.symm_preimage_preimage s

omit œÉ‚ÇÇ‚ÇÅ

/-- Create a `continuous_linear_equiv` from two `continuous_linear_map`s that are
inverse of each other. -/
def equiv_of_inverse (f‚ÇÅ : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÅ] M‚ÇÅ) (h‚ÇÅ : function.left_inverse f‚ÇÇ f‚ÇÅ)
  (h‚ÇÇ : function.right_inverse f‚ÇÇ f‚ÇÅ) :
  M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ :=
{ to_fun := f‚ÇÅ,
  continuous_to_fun := f‚ÇÅ.continuous,
  inv_fun := f‚ÇÇ,
  continuous_inv_fun := f‚ÇÇ.continuous,
  left_inv := h‚ÇÅ,
  right_inv := h‚ÇÇ,
  .. f‚ÇÅ }

include œÉ‚ÇÇ‚ÇÅ
@[simp] lemma equiv_of_inverse_apply (f‚ÇÅ : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f‚ÇÇ h‚ÇÅ h‚ÇÇ x) :
  equiv_of_inverse f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ x = f‚ÇÅ x :=
rfl

@[simp] lemma symm_equiv_of_inverse (f‚ÇÅ : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (f‚ÇÇ h‚ÇÅ h‚ÇÇ) :
  (equiv_of_inverse f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ).symm = equiv_of_inverse f‚ÇÇ f‚ÇÅ h‚ÇÇ h‚ÇÅ :=
rfl
omit œÉ‚ÇÇ‚ÇÅ

section pointwise
open_locale pointwise
include œÉ‚ÇÇ‚ÇÅ

@[simp] lemma image_smul_set‚Çõ‚Çó (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (c : R‚ÇÅ) (s : set M‚ÇÅ) :
  e '' (c ‚Ä¢ s) = (œÉ‚ÇÅ‚ÇÇ c) ‚Ä¢ e '' s :=
e.to_linear_equiv.image_smul_set‚Çõ‚Çó c s

@[simp] lemma preimage_smul_set‚Çõ‚Çó (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (c : R‚ÇÇ) (s : set M‚ÇÇ) :
  e ‚Åª¬π' (c ‚Ä¢ s) = œÉ‚ÇÇ‚ÇÅ c ‚Ä¢ e ‚Åª¬π' s :=
e.to_linear_equiv.preimage_smul_set‚Çõ‚Çó c s
omit œÉ‚ÇÇ‚ÇÅ

@[simp] lemma image_smul_set (e : M‚ÇÅ ‚âÉL[R‚ÇÅ] M'‚ÇÅ) (c : R‚ÇÅ) (s : set M‚ÇÅ) :
  e '' (c ‚Ä¢ s) = c ‚Ä¢ e '' s :=
e.to_linear_equiv.image_smul_set c s

@[simp] lemma preimage_smul_set (e : M‚ÇÅ ‚âÉL[R‚ÇÅ] M'‚ÇÅ) (c : R‚ÇÅ) (s : set M'‚ÇÅ) :
  e ‚Åª¬π' (c ‚Ä¢ s) = c ‚Ä¢ e ‚Åª¬π' s :=
e.to_linear_equiv.preimage_smul_set c s

end pointwise

variable (M‚ÇÅ)

/-- The continuous linear equivalences from `M` to itself form a group under composition. -/
instance automorphism_group : group (M‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÅ) :=
{ mul          := Œª f g, g.trans f,
  one          := continuous_linear_equiv.refl R‚ÇÅ M‚ÇÅ,
  inv          := Œª f, f.symm,
  mul_assoc    := Œª f g h, by {ext, refl},
  mul_one      := Œª f, by {ext, refl},
  one_mul      := Œª f, by {ext, refl},
  mul_left_inv := Œª f, by {ext, exact f.left_inv x} }

variables {M‚ÇÅ} {R‚ÇÑ : Type*} [semiring R‚ÇÑ] [module R‚ÇÑ M‚ÇÑ]
  {œÉ‚ÇÉ‚ÇÑ : R‚ÇÉ ‚Üí+* R‚ÇÑ} {œÉ‚ÇÑ‚ÇÉ : R‚ÇÑ ‚Üí+* R‚ÇÉ} [ring_hom_inv_pair œÉ‚ÇÉ‚ÇÑ œÉ‚ÇÑ‚ÇÉ] [ring_hom_inv_pair œÉ‚ÇÑ‚ÇÉ œÉ‚ÇÉ‚ÇÑ]
  {œÉ‚ÇÇ‚ÇÑ : R‚ÇÇ ‚Üí+* R‚ÇÑ} {œÉ‚ÇÅ‚ÇÑ : R‚ÇÅ ‚Üí+* R‚ÇÑ}
  [ring_hom_comp_triple œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÑ œÉ‚ÇÇ‚ÇÑ] [ring_hom_comp_triple œÉ‚ÇÇ‚ÇÑ œÉ‚ÇÑ‚ÇÉ œÉ‚ÇÇ‚ÇÉ]
  [ring_hom_comp_triple œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÑ œÉ‚ÇÅ‚ÇÑ]

include œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÉ‚ÇÑ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÇ‚ÇÑ œÉ‚ÇÅ‚ÇÉ

/-- A pair of continuous (semi)linear equivalences generates an equivalence between the spaces of
continuous linear maps. -/
@[simps] def arrow_congr_equiv (e‚ÇÅ‚ÇÇ : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (e‚ÇÑ‚ÇÉ : M‚ÇÑ ‚âÉSL[œÉ‚ÇÑ‚ÇÉ] M‚ÇÉ) :
  (M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÑ] M‚ÇÑ) ‚âÉ (M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] M‚ÇÉ) :=
{ to_fun := Œª f, (e‚ÇÑ‚ÇÉ : M‚ÇÑ ‚ÜíSL[œÉ‚ÇÑ‚ÇÉ] M‚ÇÉ).comp (f.comp (e‚ÇÅ‚ÇÇ.symm : M‚ÇÇ ‚ÜíSL[œÉ‚ÇÇ‚ÇÅ] M‚ÇÅ)),
  inv_fun := Œª f, (e‚ÇÑ‚ÇÉ.symm : M‚ÇÉ ‚ÜíSL[œÉ‚ÇÉ‚ÇÑ] M‚ÇÑ).comp (f.comp (e‚ÇÅ‚ÇÇ : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)),
  left_inv := Œª f, continuous_linear_map.ext $ Œª x,
    by simp only [continuous_linear_map.comp_apply, symm_apply_apply, coe_coe],
  right_inv := Œª f, continuous_linear_map.ext $ Œª x,
    by simp only [continuous_linear_map.comp_apply, apply_symm_apply, coe_coe] }

end add_comm_monoid

section add_comm_group

variables {R : Type*} [semiring R]
{M : Type*} [topological_space M] [add_comm_group M]
{M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_group M‚ÇÇ]
{M‚ÇÉ : Type*} [topological_space M‚ÇÉ] [add_comm_group M‚ÇÉ]
{M‚ÇÑ : Type*} [topological_space M‚ÇÑ] [add_comm_group M‚ÇÑ]
[module R M] [module R M‚ÇÇ] [module R M‚ÇÉ] [module R M‚ÇÑ]

variables [topological_add_group M‚ÇÑ]

/-- Equivalence given by a block lower diagonal matrix. `e` and `e'` are diagonal square blocks,
  and `f` is a rectangular block below the diagonal. -/
def skew_prod (e : M ‚âÉL[R] M‚ÇÇ) (e' : M‚ÇÉ ‚âÉL[R] M‚ÇÑ) (f : M ‚ÜíL[R] M‚ÇÑ) :
  (M √ó M‚ÇÉ) ‚âÉL[R] M‚ÇÇ √ó M‚ÇÑ :=
{ continuous_to_fun := (e.continuous_to_fun.comp continuous_fst).prod_mk
    ((e'.continuous_to_fun.comp continuous_snd).add $ f.continuous.comp continuous_fst),
  continuous_inv_fun := (e.continuous_inv_fun.comp continuous_fst).prod_mk
    (e'.continuous_inv_fun.comp $ continuous_snd.sub $ f.continuous.comp $
      e.continuous_inv_fun.comp continuous_fst),
.. e.to_linear_equiv.skew_prod e'.to_linear_equiv ‚Üëf }
@[simp] lemma skew_prod_apply (e : M ‚âÉL[R] M‚ÇÇ) (e' : M‚ÇÉ ‚âÉL[R] M‚ÇÑ) (f : M ‚ÜíL[R] M‚ÇÑ) (x) :
  e.skew_prod e' f x = (e x.1, e' x.2 + f x.1) := rfl

@[simp] lemma skew_prod_symm_apply (e : M ‚âÉL[R] M‚ÇÇ) (e' : M‚ÇÉ ‚âÉL[R] M‚ÇÑ) (f : M ‚ÜíL[R] M‚ÇÑ) (x) :
  (e.skew_prod e' f).symm x = (e.symm x.1, e'.symm (x.2 - f (e.symm x.1))) := rfl

end add_comm_group

section ring

variables {R : Type*} [ring R] {R‚ÇÇ : Type*} [ring R‚ÇÇ]
{M : Type*} [topological_space M] [add_comm_group M] [module R M]
{M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_group M‚ÇÇ] [module R‚ÇÇ M‚ÇÇ]
variables {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [ring_hom_inv_pair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [ring_hom_inv_pair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ]

include œÉ‚ÇÇ‚ÇÅ
@[simp] lemma map_sub (e : M ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M) : e (x - y) = e x - e y :=
(e : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).map_sub x y

@[simp] lemma map_neg (e : M ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x : M) : e (-x) = -e x := (e : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ).map_neg x
omit œÉ‚ÇÇ‚ÇÅ

section
/-! The next theorems cover the identification between `M ‚âÉL[ùïú] M`and the group of units of the ring
`M ‚ÜíL[R] M`. -/
variables [topological_add_group M]

/-- An invertible continuous linear map `f` determines a continuous equivalence from `M` to itself.
-/
def of_unit (f : (M ‚ÜíL[R] M)À£) : (M ‚âÉL[R] M) :=
{ to_linear_equiv :=
  { to_fun    := f.val,
    map_add'  := by simp,
    map_smul' := by simp,
    inv_fun   := f.inv,
    left_inv  := Œª x, show (f.inv * f.val) x = x, by {rw f.inv_val, simp},
    right_inv := Œª x, show (f.val * f.inv) x = x, by {rw f.val_inv, simp}, },
  continuous_to_fun  := f.val.continuous,
  continuous_inv_fun := f.inv.continuous }

/-- A continuous equivalence from `M` to itself determines an invertible continuous linear map. -/
def to_unit (f : (M ‚âÉL[R] M)) : (M ‚ÜíL[R] M)À£ :=
{ val     := f,
  inv     := f.symm,
  val_inv := by {ext, simp},
  inv_val := by {ext, simp} }

variables (R M)

/-- The units of the algebra of continuous `R`-linear endomorphisms of `M` is multiplicatively
equivalent to the type of continuous linear equivalences between `M` and itself. -/
def units_equiv : (M ‚ÜíL[R] M)À£ ‚âÉ* (M ‚âÉL[R] M) :=
{ to_fun    := of_unit,
  inv_fun   := to_unit,
  left_inv  := Œª f, by {ext, refl},
  right_inv := Œª f, by {ext, refl},
  map_mul'  := Œª x y, by {ext, refl} }

@[simp] lemma units_equiv_apply (f : (M ‚ÜíL[R] M)À£) (x : M) :
  units_equiv R M f x = f x := rfl

end

section
variables (R) [topological_space R] [has_continuous_mul R]

/-- Continuous linear equivalences `R ‚âÉL[R] R` are enumerated by `RÀ£`. -/
def units_equiv_aut : RÀ£ ‚âÉ (R ‚âÉL[R] R) :=
{ to_fun := Œª u, equiv_of_inverse
    (continuous_linear_map.smul_right (1 : R ‚ÜíL[R] R) ‚Üëu)
    (continuous_linear_map.smul_right (1 : R ‚ÜíL[R] R) ‚Üëu‚Åª¬π)
    (Œª x, by simp) (Œª x, by simp),
  inv_fun := Œª e, ‚ü®e 1, e.symm 1,
    by rw [‚Üê smul_eq_mul, ‚Üê map_smul, smul_eq_mul, mul_one, symm_apply_apply],
    by rw [‚Üê smul_eq_mul, ‚Üê map_smul, smul_eq_mul, mul_one, apply_symm_apply]‚ü©,
  left_inv := Œª u, units.ext $ by simp,
  right_inv := Œª e, ext‚ÇÅ $ by simp }

variable {R}

@[simp] lemma units_equiv_aut_apply (u : RÀ£) (x : R) : units_equiv_aut R u x = x * u := rfl

@[simp] lemma units_equiv_aut_apply_symm (u : RÀ£) (x : R) :
  (units_equiv_aut R u).symm x = x * ‚Üëu‚Åª¬π := rfl

@[simp] lemma units_equiv_aut_symm_apply (e : R ‚âÉL[R] R) :
  ‚Üë((units_equiv_aut R).symm e) = e 1 :=
rfl

end

variables [module R M‚ÇÇ] [topological_add_group M]

open _root_.continuous_linear_map (id fst snd subtype_val mem_ker)

/-- A pair of continuous linear maps such that `f‚ÇÅ ‚àò f‚ÇÇ = id` generates a continuous
linear equivalence `e` between `M` and `M‚ÇÇ √ó f‚ÇÅ.ker` such that `(e x).2 = x` for `x ‚àà f‚ÇÅ.ker`,
`(e x).1 = f‚ÇÅ x`, and `(e (f‚ÇÇ y)).2 = 0`. The map is given by `e x = (f‚ÇÅ x, x - f‚ÇÇ (f‚ÇÅ x))`. -/
def equiv_of_right_inverse (f‚ÇÅ : M ‚ÜíL[R] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R] M) (h : function.right_inverse f‚ÇÇ f‚ÇÅ) :
  M ‚âÉL[R] M‚ÇÇ √ó f‚ÇÅ.ker :=
equiv_of_inverse (f‚ÇÅ.prod (f‚ÇÅ.proj_ker_of_right_inverse f‚ÇÇ h)) (f‚ÇÇ.coprod (subtype_val f‚ÇÅ.ker))
  (Œª x, by simp)
  (Œª ‚ü®x, y‚ü©, by simp [h x])

@[simp] lemma fst_equiv_of_right_inverse (f‚ÇÅ : M ‚ÜíL[R] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R] M)
  (h : function.right_inverse f‚ÇÇ f‚ÇÅ) (x : M) :
  (equiv_of_right_inverse f‚ÇÅ f‚ÇÇ h x).1 = f‚ÇÅ x := rfl

@[simp] lemma snd_equiv_of_right_inverse (f‚ÇÅ : M ‚ÜíL[R] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R] M)
  (h : function.right_inverse f‚ÇÇ f‚ÇÅ) (x : M) :
  ((equiv_of_right_inverse f‚ÇÅ f‚ÇÇ h x).2 : M) = x - f‚ÇÇ (f‚ÇÅ x) := rfl

@[simp] lemma equiv_of_right_inverse_symm_apply (f‚ÇÅ : M ‚ÜíL[R] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R] M)
  (h : function.right_inverse f‚ÇÇ f‚ÇÅ) (y : M‚ÇÇ √ó f‚ÇÅ.ker) :
  (equiv_of_right_inverse f‚ÇÅ f‚ÇÇ h).symm y = f‚ÇÇ y.1 + y.2 := rfl

end ring

section

variables (Œπ R M : Type*) [unique Œπ] [semiring R] [add_comm_monoid M] [module R M]
  [topological_space M]

/-- If `Œπ` has a unique element, then `Œπ ‚Üí M` is continuously linear equivalent to `M`. -/
def fun_unique : (Œπ ‚Üí M) ‚âÉL[R] M :=
{ to_linear_equiv := linear_equiv.fun_unique Œπ R M,
  .. homeomorph.fun_unique Œπ M }

variables {Œπ R M}

@[simp] lemma coe_fun_unique : ‚áë(fun_unique Œπ R M) = function.eval default := rfl
@[simp] lemma coe_fun_unique_symm : ‚áë(fun_unique Œπ R M).symm = function.const Œπ := rfl

variables (R M)

/-- Continuous linear equivalence between dependent functions `Œ† i : fin 2, M i` and `M 0 √ó M 1`. -/
@[simps { fully_applied := ff }]
def pi_fin_two (M : fin 2 ‚Üí Type*) [Œ† i, add_comm_monoid (M i)] [Œ† i, module R (M i)]
  [Œ† i, topological_space (M i)] :
  (Œ† i, M i) ‚âÉL[R] M 0 √ó M 1 :=
{ to_linear_equiv := linear_equiv.pi_fin_two R M, .. homeomorph.pi_fin_two M }

/-- Continuous linear equivalence between vectors in `M¬≤ = fin 2 ‚Üí M` and `M √ó M`. -/
@[simps { fully_applied := ff }]
def fin_two_arrow : (fin 2 ‚Üí M) ‚âÉL[R] M √ó M :=
{ to_linear_equiv := linear_equiv.fin_two_arrow R M, .. pi_fin_two R (Œª _, M) }

end

end continuous_linear_equiv

namespace continuous_linear_map

open_locale classical

variables {R : Type*} {M : Type*} {M‚ÇÇ : Type*} [topological_space M] [topological_space M‚ÇÇ]

section
variables [semiring R]
variables [add_comm_monoid M‚ÇÇ] [module R M‚ÇÇ]
variables [add_comm_monoid M] [module R M]

/-- Introduce a function `inverse` from `M ‚ÜíL[R] M‚ÇÇ` to `M‚ÇÇ ‚ÜíL[R] M`, which sends `f` to `f.symm` if
`f` is a continuous linear equivalence and to `0` otherwise.  This definition is somewhat ad hoc,
but one needs a fully (rather than partially) defined inverse function for some purposes, including
for calculus. -/
noncomputable def inverse : (M ‚ÜíL[R] M‚ÇÇ) ‚Üí (M‚ÇÇ ‚ÜíL[R] M) :=
Œª f, if h : ‚àÉ (e : M ‚âÉL[R] M‚ÇÇ), (e : M ‚ÜíL[R] M‚ÇÇ) = f then ((classical.some h).symm : M‚ÇÇ ‚ÜíL[R] M)
else 0

/-- By definition, if `f` is invertible then `inverse f = f.symm`. -/
@[simp] lemma inverse_equiv (e : M ‚âÉL[R] M‚ÇÇ) : inverse (e : M ‚ÜíL[R] M‚ÇÇ) = e.symm :=
begin
  have h : ‚àÉ (e' : M ‚âÉL[R] M‚ÇÇ), (e' : M ‚ÜíL[R] M‚ÇÇ) = ‚Üëe := ‚ü®e, rfl‚ü©,
  simp only [inverse, dif_pos h],
  congr,
  exact_mod_cast (classical.some_spec h)
end

/-- By definition, if `f` is not invertible then `inverse f = 0`. -/
@[simp] lemma inverse_non_equiv (f : M ‚ÜíL[R] M‚ÇÇ) (h : ¬¨‚àÉ (e' : M ‚âÉL[R] M‚ÇÇ), ‚Üëe' = f) :
  inverse f = 0 :=
dif_neg h

end

section
variables [ring R]
variables [add_comm_group M] [topological_add_group M] [module R M]
variables [add_comm_group M‚ÇÇ] [module R M‚ÇÇ]

@[simp] lemma ring_inverse_equiv (e : M ‚âÉL[R] M) :
  ring.inverse ‚Üëe = inverse (e : M ‚ÜíL[R] M) :=
begin
  suffices :
    ring.inverse ((((continuous_linear_equiv.units_equiv _ _).symm e) : M ‚ÜíL[R] M)) = inverse ‚Üëe,
  { convert this },
  simp,
  refl,
end

/-- The function `continuous_linear_equiv.inverse` can be written in terms of `ring.inverse` for the
ring of self-maps of the domain. -/
lemma to_ring_inverse (e : M ‚âÉL[R] M‚ÇÇ) (f : M ‚ÜíL[R] M‚ÇÇ) :
  inverse f = (ring.inverse ((e.symm : (M‚ÇÇ ‚ÜíL[R] M)).comp f)) ‚àòL ‚Üëe.symm :=
begin
  by_cases h‚ÇÅ : ‚àÉ (e' : M ‚âÉL[R] M‚ÇÇ), ‚Üëe' = f,
  { obtain ‚ü®e', he'‚ü© := h‚ÇÅ,
    rw ‚Üê he',
    change _ = (ring.inverse ‚Üë(e'.trans e.symm)) ‚àòL ‚Üëe.symm,
    ext,
    simp },
  { suffices : ¬¨is_unit ((e.symm : M‚ÇÇ ‚ÜíL[R] M).comp f),
    { simp [this, h‚ÇÅ] },
    contrapose! h‚ÇÅ,
    rcases h‚ÇÅ with ‚ü®F, hF‚ü©,
    use (continuous_linear_equiv.units_equiv _ _ F).trans e,
    ext,
    dsimp, rw [coe_fn_coe_base' F, hF], simp }
end

lemma ring_inverse_eq_map_inverse : ring.inverse = @inverse R M M _ _ _ _ _ _ _ :=
begin
  ext,
  simp [to_ring_inverse (continuous_linear_equiv.refl R M)],
end

end

end continuous_linear_map

namespace submodule

variables
{R : Type*} [ring R]
{M : Type*} [topological_space M] [add_comm_group M] [module R M]
{M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_group M‚ÇÇ] [module R M‚ÇÇ]

open continuous_linear_map

/-- A submodule `p` is called *complemented* if there exists a continuous projection `M ‚Üí‚Çó[R] p`. -/
def closed_complemented (p : submodule R M) : Prop := ‚àÉ f : M ‚ÜíL[R] p, ‚àÄ x : p, f x = x

lemma closed_complemented.has_closed_complement {p : submodule R M} [t1_space p]
  (h : closed_complemented p) :
  ‚àÉ (q : submodule R M) (hq : is_closed (q : set M)), is_compl p q :=
exists.elim h $ Œª f hf, ‚ü®f.ker, f.is_closed_ker, linear_map.is_compl_of_proj hf‚ü©

protected lemma closed_complemented.is_closed [topological_add_group M] [t1_space M]
  {p : submodule R M} (h : closed_complemented p) :
  is_closed (p : set M) :=
begin
  rcases h with ‚ü®f, hf‚ü©,
  have : ker (id R M - (subtype_val p).comp f) = p := linear_map.ker_id_sub_eq_of_proj hf,
  exact this ‚ñ∏ (is_closed_ker _)
end

@[simp] lemma closed_complemented_bot : closed_complemented (‚ä• : submodule R M) :=
‚ü®0, Œª x, by simp only [zero_apply, eq_zero_of_bot_submodule x]‚ü©

@[simp] lemma closed_complemented_top : closed_complemented (‚ä§ : submodule R M) :=
‚ü®(id R M).cod_restrict ‚ä§ (Œª x, trivial), Œª x, subtype.ext_iff_val.2 $ by simp‚ü©

end submodule

lemma continuous_linear_map.closed_complemented_ker_of_right_inverse {R : Type*} [ring R]
  {M : Type*} [topological_space M] [add_comm_group M]
  {M‚ÇÇ : Type*} [topological_space M‚ÇÇ] [add_comm_group M‚ÇÇ] [module R M] [module R M‚ÇÇ]
  [topological_add_group M] (f‚ÇÅ : M ‚ÜíL[R] M‚ÇÇ) (f‚ÇÇ : M‚ÇÇ ‚ÜíL[R] M)
  (h : function.right_inverse f‚ÇÇ f‚ÇÅ) :
  f‚ÇÅ.ker.closed_complemented :=
‚ü®f‚ÇÅ.proj_ker_of_right_inverse f‚ÇÇ h, f‚ÇÅ.proj_ker_of_right_inverse_apply_idem f‚ÇÇ h‚ü©
