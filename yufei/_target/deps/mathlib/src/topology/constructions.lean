/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Patrick Massot
-/
import topology.maps
import order.filter.pi
import data.fin.tuple

/-!
# Constructions of new topological spaces from old ones

This file constructs products, sums, subtypes and quotients of topological spaces
and sets up their basic theory, such as criteria for maps into or out of these
constructions to be continuous; descriptions of the open sets, neighborhood filters,
and generators of these constructions; and their behavior with respect to embeddings
and other specific classes of maps.

## Implementation note

The constructed topologies are defined using induced and coinduced topologies
along with the complete lattice structure on topologies. Their universal properties
(for example, a map `X ‚Üí Y √ó Z` is continuous if and only if both projections
`X ‚Üí Y`, `X ‚Üí Z` are) follow easily using order-theoretic descriptions of
continuity. With more work we can also extract descriptions of the open sets,
neighborhood filters and so on.

## Tags

product, sum, disjoint union, subspace, quotient space

-/

noncomputable theory

open topological_space set filter
open_locale classical topological_space filter

universes u v w x
variables {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œ¥ : Type x}

section constructions

instance {p : Œ± ‚Üí Prop} [t : topological_space Œ±] : topological_space (subtype p) :=
induced coe t

instance {r : Œ± ‚Üí Œ± ‚Üí Prop} [t : topological_space Œ±] : topological_space (quot r) :=
coinduced (quot.mk r) t

instance {s : setoid Œ±} [t : topological_space Œ±] : topological_space (quotient s) :=
coinduced quotient.mk t

instance [t‚ÇÅ : topological_space Œ±] [t‚ÇÇ : topological_space Œ≤] : topological_space (Œ± √ó Œ≤) :=
induced prod.fst t‚ÇÅ ‚äì induced prod.snd t‚ÇÇ

instance [t‚ÇÅ : topological_space Œ±] [t‚ÇÇ : topological_space Œ≤] : topological_space (Œ± ‚äï Œ≤) :=
coinduced sum.inl t‚ÇÅ ‚äî coinduced sum.inr t‚ÇÇ

instance {Œ≤ : Œ± ‚Üí Type v} [t‚ÇÇ : Œ†a, topological_space (Œ≤ a)] : topological_space (sigma Œ≤) :=
‚®Üa, coinduced (sigma.mk a) (t‚ÇÇ a)

instance Pi.topological_space {Œ≤ : Œ± ‚Üí Type v} [t‚ÇÇ : Œ†a, topological_space (Œ≤ a)] :
  topological_space (Œ†a, Œ≤ a) :=
‚®Öa, induced (Œªf, f a) (t‚ÇÇ a)

instance ulift.topological_space [t : topological_space Œ±] : topological_space (ulift.{v u} Œ±) :=
t.induced ulift.down

lemma quotient.preimage_mem_nhds [topological_space Œ±] [s : setoid Œ±]
  {V : set $ quotient s} {a : Œ±} (hs : V ‚àà ùìù (quotient.mk a)) : quotient.mk ‚Åª¬π' V ‚àà ùìù a :=
preimage_nhds_coinduced hs

/-- The image of a dense set under `quotient.mk` is a dense set. -/
lemma dense.quotient [setoid Œ±] [topological_space Œ±] {s : set Œ±} (H : dense s) :
  dense (quotient.mk '' s) :=
(surjective_quotient_mk Œ±).dense_range.dense_image continuous_coinduced_rng H

/-- The composition of `quotient.mk` and a function with dense range has dense range. -/
lemma dense_range.quotient [setoid Œ±] [topological_space Œ±] {f : Œ≤ ‚Üí Œ±} (hf : dense_range f) :
  dense_range (quotient.mk ‚àò f) :=
(surjective_quotient_mk Œ±).dense_range.comp hf continuous_coinduced_rng

instance {p : Œ± ‚Üí Prop} [topological_space Œ±] [discrete_topology Œ±] :
  discrete_topology (subtype p) :=
‚ü®bot_unique $ assume s hs,
  ‚ü®coe '' s, is_open_discrete _, (set.preimage_image_eq _ subtype.coe_injective)‚ü©‚ü©

instance sum.discrete_topology [topological_space Œ±] [topological_space Œ≤]
  [hŒ± : discrete_topology Œ±] [hŒ≤ : discrete_topology Œ≤] : discrete_topology (Œ± ‚äï Œ≤) :=
‚ü®by unfold sum.topological_space; simp [hŒ±.eq_bot, hŒ≤.eq_bot]‚ü©

instance sigma.discrete_topology {Œ≤ : Œ± ‚Üí Type v} [Œ†a, topological_space (Œ≤ a)]
  [h : Œ†a, discrete_topology (Œ≤ a)] : discrete_topology (sigma Œ≤) :=
‚ü®by { unfold sigma.topological_space, simp [Œª a, (h a).eq_bot] }‚ü©

section topŒ±

variable [topological_space Œ±]

/-
The ùìù filter and the subspace topology.
-/

theorem mem_nhds_subtype (s : set Œ±) (a : {x // x ‚àà s}) (t : set {x // x ‚àà s}) :
  t ‚àà ùìù a ‚Üî ‚àÉ u ‚àà ùìù (a : Œ±), coe ‚Åª¬π' u ‚äÜ t :=
mem_nhds_induced coe a t

theorem nhds_subtype (s : set Œ±) (a : {x // x ‚àà s}) :
  ùìù a = comap coe (ùìù (a : Œ±)) :=
nhds_induced coe a

end topŒ±

/-- A type synonym equiped with the topology whose open sets are the empty set and the sets with
finite complements. -/
def cofinite_topology (Œ± : Type*) := Œ±

namespace cofinite_topology

/-- The identity equivalence between `Œ±` and `cofinite_topology Œ±`. -/
def of : Œ± ‚âÉ cofinite_topology Œ± := equiv.refl Œ±
instance [inhabited Œ±] : inhabited (cofinite_topology Œ±) :=
{ default := of default }

instance : topological_space (cofinite_topology Œ±) :=
{ is_open := Œª s, s.nonempty ‚Üí set.finite s·∂ú,
  is_open_univ := by simp,
  is_open_inter := Œª s t, begin
    classical,
    rintros hs ht ‚ü®x, hxs, hxt‚ü©,
    haveI := set.finite.fintype (hs ‚ü®x, hxs‚ü©),
    haveI := set.finite.fintype (ht ‚ü®x, hxt‚ü©),
    rw compl_inter,
    exact set.finite.intro (s·∂ú.fintype_union t·∂ú),
  end,
  is_open_sUnion := begin
    rintros s h ‚ü®x, t, hts, hzt‚ü©,
    rw set.compl_sUnion,
    apply set.finite.sInter _ (h t hts ‚ü®x, hzt‚ü©),
    simp [hts]
    end }

lemma is_open_iff {s : set (cofinite_topology Œ±)} :
  is_open s ‚Üî (s.nonempty ‚Üí (s·∂ú).finite) := iff.rfl

lemma is_open_iff' {s : set (cofinite_topology Œ±)} :
  is_open s ‚Üî (s = ‚àÖ ‚à® (s·∂ú).finite) :=
by simp only [is_open_iff, ‚Üê ne_empty_iff_nonempty, or_iff_not_imp_left]

lemma is_closed_iff {s : set (cofinite_topology Œ±)} :
  is_closed s ‚Üî s = univ ‚à® s.finite :=
by simp [‚Üê is_open_compl_iff, is_open_iff']

lemma nhds_eq (a : cofinite_topology Œ±) : ùìù a = pure a ‚äî cofinite :=
begin
  ext U,
  rw mem_nhds_iff,
  split,
  { rintro ‚ü®V, hVU, V_op, haV‚ü©,
    exact mem_sup.mpr ‚ü®hVU haV, mem_of_superset (V_op ‚ü®_, haV‚ü©) hVU‚ü© },
  { rintros ‚ü®hU : a ‚àà U, hU' : (U·∂ú).finite‚ü©,
    exact ‚ü®U, subset.rfl, Œª h, hU', hU‚ü© }
end

lemma mem_nhds_iff {a : cofinite_topology Œ±} {s : set (cofinite_topology Œ±)} :
  s ‚àà ùìù a ‚Üî a ‚àà s ‚àß s·∂ú.finite :=
by simp [nhds_eq]

end cofinite_topology

end constructions

section prod
variables [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥]

@[continuity] lemma continuous_fst : continuous (@prod.fst Œ± Œ≤) :=
continuous_inf_dom_left continuous_induced_dom

lemma continuous_at_fst {p : Œ± √ó Œ≤} : continuous_at prod.fst p :=
continuous_fst.continuous_at

lemma continuous.fst {f : Œ± ‚Üí Œ≤ √ó Œ≥} (hf : continuous f) : continuous (Œª a : Œ±, (f a).1) :=
continuous_fst.comp hf

lemma continuous_at.fst {f : Œ± ‚Üí Œ≤ √ó Œ≥} {x : Œ±} (hf : continuous_at f x) :
  continuous_at (Œª a : Œ±, (f a).1) x :=
continuous_at_fst.comp hf

@[continuity] lemma continuous_snd : continuous (@prod.snd Œ± Œ≤) :=
continuous_inf_dom_right continuous_induced_dom

lemma continuous_at_snd {p : Œ± √ó Œ≤} : continuous_at prod.snd p :=
continuous_snd.continuous_at

lemma continuous.snd {f : Œ± ‚Üí Œ≤ √ó Œ≥} (hf : continuous f) : continuous (Œª a : Œ±, (f a).2) :=
continuous_snd.comp hf

lemma continuous_at.snd {f : Œ± ‚Üí Œ≤ √ó Œ≥} {x : Œ±} (hf : continuous_at f x) :
  continuous_at (Œª a : Œ±, (f a).2) x :=
continuous_at_snd.comp hf

@[continuity] lemma continuous.prod_mk {f : Œ≥ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ≤}
  (hf : continuous f) (hg : continuous g) : continuous (Œªx, (f x, g x)) :=
continuous_inf_rng (continuous_induced_rng hf) (continuous_induced_rng hg)

@[continuity] lemma continuous.prod.mk (a : Œ±) : continuous (prod.mk a : Œ≤ ‚Üí Œ± √ó Œ≤) :=
continuous_const.prod_mk continuous_id'

lemma continuous.prod_map {f : Œ≥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤} (hf : continuous f) (hg : continuous g) :
  continuous (Œª x : Œ≥ √ó Œ¥, (f x.1, g x.2)) :=
(hf.comp continuous_fst).prod_mk (hg.comp continuous_snd)

/-- A version of `continuous_inf_dom_left` for binary functions -/
lemma continuous_inf_dom_left‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥}
  {ta1 ta2 : topological_space Œ±} {tb1 tb2 : topological_space Œ≤} {tc1 : topological_space Œ≥}
  (h : by haveI := ta1; haveI := tb1; exact continuous (Œª p : Œ± √ó Œ≤, f p.1 p.2)) :
  by haveI := ta1 ‚äì ta2; haveI := tb1 ‚äì tb2; exact continuous (Œª p : Œ± √ó Œ≤, f p.1 p.2) :=
begin
  have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _)),
  have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _)),
  have h_continuous_id := @continuous.prod_map _ _ _ _ ta1 tb1 (ta1 ‚äì ta2) (tb1 ‚äì tb2) _ _ ha hb,
  exact @continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id,
end

/-- A version of `continuous_inf_dom_right` for binary functions -/
lemma continuous_inf_dom_right‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥}
  {ta1 ta2 : topological_space Œ±} {tb1 tb2 : topological_space Œ≤} {tc1 : topological_space Œ≥}
  (h : by haveI := ta2; haveI := tb2; exact continuous (Œª p : Œ± √ó Œ≤, f p.1 p.2)) :
  by haveI := ta1 ‚äì ta2; haveI := tb1 ‚äì tb2; exact continuous (Œª p : Œ± √ó Œ≤, f p.1 p.2) :=
begin
  have ha := @continuous_inf_dom_right _ _ id ta1 ta2 ta2 (@continuous_id _ (id _)),
  have hb := @continuous_inf_dom_right _ _ id tb1 tb2 tb2 (@continuous_id _ (id _)),
  have h_continuous_id := @continuous.prod_map _ _ _ _ ta2 tb2 (ta1 ‚äì ta2) (tb1 ‚äì tb2) _ _ ha hb,
  exact @continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id,
end

/-- A version of `continuous_Inf_dom` for binary functions -/
lemma continuous_Inf_dom‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥}
  {tas : set (topological_space Œ±)} {tbs : set (topological_space Œ≤)}
  {ta : topological_space Œ±} {tb : topological_space Œ≤} {tc : topological_space Œ≥}
  (ha : ta ‚àà tas) (hb : tb ‚àà tbs)
  (hf : continuous (Œª p : Œ± √ó Œ≤, f p.1 p.2)):
  by haveI := Inf tas; haveI := Inf tbs; exact @continuous _ _ _ tc (Œª p : Œ± √ó Œ≤, f p.1 p.2) :=
begin
  let t : topological_space (Œ± √ó Œ≤) := prod.topological_space,
  have ha := continuous_Inf_dom ha continuous_id,
  have hb := continuous_Inf_dom hb continuous_id,
  have h_continuous_id := @continuous.prod_map _ _ _ _ ta tb (Inf tas) (Inf tbs) _ _ ha hb,
  exact @continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id,
end

lemma filter.eventually.prod_inl_nhds {p : Œ± ‚Üí Prop} {a : Œ±}  (h : ‚àÄ·∂† x in ùìù a, p x) (b : Œ≤) :
  ‚àÄ·∂† x in ùìù (a, b), p (x : Œ± √ó Œ≤).1 :=
continuous_at_fst h

lemma filter.eventually.prod_inr_nhds {p : Œ≤ ‚Üí Prop} {b : Œ≤} (h : ‚àÄ·∂† x in ùìù b, p x) (a : Œ±) :
  ‚àÄ·∂† x in ùìù (a, b), p (x : Œ± √ó Œ≤).2 :=
continuous_at_snd h

lemma filter.eventually.prod_mk_nhds {pa : Œ± ‚Üí Prop} {a} (ha : ‚àÄ·∂† x in ùìù a, pa x)
  {pb : Œ≤ ‚Üí Prop} {b} (hb : ‚àÄ·∂† y in ùìù b, pb y) :
  ‚àÄ·∂† p in ùìù (a, b), pa (p : Œ± √ó Œ≤).1 ‚àß pb p.2 :=
(ha.prod_inl_nhds b).and (hb.prod_inr_nhds a)

lemma continuous_swap : continuous (prod.swap : Œ± √ó Œ≤ ‚Üí Œ≤ √ó Œ±) :=
continuous_snd.prod_mk continuous_fst

lemma continuous_uncurry_left {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (a : Œ±)
  (h : continuous (function.uncurry f)) : continuous (f a) :=
show continuous (function.uncurry f ‚àò (Œª b, (a, b))), from h.comp (by continuity)

lemma continuous_uncurry_right {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (b : Œ≤)
  (h : continuous (function.uncurry f)) : continuous (Œª a, f a b) :=
show continuous (function.uncurry f ‚àò (Œª a, (a, b))), from h.comp (by continuity)

lemma continuous_curry {g : Œ± √ó Œ≤ ‚Üí Œ≥} (a : Œ±)
  (h : continuous g) : continuous (function.curry g a) :=
show continuous (g ‚àò (Œª b, (a, b))), from h.comp (by continuity)

lemma is_open.prod {s : set Œ±} {t : set Œ≤} (hs : is_open s) (ht : is_open t) :
  is_open (s √óÀ¢ t) :=
is_open.inter (hs.preimage continuous_fst) (ht.preimage continuous_snd)

lemma nhds_prod_eq {a : Œ±} {b : Œ≤} : ùìù (a, b) = ùìù a √ó·∂† ùìù b :=
by rw [filter.prod, prod.topological_space, nhds_inf, nhds_induced, nhds_induced]

lemma mem_nhds_prod_iff {a : Œ±} {b : Œ≤} {s : set (Œ± √ó Œ≤)} :
  s ‚àà ùìù (a, b) ‚Üî ‚àÉ (u ‚àà ùìù a) (v ‚àà ùìù b), u √óÀ¢ v ‚äÜ s :=
by rw [nhds_prod_eq, mem_prod_iff]

lemma mem_nhds_prod_iff' {a : Œ±} {b : Œ≤} {s : set (Œ± √ó Œ≤)} :
  s ‚àà ùìù (a, b) ‚Üî ‚àÉ (u : set Œ±) (v : set Œ≤), is_open u ‚àß a ‚àà u ‚àß is_open v ‚àß b ‚àà v ‚àß u √óÀ¢ v ‚äÜ s :=
begin
  rw mem_nhds_prod_iff,
  split,
  { rintros ‚ü®u, Hu, v, Hv, h‚ü©,
    rcases mem_nhds_iff.1 Hu with ‚ü®u', u'u, u'_open, Hu'‚ü©,
    rcases mem_nhds_iff.1 Hv with ‚ü®v', v'v, v'_open, Hv'‚ü©,
    exact ‚ü®u', v', u'_open, Hu', v'_open, Hv', (set.prod_mono u'u v'v).trans h‚ü© },
  { rintros ‚ü®u, v, u_open, au, v_open, bv, huv‚ü©,
    exact ‚ü®u, u_open.mem_nhds au, v, v_open.mem_nhds bv, huv‚ü© }
end

lemma filter.has_basis.prod_nhds {Œπa Œπb : Type*} {pa : Œπa ‚Üí Prop} {pb : Œπb ‚Üí Prop}
  {sa : Œπa ‚Üí set Œ±} {sb : Œπb ‚Üí set Œ≤} {a : Œ±} {b : Œ≤} (ha : (ùìù a).has_basis pa sa)
  (hb : (ùìù b).has_basis pb sb) :
  (ùìù (a, b)).has_basis (Œª i : Œπa √ó Œπb, pa i.1 ‚àß pb i.2) (Œª i, sa i.1 √óÀ¢ sb i.2) :=
by { rw nhds_prod_eq, exact ha.prod hb }

lemma filter.has_basis.prod_nhds' {Œπa Œπb : Type*} {pa : Œπa ‚Üí Prop} {pb : Œπb ‚Üí Prop}
  {sa : Œπa ‚Üí set Œ±} {sb : Œπb ‚Üí set Œ≤} {ab : Œ± √ó Œ≤} (ha : (ùìù ab.1).has_basis pa sa)
  (hb : (ùìù ab.2).has_basis pb sb) :
  (ùìù ab).has_basis (Œª i : Œπa √ó Œπb, pa i.1 ‚àß pb i.2) (Œª i, sa i.1 √óÀ¢ sb i.2) :=
by { cases ab, exact ha.prod_nhds hb }

instance [discrete_topology Œ±] [discrete_topology Œ≤] : discrete_topology (Œ± √ó Œ≤) :=
‚ü®eq_of_nhds_eq_nhds $ assume ‚ü®a, b‚ü©,
  by rw [nhds_prod_eq, nhds_discrete Œ±, nhds_discrete Œ≤, nhds_bot, filter.prod_pure_pure]‚ü©

lemma prod_mem_nhds_iff {s : set Œ±} {t : set Œ≤} {a : Œ±} {b : Œ≤} :
  s √óÀ¢ t ‚àà ùìù (a, b) ‚Üî s ‚àà ùìù a ‚àß t ‚àà ùìù b :=
by rw [nhds_prod_eq, prod_mem_prod_iff]

lemma prod_is_open.mem_nhds {s : set Œ±} {t : set Œ≤} {a : Œ±} {b : Œ≤}
  (ha : s ‚àà ùìù a) (hb : t ‚àà ùìù b) : s √óÀ¢ t ‚àà ùìù (a, b) :=
prod_mem_nhds_iff.2 ‚ü®ha, hb‚ü©

lemma nhds_swap (a : Œ±) (b : Œ≤) : ùìù (a, b) = (ùìù (b, a)).map prod.swap :=
by rw [nhds_prod_eq, filter.prod_comm, nhds_prod_eq]; refl

lemma filter.tendsto.prod_mk_nhds {Œ≥} {a : Œ±} {b : Œ≤} {f : filter Œ≥} {ma : Œ≥ ‚Üí Œ±} {mb : Œ≥ ‚Üí Œ≤}
  (ha : tendsto ma f (ùìù a)) (hb : tendsto mb f (ùìù b)) :
  tendsto (Œªc, (ma c, mb c)) f (ùìù (a, b)) :=
by rw [nhds_prod_eq]; exact filter.tendsto.prod_mk ha hb

lemma filter.eventually.curry_nhds {p : Œ± √ó Œ≤ ‚Üí Prop} {x : Œ±} {y : Œ≤} (h : ‚àÄ·∂† x in ùìù (x, y), p x) :
  ‚àÄ·∂† x' in ùìù x, ‚àÄ·∂† y' in ùìù y, p (x', y') :=
by { rw [nhds_prod_eq] at h, exact h.curry }

lemma continuous_at.prod {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≥} {x : Œ±}
  (hf : continuous_at f x) (hg : continuous_at g x) : continuous_at (Œªx, (f x, g x)) x :=
hf.prod_mk_nhds hg

lemma continuous_at.prod_map {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {p : Œ± √ó Œ≤}
  (hf : continuous_at f p.fst) (hg : continuous_at g p.snd) :
  continuous_at (Œª p : Œ± √ó Œ≤, (f p.1, g p.2)) p :=
(hf.comp continuous_at_fst).prod (hg.comp continuous_at_snd)

lemma continuous_at.prod_map' {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {x : Œ±} {y : Œ≤}
  (hf : continuous_at f x) (hg : continuous_at g y) :
  continuous_at (Œª p : Œ± √ó Œ≤, (f p.1, g p.2)) (x, y) :=
have hf : continuous_at f (x, y).fst, from hf,
have hg : continuous_at g (x, y).snd, from hg,
hf.prod_map hg

lemma prod_generate_from_generate_from_eq {Œ± Œ≤ : Type*} {s : set (set Œ±)} {t : set (set Œ≤)}
  (hs : ‚ãÉ‚ÇÄ s = univ) (ht : ‚ãÉ‚ÇÄ t = univ) :
  @prod.topological_space Œ± Œ≤ (generate_from s) (generate_from t) =
  generate_from {g | ‚àÉu‚ààs, ‚àÉv‚ààt, g = u √óÀ¢ v} :=
let G := generate_from {g | ‚àÉu‚ààs, ‚àÉv‚ààt, g = u √óÀ¢ v} in
le_antisymm
  (le_generate_from $ assume g ‚ü®u, hu, v, hv, g_eq‚ü©, g_eq.symm ‚ñ∏
    @is_open.prod _ _ (generate_from s) (generate_from t) _ _
      (generate_open.basic _ hu) (generate_open.basic _ hv))
  (le_inf
    (coinduced_le_iff_le_induced.mp $ le_generate_from $ assume u hu,
      have (‚ãÉv‚ààt, u √óÀ¢ v) = prod.fst ‚Åª¬π' u,
        from calc (‚ãÉv‚ààt, u √óÀ¢ v) = u √óÀ¢ (univ : set Œ≤) :
            set.ext $ assume ‚ü®a, b‚ü©, by rw ‚Üê ht; simp [and.left_comm] {contextual:=tt}
          ... = prod.fst ‚Åª¬π' u : set.prod_univ,
      show G.is_open (prod.fst ‚Åª¬π' u),
        from this ‚ñ∏ @is_open_Union _ _ G _ $ assume v, @is_open_Union _ _ G _ $ assume hv,
          generate_open.basic _ ‚ü®_, hu, _, hv, rfl‚ü©)
    (coinduced_le_iff_le_induced.mp $ le_generate_from $ assume v hv,
      have (‚ãÉu‚ààs, u √óÀ¢ v) = prod.snd ‚Åª¬π' v,
        from calc (‚ãÉu‚ààs, u √óÀ¢ v) = (univ : set Œ±) √óÀ¢ v:
            set.ext $ assume ‚ü®a, b‚ü©, by rw [‚Üêhs]; by_cases b ‚àà v; simp [h] {contextual:=tt}
          ... = prod.snd ‚Åª¬π' v : set.univ_prod,
      show G.is_open (prod.snd ‚Åª¬π' v),
        from this ‚ñ∏ @is_open_Union _ _ G _ $ assume u, @is_open_Union _ _ G _ $ assume hu,
          generate_open.basic _ ‚ü®_, hu, _, hv, rfl‚ü©))

lemma prod_eq_generate_from :
  prod.topological_space =
  generate_from {g | ‚àÉ(s:set Œ±) (t:set Œ≤), is_open s ‚àß is_open t ‚àß g = s √óÀ¢ t} :=
le_antisymm
  (le_generate_from $ assume g ‚ü®s, t, hs, ht, g_eq‚ü©, g_eq.symm ‚ñ∏ hs.prod ht)
  (le_inf
    (ball_image_of_ball $ Œªt ht, generate_open.basic _ ‚ü®t, univ, by simpa [set.prod_eq] using ht‚ü©)
    (ball_image_of_ball $ Œªt ht, generate_open.basic _ ‚ü®univ, t, by simpa [set.prod_eq] using ht‚ü©))

lemma is_open_prod_iff {s : set (Œ± √ó Œ≤)} : is_open s ‚Üî
  (‚àÄa b, (a, b) ‚àà s ‚Üí
    ‚àÉ (u : set Œ±) (v : set Œ≤), is_open u ‚àß is_open v ‚àß a ‚àà u ‚àß b ‚àà v ‚àß u √óÀ¢ v ‚äÜ s) :=
begin
  rw [is_open_iff_nhds],
  simp_rw [le_principal_iff, prod.forall,
    ((nhds_basis_opens _).prod_nhds (nhds_basis_opens _)).mem_iff, prod.exists, exists_prop],
  simp only [and_assoc, and.left_comm]
end

/-- A product of induced topologies is induced by the product map -/
lemma prod_induced_induced {Œ± Œ≥ : Type*} (f : Œ± ‚Üí Œ≤) (g : Œ≥ ‚Üí Œ¥) :
  @prod.topological_space Œ± Œ≥ (induced f ‚Äπ_‚Ä∫) (induced g ‚Äπ_‚Ä∫) =
  induced (Œª p, (f p.1, g p.2)) prod.topological_space :=
begin
  set fxg := (Œª p : Œ± √ó Œ≥, (f p.1, g p.2)),
  have key1 : f ‚àò (prod.fst : Œ± √ó Œ≥ ‚Üí Œ±) = (prod.fst : Œ≤ √ó Œ¥ ‚Üí Œ≤) ‚àò fxg, from rfl,
  have key2 : g ‚àò (prod.snd : Œ± √ó Œ≥ ‚Üí Œ≥) = (prod.snd : Œ≤ √ó Œ¥ ‚Üí Œ¥) ‚àò fxg, from rfl,
  unfold prod.topological_space,
  conv_lhs
  { rw [induced_compose, induced_compose, key1, key2],
    congr, rw ‚Üê induced_compose, skip, rw ‚Üê induced_compose, },
  rw induced_inf
end

lemma continuous_uncurry_of_discrete_topology_left [discrete_topology Œ±]
  {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : ‚àÄ a, continuous (f a)) : continuous (function.uncurry f) :=
continuous_iff_continuous_at.2 $ Œª ‚ü®a, b‚ü©,
  by simp only [continuous_at, nhds_prod_eq, nhds_discrete Œ±, pure_prod, tendsto_map'_iff, (‚àò),
    function.uncurry, (h a).tendsto]

/-- Given a neighborhood `s` of `(x, x)`, then `(x, x)` has a square open neighborhood
  that is a subset of `s`. -/
lemma exists_nhds_square {s : set (Œ± √ó Œ±)} {x : Œ±} (hx : s ‚àà ùìù (x, x)) :
  ‚àÉ U : set Œ±, is_open U ‚àß x ‚àà U ‚àß U √óÀ¢ U ‚äÜ s :=
by simpa [nhds_prod_eq, (nhds_basis_opens x).prod_self.mem_iff, and.assoc, and.left_comm] using hx

/-- `prod.fst` maps neighborhood of `x : Œ± √ó Œ≤` within the section `prod.snd ‚Åª¬π' {x.2}`
to `ùìù x.1`. -/
lemma map_fst_nhds_within (x : Œ± √ó Œ≤) : map prod.fst (ùìù[prod.snd ‚Åª¬π' {x.2}] x) = ùìù x.1 :=
begin
  refine le_antisymm (continuous_at_fst.mono_left inf_le_left) (Œª s hs, _),
  rcases x with ‚ü®x, y‚ü©,
  rw [mem_map, nhds_within, mem_inf_principal, mem_nhds_prod_iff] at hs,
  rcases hs with ‚ü®u, hu, v, hv, H‚ü©,
  simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H,
  exact mem_of_superset hu (Œª z hz, H _ hz _ (mem_of_mem_nhds hv) rfl)
end

@[simp] lemma map_fst_nhds (x : Œ± √ó Œ≤) : map prod.fst (ùìù x) = ùìù x.1 :=
le_antisymm continuous_at_fst $ (map_fst_nhds_within x).symm.trans_le (map_mono inf_le_left)

/-- The first projection in a product of topological spaces sends open sets to open sets. -/
lemma is_open_map_fst : is_open_map (@prod.fst Œ± Œ≤) :=
is_open_map_iff_nhds_le.2 $ Œª x, (map_fst_nhds x).ge

/-- `prod.snd` maps neighborhood of `x : Œ± √ó Œ≤` within the section `prod.fst ‚Åª¬π' {x.1}`
to `ùìù x.2`. -/
lemma map_snd_nhds_within (x : Œ± √ó Œ≤) : map prod.snd (ùìù[prod.fst ‚Åª¬π' {x.1}] x) = ùìù x.2 :=
begin
  refine le_antisymm (continuous_at_snd.mono_left inf_le_left) (Œª s hs, _),
  rcases x with ‚ü®x, y‚ü©,
  rw [mem_map, nhds_within, mem_inf_principal, mem_nhds_prod_iff] at hs,
  rcases hs with ‚ü®u, hu, v, hv, H‚ü©,
  simp only [prod_subset_iff, mem_singleton_iff, mem_set_of_eq, mem_preimage] at H,
  exact mem_of_superset hv (Œª z hz, H _ (mem_of_mem_nhds hu) _ hz rfl)
end

@[simp] lemma map_snd_nhds (x : Œ± √ó Œ≤) : map prod.snd (ùìù x) = ùìù x.2 :=
le_antisymm continuous_at_snd $ (map_snd_nhds_within x).symm.trans_le (map_mono inf_le_left)

/-- The second projection in a product of topological spaces sends open sets to open sets. -/
lemma is_open_map_snd : is_open_map (@prod.snd Œ± Œ≤) :=
is_open_map_iff_nhds_le.2 $ Œª x, (map_snd_nhds x).ge

/-- A product set is open in a product space if and only if each factor is open, or one of them is
empty -/
lemma is_open_prod_iff' {s : set Œ±} {t : set Œ≤} :
  is_open (s √óÀ¢ t) ‚Üî (is_open s ‚àß is_open t) ‚à® (s = ‚àÖ) ‚à® (t = ‚àÖ) :=
begin
  cases (s √óÀ¢ t : set _).eq_empty_or_nonempty with h h,
  { simp [h, prod_eq_empty_iff.1 h] },
  { have st : s.nonempty ‚àß t.nonempty, from prod_nonempty_iff.1 h,
    split,
    { assume H : is_open (s √óÀ¢ t),
      refine or.inl ‚ü®_, _‚ü©,
      show is_open s,
      { rw ‚Üê fst_image_prod s st.2,
        exact is_open_map_fst _ H },
      show is_open t,
      { rw ‚Üê snd_image_prod st.1 t,
        exact is_open_map_snd _ H } },
    { assume H,
      simp only [st.1.ne_empty, st.2.ne_empty, not_false_iff, or_false] at H,
      exact H.1.prod H.2 } }
end

lemma closure_prod_eq {s : set Œ±} {t : set Œ≤} :
  closure (s √óÀ¢ t) = closure s √óÀ¢ closure t :=
set.ext $ assume ‚ü®a, b‚ü©,
have (ùìù a √ó·∂† ùìù b) ‚äì ùìü (s √óÀ¢ t) = (ùìù a ‚äì ùìü s) √ó·∂† (ùìù b ‚äì ùìü t),
  by rw [‚Üêprod_inf_prod, prod_principal_principal],
by simp [closure_eq_cluster_pts, cluster_pt, nhds_prod_eq, this]; exact prod_ne_bot

lemma interior_prod_eq (s : set Œ±) (t : set Œ≤) :
  interior (s √óÀ¢ t) = interior s √óÀ¢ interior t :=
set.ext $ Œª ‚ü®a, b‚ü©, by simp only [mem_interior_iff_mem_nhds, mem_prod, prod_mem_nhds_iff]

lemma frontier_prod_eq (s : set Œ±) (t : set Œ≤) :
  frontier (s √óÀ¢ t) = closure s √óÀ¢ frontier t ‚à™ frontier s √óÀ¢ closure t :=
by simp only [frontier, closure_prod_eq, interior_prod_eq, prod_diff_prod]

@[simp] lemma frontier_prod_univ_eq (s : set Œ±) :
  frontier (s √óÀ¢ (univ : set Œ≤)) = frontier s √óÀ¢ (univ : set Œ≤) :=
by simp [frontier_prod_eq]

@[simp] lemma frontier_univ_prod_eq (s : set Œ≤) :
  frontier ((univ : set Œ±) √óÀ¢ s) = (univ : set Œ±) √óÀ¢ (frontier s) :=
by simp [frontier_prod_eq]

lemma map_mem_closure2 {s : set Œ±} {t : set Œ≤} {u : set Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {a : Œ±} {b : Œ≤}
  (hf : continuous (Œªp:Œ±√óŒ≤, f p.1 p.2)) (ha : a ‚àà closure s) (hb : b ‚àà closure t)
  (hu : ‚àÄa b, a ‚àà s ‚Üí b ‚àà t ‚Üí f a b ‚àà u) :
  f a b ‚àà closure u :=
have (a, b) ‚àà closure (s √óÀ¢ t), by rw [closure_prod_eq]; from ‚ü®ha, hb‚ü©,
show (Œªp:Œ±√óŒ≤, f p.1 p.2) (a, b) ‚àà closure u, from
  map_mem_closure hf this $ assume ‚ü®a, b‚ü© ‚ü®ha, hb‚ü©, hu a b ha hb

lemma is_closed.prod {s‚ÇÅ : set Œ±} {s‚ÇÇ : set Œ≤} (h‚ÇÅ : is_closed s‚ÇÅ) (h‚ÇÇ : is_closed s‚ÇÇ) :
  is_closed (s‚ÇÅ √óÀ¢ s‚ÇÇ) :=
closure_eq_iff_is_closed.mp $ by simp only [h‚ÇÅ.closure_eq, h‚ÇÇ.closure_eq, closure_prod_eq]

/-- The product of two dense sets is a dense set. -/
lemma dense.prod {s : set Œ±} {t : set Œ≤} (hs : dense s) (ht : dense t) :
  dense (s √óÀ¢ t) :=
Œª x, by { rw closure_prod_eq, exact ‚ü®hs x.1, ht x.2‚ü© }

/-- If `f` and `g` are maps with dense range, then `prod.map f g` has dense range. -/
lemma dense_range.prod_map {Œπ : Type*} {Œ∫ : Type*} {f : Œπ ‚Üí Œ≤} {g : Œ∫ ‚Üí Œ≥}
  (hf : dense_range f) (hg : dense_range g) : dense_range (prod.map f g) :=
by simpa only [dense_range, prod_range_range_eq] using hf.prod hg

lemma inducing.prod_mk {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : inducing f) (hg : inducing g) :
  inducing (Œªx:Œ±√óŒ≥, (f x.1, g x.2)) :=
‚ü®by rw [prod.topological_space, prod.topological_space, hf.induced, hg.induced,
         induced_compose, induced_compose, induced_inf, induced_compose, induced_compose]‚ü©

lemma embedding.prod_mk {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : embedding f) (hg : embedding g) :
  embedding (Œªx:Œ±√óŒ≥, (f x.1, g x.2)) :=
{ inj := assume ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© ‚ü®y‚ÇÅ, y‚ÇÇ‚ü©, by simp; exact assume h‚ÇÅ h‚ÇÇ, ‚ü®hf.inj h‚ÇÅ, hg.inj h‚ÇÇ‚ü©,
  ..hf.to_inducing.prod_mk hg.to_inducing }

protected lemma is_open_map.prod {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : is_open_map f) (hg : is_open_map g) :
  is_open_map (Œª p : Œ± √ó Œ≥, (f p.1, g p.2)) :=
begin
  rw [is_open_map_iff_nhds_le],
  rintros ‚ü®a, b‚ü©,
  rw [nhds_prod_eq, nhds_prod_eq, ‚Üê filter.prod_map_map_eq],
  exact filter.prod_mono (is_open_map_iff_nhds_le.1 hf a) (is_open_map_iff_nhds_le.1 hg b)
end

protected lemma open_embedding.prod {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥}
  (hf : open_embedding f) (hg : open_embedding g) : open_embedding (Œªx:Œ±√óŒ≥, (f x.1, g x.2)) :=
open_embedding_of_embedding_open (hf.1.prod_mk hg.1)
  (hf.is_open_map.prod hg.is_open_map)

lemma embedding_graph {f : Œ± ‚Üí Œ≤} (hf : continuous f) : embedding (Œªx, (x, f x)) :=
embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id

end prod

section sum
open sum
variables [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥]

@[continuity] lemma continuous_inl : continuous (@inl Œ± Œ≤) :=
continuous_sup_rng_left continuous_coinduced_rng

@[continuity] lemma continuous_inr : continuous (@inr Œ± Œ≤) :=
continuous_sup_rng_right continuous_coinduced_rng

@[continuity] lemma continuous_sum_rec {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥}
  (hf : continuous f) (hg : continuous g) : @continuous (Œ± ‚äï Œ≤) Œ≥ _ _ (@sum.rec Œ± Œ≤ (Œª_, Œ≥) f g) :=
begin
  apply continuous_sup_dom;
  rw continuous_def at hf hg ‚ä¢;
  assumption
end

lemma is_open_sum_iff {s : set (Œ± ‚äï Œ≤)} :
  is_open s ‚Üî is_open (inl ‚Åª¬π' s) ‚àß is_open (inr ‚Åª¬π' s) :=
iff.rfl

lemma is_open_map_sum {f : Œ± ‚äï Œ≤ ‚Üí Œ≥}
  (h‚ÇÅ : is_open_map (Œª a, f (inl a))) (h‚ÇÇ : is_open_map (Œª b, f (inr b))) :
  is_open_map f :=
begin
  intros u hu,
  rw is_open_sum_iff at hu,
  cases hu with hu‚ÇÅ hu‚ÇÇ,
  have : u = inl '' (inl ‚Åª¬π' u) ‚à™ inr '' (inr ‚Åª¬π' u),
  { ext (_|_); simp },
  rw [this, set.image_union, set.image_image, set.image_image],
  exact is_open.union (h‚ÇÅ _ hu‚ÇÅ) (h‚ÇÇ _ hu‚ÇÇ)
end

lemma embedding_inl : embedding (@inl Œ± Œ≤) :=
{ induced := begin
    unfold sum.topological_space,
    apply le_antisymm,
    { rw ‚Üê coinduced_le_iff_le_induced, exact le_sup_left },
    { intros u hu, existsi (inl '' u),
      change
        (is_open (inl ‚Åª¬π' (@inl Œ± Œ≤ '' u)) ‚àß
         is_open (inr ‚Åª¬π' (@inl Œ± Œ≤ '' u))) ‚àß
        inl ‚Åª¬π' (inl '' u) = u,
      have : inl ‚Åª¬π' (@inl Œ± Œ≤ '' u) = u :=
        preimage_image_eq u (Œª _ _, inl.inj_iff.mp), rw this,
      have : inr ‚Åª¬π' (@inl Œ± Œ≤ '' u) = ‚àÖ :=
        eq_empty_iff_forall_not_mem.mpr (assume a ‚ü®b, _, h‚ü©, inl_ne_inr h), rw this,
      exact ‚ü®‚ü®hu, is_open_empty‚ü©, rfl‚ü© }
  end,
  inj := Œª _ _, inl.inj_iff.mp }

lemma embedding_inr : embedding (@inr Œ± Œ≤) :=
{ induced := begin
    unfold sum.topological_space,
    apply le_antisymm,
    { rw ‚Üê coinduced_le_iff_le_induced, exact le_sup_right },
    { intros u hu, existsi (inr '' u),
      change
        (is_open (inl ‚Åª¬π' (@inr Œ± Œ≤ '' u)) ‚àß
         is_open (inr ‚Åª¬π' (@inr Œ± Œ≤ '' u))) ‚àß
        inr ‚Åª¬π' (inr '' u) = u,
      have : inl ‚Åª¬π' (@inr Œ± Œ≤ '' u) = ‚àÖ :=
        eq_empty_iff_forall_not_mem.mpr (assume b ‚ü®a, _, h‚ü©, inr_ne_inl h), rw this,
      have : inr ‚Åª¬π' (@inr Œ± Œ≤ '' u) = u :=
        preimage_image_eq u (Œª _ _, inr.inj_iff.mp), rw this,
      exact ‚ü®‚ü®is_open_empty, hu‚ü©, rfl‚ü© }
  end,
  inj := Œª _ _, inr.inj_iff.mp }

lemma is_open_range_inl : is_open (range (inl : Œ± ‚Üí Œ± ‚äï Œ≤)) :=
is_open_sum_iff.2 $ by simp

lemma is_open_range_inr : is_open (range (inr : Œ≤ ‚Üí Œ± ‚äï Œ≤)) :=
is_open_sum_iff.2 $ by simp

lemma open_embedding_inl : open_embedding (inl : Œ± ‚Üí Œ± ‚äï Œ≤) :=
{ open_range := is_open_range_inl,
  .. embedding_inl }

lemma open_embedding_inr : open_embedding (inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=
{ open_range := is_open_range_inr,
  .. embedding_inr }

end sum

section subtype
variables [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {p : Œ± ‚Üí Prop}

lemma embedding_subtype_coe : embedding (coe : subtype p ‚Üí Œ±) :=
‚ü®‚ü®rfl‚ü©, subtype.coe_injective‚ü©

lemma closed_embedding_subtype_coe (h : is_closed {a | p a}) :
  closed_embedding (coe : subtype p ‚Üí Œ±) :=
‚ü®embedding_subtype_coe, by rwa [subtype.range_coe_subtype]‚ü©

@[continuity] lemma continuous_subtype_val : continuous (@subtype.val Œ± p) :=
continuous_induced_dom

lemma continuous_subtype_coe : continuous (coe : subtype p ‚Üí Œ±) :=
continuous_subtype_val

lemma continuous.subtype_coe {f : Œ≤ ‚Üí subtype p} (hf : continuous f) :
  continuous (Œª x, (f x : Œ±)) :=
continuous_subtype_coe.comp hf

lemma is_open.open_embedding_subtype_coe {s : set Œ±} (hs : is_open s) :
  open_embedding (coe : s ‚Üí Œ±) :=
{ induced := rfl,
  inj := subtype.coe_injective,
  open_range := (subtype.range_coe : range coe = s).symm ‚ñ∏  hs }

lemma is_open.is_open_map_subtype_coe {s : set Œ±} (hs : is_open s) :
  is_open_map (coe : s ‚Üí Œ±) :=
hs.open_embedding_subtype_coe.is_open_map

lemma is_open_map.restrict {f : Œ± ‚Üí Œ≤} (hf : is_open_map f) {s : set Œ±} (hs : is_open s) :
  is_open_map (s.restrict f) :=
hf.comp hs.is_open_map_subtype_coe

lemma is_closed.closed_embedding_subtype_coe {s : set Œ±} (hs : is_closed s) :
  closed_embedding (coe : {x // x ‚àà s} ‚Üí Œ±) :=
{ induced := rfl,
  inj := subtype.coe_injective,
  closed_range := (subtype.range_coe : range coe = s).symm ‚ñ∏ hs }

@[continuity] lemma continuous_subtype_mk {f : Œ≤ ‚Üí Œ±}
  (hp : ‚àÄx, p (f x)) (h : continuous f) : continuous (Œªx, (‚ü®f x, hp x‚ü© : subtype p)) :=
continuous_induced_rng h

lemma continuous_inclusion {s t : set Œ±} (h : s ‚äÜ t) : continuous (inclusion h) :=
continuous_subtype_mk _ continuous_subtype_coe

lemma continuous_at_subtype_coe {p : Œ± ‚Üí Prop} {a : subtype p} :
  continuous_at (coe : subtype p ‚Üí Œ±) a :=
continuous_iff_continuous_at.mp continuous_subtype_coe _

lemma map_nhds_subtype_coe_eq {a : Œ±} (ha : p a) (h : {a | p a} ‚àà ùìù a) :
  map (coe : subtype p ‚Üí Œ±) (ùìù ‚ü®a, ha‚ü©) = ùìù a :=
map_nhds_induced_of_mem $ by simpa only [subtype.coe_mk, subtype.range_coe] using h

lemma nhds_subtype_eq_comap {a : Œ±} {h : p a} :
  ùìù (‚ü®a, h‚ü© : subtype p) = comap coe (ùìù a) :=
nhds_induced _ _

lemma tendsto_subtype_rng {Œ≤ : Type*} {p : Œ± ‚Üí Prop} {b : filter Œ≤} {f : Œ≤ ‚Üí subtype p} :
  ‚àÄ{a:subtype p}, tendsto f b (ùìù a) ‚Üî tendsto (Œªx, (f x : Œ±)) b (ùìù (a : Œ±))
| ‚ü®a, ha‚ü© := by rw [nhds_subtype_eq_comap, tendsto_comap_iff, subtype.coe_mk]

lemma continuous_subtype_nhds_cover {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {c : Œπ ‚Üí Œ± ‚Üí Prop}
  (c_cover : ‚àÄx:Œ±, ‚àÉi, {x | c i x} ‚àà ùìù x)
  (f_cont  : ‚àÄi, continuous (Œª(x : subtype (c i)), f x)) :
  continuous f :=
continuous_iff_continuous_at.mpr $ assume x,
  let ‚ü®i, (c_sets : {x | c i x} ‚àà ùìù x)‚ü© := c_cover x in
  let x' : subtype (c i) := ‚ü®x, mem_of_mem_nhds c_sets‚ü© in
  calc map f (ùìù x) = map f (map coe (ùìù x')) :
      congr_arg (map f) (map_nhds_subtype_coe_eq _ $ c_sets).symm
    ... = map (Œªx:subtype (c i), f x) (ùìù x') : rfl
    ... ‚â§ ùìù (f x) : continuous_iff_continuous_at.mp (f_cont i) x'

lemma continuous_subtype_is_closed_cover {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} (c : Œπ ‚Üí Œ± ‚Üí Prop)
  (h_lf : locally_finite (Œªi, {x | c i x}))
  (h_is_closed : ‚àÄi, is_closed {x | c i x})
  (h_cover : ‚àÄx, ‚àÉi, c i x)
  (f_cont  : ‚àÄi, continuous (Œª(x : subtype (c i)), f x)) :
  continuous f :=
continuous_iff_is_closed.mpr $
  assume s hs,
  have ‚àÄi, is_closed ((coe : {x | c i x} ‚Üí Œ±) '' (f ‚àò coe ‚Åª¬π' s)),
    from assume i,
    (closed_embedding_subtype_coe (h_is_closed _)).is_closed_map _ (hs.preimage (f_cont i)),
  have is_closed (‚ãÉi, (coe : {x | c i x} ‚Üí Œ±) '' (f ‚àò coe ‚Åª¬π' s)),
    from locally_finite.is_closed_Union
      (h_lf.subset $ assume i x ‚ü®‚ü®x', hx'‚ü©, _, heq‚ü©, heq ‚ñ∏ hx')
      this,
  have f ‚Åª¬π' s = (‚ãÉi, (coe : {x | c i x} ‚Üí Œ±) '' (f ‚àò coe ‚Åª¬π' s)),
  begin
    apply set.ext,
    have : ‚àÄ (x : Œ±), f x ‚àà s ‚Üî ‚àÉ (i : Œπ), c i x ‚àß f x ‚àà s :=
      Œª x, ‚ü®Œª hx, let ‚ü®i, hi‚ü© := h_cover x in ‚ü®i, hi, hx‚ü©,
            Œª ‚ü®i, hi, hx‚ü©, hx‚ü©,
    simpa [and.comm, @and.left_comm (c _ _), ‚Üê exists_and_distrib_right],
  end,
  by rwa [this]

lemma closure_subtype {x : {a // p a}} {s : set {a // p a}}:
  x ‚àà closure s ‚Üî (x : Œ±) ‚àà closure ((coe : _ ‚Üí Œ±) '' s) :=
closure_induced

end subtype

section quotient
variables [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥]
variables {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : setoid Œ±}

lemma quotient_map_quot_mk : quotient_map (@quot.mk Œ± r) :=
‚ü®quot.exists_rep, rfl‚ü©

@[continuity] lemma continuous_quot_mk : continuous (@quot.mk Œ± r) :=
continuous_coinduced_rng

@[continuity] lemma continuous_quot_lift {f : Œ± ‚Üí Œ≤} (hr : ‚àÄ a b, r a b ‚Üí f a = f b)
  (h : continuous f) : continuous (quot.lift f hr : quot r ‚Üí Œ≤) :=
continuous_coinduced_dom h

lemma quotient_map_quotient_mk : quotient_map (@quotient.mk Œ± s) :=
quotient_map_quot_mk

lemma continuous_quotient_mk : continuous (@quotient.mk Œ± s) :=
continuous_coinduced_rng

lemma continuous_quotient_lift {f : Œ± ‚Üí Œ≤} (hs : ‚àÄ a b, a ‚âà b ‚Üí f a = f b)
  (h : continuous f) : continuous (quotient.lift f hs : quotient s ‚Üí Œ≤) :=
continuous_coinduced_dom h

lemma continuous_quotient_lift_on' {f : Œ± ‚Üí Œ≤} (hs : ‚àÄ a b, a ‚âà b ‚Üí f a = f b)
  (h : continuous f) : continuous (Œª x, quotient.lift_on' x f hs : quotient s ‚Üí Œ≤) :=
continuous_coinduced_dom h

end quotient

section pi
variables {Œπ : Type*} {œÄ : Œπ ‚Üí Type*}

@[continuity]
lemma continuous_pi [topological_space Œ±] [‚àÄi, topological_space (œÄ i)] {f : Œ± ‚Üí Œ†i:Œπ, œÄ i}
  (h : ‚àÄi, continuous (Œªa, f a i)) : continuous f :=
continuous_infi_rng $ assume i, continuous_induced_rng $ h i

@[continuity]
lemma continuous_apply [‚àÄi, topological_space (œÄ i)] (i : Œπ) :
  continuous (Œªp:Œ†i, œÄ i, p i) :=
continuous_infi_dom continuous_induced_dom

@[continuity]
lemma continuous_apply_apply {Œ∫ : Type*} {œÅ : Œ∫ ‚Üí Œπ ‚Üí Type*}
  [‚àÄ j i, topological_space (œÅ j i)] (j : Œ∫) (i : Œπ) :
  continuous (Œª p : (Œ† j, Œ† i, œÅ j i), p j i) :=
(continuous_apply i).comp (continuous_apply j)

lemma continuous_at_apply [‚àÄi, topological_space (œÄ i)] (i : Œπ) (x : Œ† i, œÄ i) :
  continuous_at (Œª p : Œ† i, œÄ i, p i) x :=
(continuous_apply i).continuous_at

lemma filter.tendsto.apply [‚àÄi, topological_space (œÄ i)] {l : filter Œ±} {f : Œ± ‚Üí Œ† i, œÄ i}
  {x : Œ† i, œÄ i} (h : tendsto f l (ùìù x)) (i : Œπ) :
  tendsto (Œª a, f a i) l (ùìù $ x i) :=
(continuous_at_apply i _).tendsto.comp h

lemma continuous_pi_iff [topological_space Œ±] [‚àÄ i, topological_space (œÄ i)] {f : Œ± ‚Üí Œ† i, œÄ i} :
  continuous f ‚Üî ‚àÄ i, continuous (Œª y, f y i) :=
iff.intro (Œª h i, (continuous_apply i).comp h) continuous_pi

lemma nhds_pi [t : ‚àÄi, topological_space (œÄ i)] {a : Œ†i, œÄ i} :
  ùìù a = pi (Œª i, ùìù (a i)) :=
calc ùìù a = (‚®Öi, @nhds _ (@topological_space.induced _ _ (Œªx:Œ†i, œÄ i, x i) (t i)) a) : nhds_infi
  ... = (‚®Öi, comap (Œªx, x i) (ùìù (a i))) : by simp [nhds_induced]

lemma tendsto_pi_nhds [t : ‚àÄi, topological_space (œÄ i)] {f : Œ± ‚Üí Œ†i, œÄ i} {g : Œ†i, œÄ i}
  {u : filter Œ±} :
  tendsto f u (ùìù g) ‚Üî ‚àÄ x, tendsto (Œª i, f i x) u (ùìù (g x)) :=
by rw [nhds_pi, filter.tendsto_pi]

lemma continuous_at_pi [‚àÄ i, topological_space (œÄ i)] [topological_space Œ±] {f : Œ± ‚Üí Œ† i, œÄ i}
  {x : Œ±} :
  continuous_at f x ‚Üî ‚àÄ i, continuous_at (Œª y, f y i) x :=
tendsto_pi_nhds

lemma filter.tendsto.update [‚àÄi, topological_space (œÄ i)] [decidable_eq Œπ]
  {l : filter Œ±} {f : Œ± ‚Üí Œ† i, œÄ i} {x : Œ† i, œÄ i} (hf : tendsto f l (ùìù x)) (i : Œπ)
  {g : Œ± ‚Üí œÄ i} {xi : œÄ i} (hg : tendsto g l (ùìù xi)) :
  tendsto (Œª a, function.update (f a) i (g a)) l (ùìù $ function.update x i xi) :=
tendsto_pi_nhds.2 $ Œª j, by { rcases em (j = i) with rfl|hj; simp [*, hf.apply] }

lemma continuous_at.update [‚àÄi, topological_space (œÄ i)] [topological_space Œ±] [decidable_eq Œπ]
  {f : Œ± ‚Üí Œ† i, œÄ i} {a : Œ±} (hf : continuous_at f a) (i : Œπ) {g : Œ± ‚Üí œÄ i}
  (hg : continuous_at g a) :
  continuous_at (Œª a, function.update (f a) i (g a)) a :=
hf.update i hg

lemma continuous.update [‚àÄi, topological_space (œÄ i)] [topological_space Œ±] [decidable_eq Œπ]
  {f : Œ± ‚Üí Œ† i, œÄ i} (hf : continuous f) (i : Œπ) {g : Œ± ‚Üí œÄ i} (hg : continuous g) :
  continuous (Œª a, function.update (f a) i (g a)) :=
continuous_iff_continuous_at.2 $ Œª x, hf.continuous_at.update i hg.continuous_at

/-- `function.update f i x` is continuous in `(f, x)`. -/
@[continuity] lemma continuous_update [‚àÄi, topological_space (œÄ i)] [decidable_eq Œπ] (i : Œπ) :
  continuous (Œª f : (Œ† j, œÄ j) √ó œÄ i, function.update f.1 i f.2) :=
continuous_fst.update i continuous_snd

lemma filter.tendsto.fin_insert_nth {n} {œÄ : fin (n + 1) ‚Üí Type*} [Œ† i, topological_space (œÄ i)]
  (i : fin (n + 1)) {f : Œ± ‚Üí œÄ i} {l : filter Œ±} {x : œÄ i} (hf : tendsto f l (ùìù x))
  {g : Œ± ‚Üí Œ† j : fin n, œÄ (i.succ_above j)} {y : Œ† j, œÄ (i.succ_above j)} (hg : tendsto g l (ùìù y)) :
  tendsto (Œª a, i.insert_nth (f a) (g a)) l (ùìù $ i.insert_nth x y) :=
tendsto_pi_nhds.2 (Œª j, fin.succ_above_cases i (by simpa) (by simpa using tendsto_pi_nhds.1 hg) j)

lemma continuous_at.fin_insert_nth {n} {œÄ : fin (n + 1) ‚Üí Type*} [Œ† i, topological_space (œÄ i)]
  [topological_space Œ±] (i : fin (n + 1)) {f : Œ± ‚Üí œÄ i} {a : Œ±} (hf : continuous_at f a)
  {g : Œ± ‚Üí Œ† j : fin n, œÄ (i.succ_above j)} (hg : continuous_at g a) :
  continuous_at (Œª a, i.insert_nth (f a) (g a)) a :=
hf.fin_insert_nth i hg

lemma continuous.fin_insert_nth {n} {œÄ : fin (n + 1) ‚Üí Type*} [Œ† i, topological_space (œÄ i)]
  [topological_space Œ±] (i : fin (n + 1)) {f : Œ± ‚Üí œÄ i} (hf : continuous f)
  {g : Œ± ‚Üí Œ† j : fin n, œÄ (i.succ_above j)} (hg : continuous g) :
  continuous (Œª a, i.insert_nth (f a) (g a)) :=
continuous_iff_continuous_at.2 $ Œª a, hf.continuous_at.fin_insert_nth i hg.continuous_at

lemma is_open_set_pi [‚àÄa, topological_space (œÄ a)] {i : set Œπ} {s : Œ†a, set (œÄ a)}
  (hi : finite i) (hs : ‚àÄa‚àài, is_open (s a)) : is_open (pi i s) :=
by rw [pi_def]; exact (is_open_bInter hi $ assume a ha, (hs _ ha).preimage (continuous_apply _))

lemma is_closed_set_pi [‚àÄa, topological_space (œÄ a)] {i : set Œπ} {s : Œ†a, set (œÄ a)}
  (hs : ‚àÄa‚àài, is_closed (s a)) : is_closed (pi i s) :=
by rw [pi_def];
  exact (is_closed_Inter $ Œª a, is_closed_Inter $ Œª ha, (hs _ ha).preimage (continuous_apply _))

lemma mem_nhds_of_pi_mem_nhds {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [Œ† (i : Œπ), topological_space (Œ± i)]
  {I : set Œπ} {s : Œ† i, set (Œ± i)} (a : Œ† i, Œ± i) (hs : I.pi s ‚àà ùìù a) {i : Œπ} (hi : i ‚àà I) :
  s i ‚àà ùìù (a i) :=
by { rw nhds_pi at hs, exact mem_of_pi_mem_pi hs hi }

lemma set_pi_mem_nhds [Œ† a, topological_space (œÄ a)] {i : set Œπ} {s : Œ† a, set (œÄ a)}
  {x : Œ† a, œÄ a} (hi : finite i) (hs : ‚àÄ a ‚àà i, s a ‚àà ùìù (x a)) :
  pi i s ‚àà ùìù x :=
by { rw [pi_def, bInter_mem hi], exact Œª a ha, (continuous_apply a).continuous_at (hs a ha) }

lemma set_pi_mem_nhds_iff {Œ± : Œπ ‚Üí Type*} [Œ† (i : Œπ), topological_space (Œ± i)]
  {I : set Œπ} (hI : I.finite) {s : Œ† i, set (Œ± i)} (a : Œ† i, Œ± i) :
  I.pi s ‚àà ùìù a ‚Üî ‚àÄ (i : Œπ), i ‚àà I ‚Üí s i ‚àà ùìù (a i) :=
by { rw [nhds_pi, pi_mem_pi_iff hI], apply_instance }

lemma interior_pi_set {Œ± : Œπ ‚Üí Type*} [Œ† i, topological_space (Œ± i)]
  {I : set Œπ} (hI : I.finite) {s : Œ† i, set (Œ± i)} :
  interior (pi I s) = I.pi (Œª i, interior (s i)) :=
by { ext a, simp only [set.mem_pi, mem_interior_iff_mem_nhds, set_pi_mem_nhds_iff hI] }

lemma exists_finset_piecewise_mem_of_mem_nhds [decidable_eq Œπ] [Œ† i, topological_space (œÄ i)]
  {s : set (Œ† a, œÄ a)} {x : Œ† a, œÄ a} (hs : s ‚àà ùìù x) (y : Œ† a, œÄ a) :
  ‚àÉ I : finset Œπ, I.piecewise x y ‚àà s :=
begin
  simp only [nhds_pi, filter.mem_pi'] at hs,
  rcases hs with ‚ü®I, t, htx, hts‚ü©,
  refine ‚ü®I, hts $ Œª i hi, _‚ü©,
  simpa [finset.mem_coe.1 hi] using mem_of_mem_nhds (htx i)
end

lemma pi_eq_generate_from [‚àÄa, topological_space (œÄ a)] :
  Pi.topological_space =
  generate_from {g | ‚àÉ(s:Œ†a, set (œÄ a)) (i : finset Œπ), (‚àÄa‚àài, is_open (s a)) ‚àß g = pi ‚Üëi s} :=
le_antisymm
  (le_generate_from $ assume g ‚ü®s, i, hi, eq‚ü©, eq.symm ‚ñ∏ is_open_set_pi (finset.finite_to_set _) hi)
  (le_infi $ assume a s ‚ü®t, ht, s_eq‚ü©, generate_open.basic _ $
    ‚ü®function.update (Œªa, univ) a t, {a}, by simpa using ht, s_eq ‚ñ∏ by ext f; simp [set.pi]‚ü©)

lemma pi_generate_from_eq {g : Œ†a, set (set (œÄ a))} :
  @Pi.topological_space Œπ œÄ (Œªa, generate_from (g a)) =
  generate_from {t | ‚àÉ(s:Œ†a, set (œÄ a)) (i : finset Œπ), (‚àÄa‚àài, s a ‚àà g a) ‚àß t = pi ‚Üëi s} :=
let G := {t | ‚àÉ(s:Œ†a, set (œÄ a)) (i : finset Œπ), (‚àÄa‚àài, s a ‚àà g a) ‚àß t = pi ‚Üëi s} in
begin
  rw [pi_eq_generate_from],
  refine le_antisymm (generate_from_mono _) (le_generate_from _),
  exact assume s ‚ü®t, i, ht, eq‚ü©, ‚ü®t, i, assume a ha, generate_open.basic _ (ht a ha), eq‚ü©,
  { rintros s ‚ü®t, i, hi, rfl‚ü©,
    rw [pi_def],
    apply is_open_bInter (finset.finite_to_set _),
    assume a ha, show ((generate_from G).coinduced (Œªf:Œ†a, œÄ a, f a)).is_open (t a),
    refine le_generate_from _ _ (hi a ha),
    exact assume s hs, generate_open.basic _ ‚ü®function.update (Œªa, univ) a s, {a}, by simp [hs]‚ü© }
end

lemma pi_generate_from_eq_fintype {g : Œ†a, set (set (œÄ a))} [fintype Œπ] (hg : ‚àÄa, ‚ãÉ‚ÇÄ g a = univ) :
  @Pi.topological_space Œπ œÄ (Œªa, generate_from (g a)) =
  generate_from {t | ‚àÉ(s:Œ†a, set (œÄ a)), (‚àÄa, s a ‚àà g a) ‚àß t = pi univ s} :=
begin
  rw [pi_generate_from_eq],
  refine le_antisymm (generate_from_mono _) (le_generate_from _),
  exact assume s ‚ü®t, ht, eq‚ü©, ‚ü®t, finset.univ, by simp [ht, eq]‚ü©,
  { rintros s ‚ü®t, i, ht, rfl‚ü©,
    apply is_open_iff_forall_mem_open.2 _,
    assume f hf,
    choose c hc using show ‚àÄa, ‚àÉs, s ‚àà g a ‚àß f a ‚àà s,
    { assume a, have : f a ‚àà ‚ãÉ‚ÇÄ g a, { rw [hg], apply mem_univ }, simpa },
    refine ‚ü®pi univ (Œªa, if a ‚àà i then t a else (c : Œ†a, set (œÄ a)) a), _, _, _‚ü©,
    { simp [pi_if] },
    { refine generate_open.basic _ ‚ü®_, assume a, _, rfl‚ü©,
      by_cases a ‚àà i; simp [*, set.pi] at * },
    { have : f ‚àà pi {a | a ‚àâ i} c, { simp [*, set.pi] at * },
      simpa [pi_if, hf] } }
end

/-- Suppose `œÄ i` is a family of topological spaces indexed by `i : Œπ`, and `X` is a type
endowed with a family of maps `f i : X ‚Üí œÄ i` for every `i : Œπ`, hence inducing a
map `g : X ‚Üí Œ† i, œÄ i`. This lemma shows that infimum of the topologies on `X` induced by
the `f i` as `i : Œπ` varies is simply the topology on `X` induced by `g : X ‚Üí Œ† i, œÄ i`
where `Œ† i, œÄ i` is endowed with the usual product topology. -/
lemma inducing_infi_to_pi {X : Type*} [‚àÄ i, topological_space (œÄ i)] (f : Œ† i, X ‚Üí œÄ i) :
  @inducing X (Œ† i, œÄ i) (‚®Ö i, induced (f i) infer_instance) _ (Œª x i, f i x) :=
begin
  constructor,
  erw induced_infi,
  congr' 1,
  funext,
  erw induced_compose,
end

variables [fintype Œπ] [‚àÄ i, topological_space (œÄ i)] [‚àÄ i, discrete_topology (œÄ i)]

/-- A finite product of discrete spaces is discrete. -/
instance Pi.discrete_topology : discrete_topology (Œ† i, œÄ i) :=
singletons_open_iff_discrete.mp (Œª x,
begin
  rw show {x} = ‚ãÇ i, {y : Œ† i, œÄ i | y i = x i},
  { ext, simp only [function.funext_iff, set.mem_singleton_iff, set.mem_Inter, set.mem_set_of_eq] },
  exact is_open_Inter (Œª i, (continuous_apply i).is_open_preimage {x i} (is_open_discrete {x i}))
end)

end pi

section sigma
variables {Œπ : Type*} {œÉ : Œπ ‚Üí Type*} [Œ† i, topological_space (œÉ i)]

@[continuity]
lemma continuous_sigma_mk {i : Œπ} : continuous (@sigma.mk Œπ œÉ i) :=
continuous_supr_rng continuous_coinduced_rng

lemma is_open_sigma_iff {s : set (sigma œÉ)} : is_open s ‚Üî ‚àÄ i, is_open (sigma.mk i ‚Åª¬π' s) :=
by simp only [is_open_supr_iff, is_open_coinduced]

lemma is_closed_sigma_iff {s : set (sigma œÉ)} : is_closed s ‚Üî ‚àÄ i, is_closed (sigma.mk i ‚Åª¬π' s) :=
by simp only [‚Üê is_open_compl_iff, is_open_sigma_iff, preimage_compl]

lemma is_open_sigma_fst_preimage (s : set Œπ) :  is_open (sigma.fst ‚Åª¬π' s : set (Œ£ a, œÉ a)) :=
begin
  rw is_open_sigma_iff,
  intros a,
  by_cases h : a ‚àà s,
  { convert is_open_univ,
    ext x,
    simp only [h, set.mem_preimage, set.mem_univ] },
  { convert is_open_empty,
    ext x,
    simp only [h, set.mem_empty_eq, set.mem_preimage] }
end

lemma is_open_map_sigma_mk {i : Œπ} : is_open_map (@sigma.mk Œπ œÉ i) :=
begin
  intros s hs,
  rw is_open_sigma_iff,
  intro j,
  rcases eq_or_ne i j with (rfl|hne),
  { rwa set.preimage_image_eq _ sigma_mk_injective },
  { convert is_open_empty,
    apply set.eq_empty_of_subset_empty,
    rintro x ‚ü®y, _, hy‚ü©,
    have : i = j, by cc,
    contradiction }
end

lemma is_open_range_sigma_mk {i : Œπ} : is_open (set.range (@sigma.mk Œπ œÉ i)) :=
is_open_map_sigma_mk.is_open_range

lemma is_closed_map_sigma_mk {i : Œπ} : is_closed_map (@sigma.mk Œπ œÉ i) :=
begin
  intros s hs,
  rw is_closed_sigma_iff,
  intro j,
  rcases eq_or_ne i j with (rfl|hne),
  { rwa set.preimage_image_eq _ sigma_mk_injective },
  { convert is_closed_empty,
    apply set.eq_empty_of_subset_empty,
    rintro x ‚ü®y, _, hy‚ü©,
    have : i = j, by cc,
    contradiction }
end

lemma is_closed_sigma_mk {i : Œπ} : is_closed (set.range (@sigma.mk Œπ œÉ i)) :=
by { rw ‚Üêset.image_univ, exact is_closed_map_sigma_mk _ is_closed_univ }

lemma open_embedding_sigma_mk {i : Œπ} : open_embedding (@sigma.mk Œπ œÉ i) :=
open_embedding_of_continuous_injective_open
  continuous_sigma_mk sigma_mk_injective is_open_map_sigma_mk

lemma closed_embedding_sigma_mk {i : Œπ} : closed_embedding (@sigma.mk Œπ œÉ i) :=
closed_embedding_of_continuous_injective_closed
  continuous_sigma_mk sigma_mk_injective is_closed_map_sigma_mk

lemma embedding_sigma_mk {i : Œπ} : embedding (@sigma.mk Œπ œÉ i) :=
closed_embedding_sigma_mk.1

/-- A map out of a sum type is continuous if its restriction to each summand is. -/
@[continuity]
lemma continuous_sigma [topological_space Œ≤] {f : sigma œÉ ‚Üí Œ≤}
  (h : ‚àÄ i, continuous (Œª a, f ‚ü®i, a‚ü©)) : continuous f :=
continuous_supr_dom (Œª i, continuous_coinduced_dom (h i))

@[continuity]
lemma continuous_sigma_map {Œ∫ : Type*} {œÑ : Œ∫ ‚Üí Type*} [Œ† k, topological_space (œÑ k)]
  {f‚ÇÅ : Œπ ‚Üí Œ∫} {f‚ÇÇ : Œ† i, œÉ i ‚Üí œÑ (f‚ÇÅ i)} (hf : ‚àÄ i, continuous (f‚ÇÇ i)) :
  continuous (sigma.map f‚ÇÅ f‚ÇÇ) :=
continuous_sigma $ Œª i,
  show continuous (Œª a, sigma.mk (f‚ÇÅ i) (f‚ÇÇ i a)),
  from continuous_sigma_mk.comp (hf i)

lemma is_open_map_sigma [topological_space Œ≤] {f : sigma œÉ ‚Üí Œ≤}
  (h : ‚àÄ i, is_open_map (Œª a, f ‚ü®i, a‚ü©)) : is_open_map f :=
begin
  intros s hs,
  rw is_open_sigma_iff at hs,
  rw [‚Üê Union_image_preimage_sigma_mk_eq_self s, image_Union],
  apply is_open_Union,
  intro i,
  rw [image_image],
  exact h i _ (hs i)
end

/-- The sum of embeddings is an embedding. -/
lemma embedding_sigma_map {œÑ : Œπ ‚Üí Type*} [Œ† i, topological_space (œÑ i)]
  {f : Œ† i, œÉ i ‚Üí œÑ i} (hf : ‚àÄ i, embedding (f i)) : embedding (sigma.map id f) :=
begin
  refine ‚ü®‚ü®_‚ü©, function.injective_id.sigma_map (Œª i, (hf i).inj)‚ü©,
  refine le_antisymm
    (continuous_iff_le_induced.mp (continuous_sigma_map (Œª i, (hf i).continuous))) _,
  intros s hs,
  replace hs := is_open_sigma_iff.mp hs,
  have : ‚àÄ i, ‚àÉ t, is_open t ‚àß f i ‚Åª¬π' t = sigma.mk i ‚Åª¬π' s,
  { intro i,
    apply is_open_induced_iff.mp,
    convert hs i,
    exact (hf i).induced.symm },
  choose t ht using this,
  apply is_open_induced_iff.mpr,
  refine ‚ü®‚ãÉ i, sigma.mk i '' t i, is_open_Union (Œª i, is_open_map_sigma_mk _ (ht i).1), _‚ü©,
  ext ‚ü®i, x‚ü©,
  change (sigma.mk i (f i x) ‚àà ‚ãÉ (i : Œπ), sigma.mk i '' t i) ‚Üî x ‚àà sigma.mk i ‚Åª¬π' s,
  rw [‚Üê(ht i).2, mem_Union],
  split,
  { rintro ‚ü®j, hj‚ü©,
    rw mem_image at hj,
    rcases hj with ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü©,
    rcases sigma.mk.inj_iff.mp hy‚ÇÇ with ‚ü®rfl, hy‚ü©,
    replace hy := eq_of_heq hy,
    subst y,
    exact hy‚ÇÅ },
  { intro hx,
    use i,
    rw mem_image,
    exact ‚ü®f i x, hx, rfl‚ü© }
end

end sigma

section ulift

@[continuity] lemma continuous_ulift_down [topological_space Œ±] :
  continuous (ulift.down : ulift.{v u} Œ± ‚Üí Œ±) :=
continuous_induced_dom

@[continuity] lemma continuous_ulift_up [topological_space Œ±] :
  continuous (ulift.up : Œ± ‚Üí ulift.{v u} Œ±) :=
continuous_induced_rng continuous_id

end ulift

lemma mem_closure_of_continuous [topological_space Œ±] [topological_space Œ≤]
  {f : Œ± ‚Üí Œ≤} {a : Œ±} {s : set Œ±} {t : set Œ≤}
  (hf : continuous f) (ha : a ‚àà closure s) (h : maps_to f s (closure t)) :
  f a ‚àà closure t :=
calc f a ‚àà f '' closure s : mem_image_of_mem _ ha
  ... ‚äÜ closure (f '' s) : image_closure_subset_closure_image hf
  ... ‚äÜ closure t : closure_minimal h.image_subset is_closed_closure

lemma mem_closure_of_continuous2 [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥]
  {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {a : Œ±} {b : Œ≤} {s : set Œ±} {t : set Œ≤} {u : set Œ≥}
  (hf : continuous (Œªp:Œ±√óŒ≤, f p.1 p.2)) (ha : a ‚àà closure s) (hb : b ‚àà closure t)
  (h : ‚àÄa‚ààs, ‚àÄb‚ààt, f a b ‚àà closure u) :
  f a b ‚àà closure u :=
have (a,b) ‚àà closure (s √óÀ¢ t),
  by simp [closure_prod_eq, ha, hb],
show f (a, b).1 (a, b).2 ‚àà closure u,
  from @mem_closure_of_continuous (Œ±√óŒ≤) _ _ _ (Œªp:Œ±√óŒ≤, f p.1 p.2) (a,b) _ u hf this $
    assume ‚ü®p‚ÇÅ, p‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h p‚ÇÅ h‚ÇÅ p‚ÇÇ h‚ÇÇ
