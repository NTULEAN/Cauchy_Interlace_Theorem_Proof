/-
Copyright (c) 2021 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import topology.algebra.monoid
import group_theory.group_action.prod
import group_theory.group_action.basic
import topology.homeomorph
import topology.algebra.const_mul_action

/-!
# Continuous monoid action

In this file we define class `has_continuous_smul`. We say `has_continuous_smul M Œ±` if `M` acts on
`Œ±` and the map `(c, x) ‚Ü¶ c ‚Ä¢ x` is continuous on `M √ó Œ±`. We reuse this class for topological
(semi)modules, vector spaces and algebras.

## Main definitions

* `has_continuous_smul M Œ±` : typeclass saying that the map `(c, x) ‚Ü¶ c ‚Ä¢ x` is continuous
  on `M √ó Œ±`;
* `homeomorph.smul_of_ne_zero`: if a group with zero `G‚ÇÄ` (e.g., a field) acts on `Œ±` and `c : G‚ÇÄ`
  is a nonzero element of `G‚ÇÄ`, then scalar multiplication by `c` is a homeomorphism of `Œ±`;
* `homeomorph.smul`: scalar multiplication by an element of a group `G` acting on `Œ±`
  is a homeomorphism of `Œ±`.
* `units.has_continuous_smul`: scalar multiplication by `MÀ£` is continuous when scalar
  multiplication by `M` is continuous. This allows `homeomorph.smul` to be used with on monoids
  with `G = MÀ£`.

## Main results

Besides homeomorphisms mentioned above, in this file we provide lemmas like `continuous.smul`
or `filter.tendsto.smul` that provide dot-syntax access to `continuous_smul`.
-/

open_locale topological_space pointwise
open filter

/-- Class `has_continuous_smul M Œ±` says that the scalar multiplication `(‚Ä¢) : M ‚Üí Œ± ‚Üí Œ±`
is continuous in both arguments. We use the same class for all kinds of multiplicative actions,
including (semi)modules and algebras. -/
class has_continuous_smul (M Œ± : Type*) [has_scalar M Œ±]
  [topological_space M] [topological_space Œ±] : Prop :=
(continuous_smul : continuous (Œªp : M √ó Œ±, p.1 ‚Ä¢ p.2))

export has_continuous_smul (continuous_smul)

/-- Class `has_continuous_vadd M Œ±` says that the additive action `(+·µ•) : M ‚Üí Œ± ‚Üí Œ±`
is continuous in both arguments. We use the same class for all kinds of additive actions,
including (semi)modules and algebras. -/
class has_continuous_vadd (M Œ± : Type*) [has_vadd M Œ±]
  [topological_space M] [topological_space Œ±] : Prop :=
(continuous_vadd : continuous (Œªp : M √ó Œ±, p.1 +·µ• p.2))

export has_continuous_vadd (continuous_vadd)

attribute [to_additive] has_continuous_smul

variables {M Œ± Œ≤ : Type*}
variables [topological_space M] [topological_space Œ±]

section has_scalar
variables [has_scalar M Œ±] [has_continuous_smul M Œ±]

@[priority 100, to_additive] instance has_continuous_smul.has_continuous_const_smul :
  has_continuous_const_smul M Œ± :=
{ continuous_const_smul := Œª _, continuous_smul.comp (continuous_const.prod_mk continuous_id) }

@[to_additive]
lemma filter.tendsto.smul {f : Œ≤ ‚Üí M} {g : Œ≤ ‚Üí Œ±} {l : filter Œ≤} {c : M} {a : Œ±}
  (hf : tendsto f l (ùìù c)) (hg : tendsto g l (ùìù a)) :
  tendsto (Œª x, f x ‚Ä¢ g x) l (ùìù $ c ‚Ä¢ a) :=
(continuous_smul.tendsto _).comp (hf.prod_mk_nhds hg)

@[to_additive]
lemma filter.tendsto.smul_const {f : Œ≤ ‚Üí M} {l : filter Œ≤} {c : M}
  (hf : tendsto f l (ùìù c)) (a : Œ±) :
  tendsto (Œª x, (f x) ‚Ä¢ a) l (ùìù (c ‚Ä¢ a)) :=
hf.smul tendsto_const_nhds

variables [topological_space Œ≤] {f : Œ≤ ‚Üí M} {g : Œ≤ ‚Üí Œ±} {b : Œ≤} {s : set Œ≤}

@[to_additive]
lemma continuous_within_at.smul (hf : continuous_within_at f s b)
  (hg : continuous_within_at g s b) :
  continuous_within_at (Œª x, f x ‚Ä¢ g x) s b :=
hf.smul hg

@[to_additive]
lemma continuous_at.smul (hf : continuous_at f b) (hg : continuous_at g b) :
  continuous_at (Œª x, f x ‚Ä¢ g x) b :=
hf.smul hg

@[to_additive]
lemma continuous_on.smul (hf : continuous_on f s) (hg : continuous_on g s) :
  continuous_on (Œª x, f x ‚Ä¢ g x) s :=
Œª x hx, (hf x hx).smul (hg x hx)

@[continuity, to_additive]
lemma continuous.smul (hf : continuous f) (hg : continuous g) :
  continuous (Œª x, f x ‚Ä¢ g x) :=
continuous_smul.comp (hf.prod_mk hg)

/-- If a scalar is central, then its right action is continuous when its left action is. -/
instance has_continuous_smul.op [has_scalar M·µê·µí·µñ Œ±] [is_central_scalar M Œ±] :
  has_continuous_smul M·µê·µí·µñ Œ± :=
‚ü® suffices continuous (Œª p : M √ó Œ±, mul_opposite.op p.fst ‚Ä¢ p.snd),
  from this.comp (mul_opposite.continuous_unop.prod_map continuous_id),
  by simpa only [op_smul_eq_smul] using (continuous_smul : continuous (Œª p : M √ó Œ±, _)) ‚ü©

end has_scalar

section monoid
variables [monoid M] [mul_action M Œ±] [has_continuous_smul M Œ±]

@[to_additive] instance units.has_continuous_smul : has_continuous_smul MÀ£ Œ± :=
{ continuous_smul :=
    show continuous ((Œª p : M √ó Œ±, p.fst ‚Ä¢ p.snd) ‚àò (Œª p : MÀ£ √ó Œ±, (p.1, p.2))),
    from continuous_smul.comp ((units.continuous_coe.comp continuous_fst).prod_mk continuous_snd) }

end monoid

@[to_additive]
instance has_continuous_mul.has_continuous_smul {M : Type*} [monoid M]
  [topological_space M] [has_continuous_mul M] :
  has_continuous_smul M M :=
‚ü®continuous_mul‚ü©

@[to_additive]
instance [topological_space Œ≤] [has_scalar M Œ±] [has_scalar M Œ≤] [has_continuous_smul M Œ±]
  [has_continuous_smul M Œ≤] :
  has_continuous_smul M (Œ± √ó Œ≤) :=
‚ü®(continuous_fst.smul (continuous_fst.comp continuous_snd)).prod_mk
  (continuous_fst.smul (continuous_snd.comp continuous_snd))‚ü©

@[to_additive]
instance {Œπ : Type*} {Œ≥ : Œπ ‚Üí Type*}
  [‚àÄ i, topological_space (Œ≥ i)] [Œ† i, has_scalar M (Œ≥ i)] [‚àÄ i, has_continuous_smul M (Œ≥ i)] :
  has_continuous_smul M (Œ† i, Œ≥ i) :=
‚ü®continuous_pi $ Œª i,
  (continuous_fst.smul continuous_snd).comp $
    continuous_fst.prod_mk ((continuous_apply i).comp continuous_snd)‚ü©

section lattice_ops

variables {Œπ : Type*} [has_scalar M Œ≤]
  {ts : set (topological_space Œ≤)} (h : Œ† t ‚àà ts, @has_continuous_smul M Œ≤ _ _ t)
  {ts' : Œπ ‚Üí topological_space Œ≤} (h' : Œ† i, @has_continuous_smul M Œ≤ _ _ (ts' i))
  {t‚ÇÅ t‚ÇÇ : topological_space Œ≤} [h‚ÇÅ : @has_continuous_smul M Œ≤ _ _ t‚ÇÅ]
  [h‚ÇÇ : @has_continuous_smul M Œ≤ _ _ t‚ÇÇ]

include h

@[to_additive] lemma has_continuous_smul_Inf :
  @has_continuous_smul M Œ≤ _ _ (Inf ts) :=
{ continuous_smul :=
  begin
    rw ‚Üê @Inf_singleton _ _ ‚Äπtopological_space M‚Ä∫,
    exact continuous_Inf_rng (Œª t ht, continuous_Inf_dom‚ÇÇ (eq.refl _) ht
      (@has_continuous_smul.continuous_smul _ _ _ _ t (h t ht)))
  end }

omit h

include h'

@[to_additive] lemma has_continuous_smul_infi :
  @has_continuous_smul M Œ≤ _ _ (‚®Ö i, ts' i) :=
by {rw ‚Üê Inf_range, exact has_continuous_smul_Inf (set.forall_range_iff.mpr h')}

omit h'

include h‚ÇÅ h‚ÇÇ

@[to_additive] lemma has_continuous_smul_inf :
  @has_continuous_smul M Œ≤ _ _ (t‚ÇÅ ‚äì t‚ÇÇ) :=
by {rw inf_eq_infi, refine has_continuous_smul_infi (Œª b, _), cases b; assumption}

omit h‚ÇÅ h‚ÇÇ

end lattice_ops
