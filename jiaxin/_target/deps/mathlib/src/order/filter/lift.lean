/-
Copyright (c) 2019 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl
-/
import order.filter.bases

/-!
# Lift filters along filter and set functions
-/

open set

open_locale classical filter

namespace filter
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œπ : Sort*}

section lift

/-- A variant on `bind` using a function `g` taking a set instead of a member of `Œ±`.
This is essentially a push-forward along a function mapping each set to a filter. -/
protected def lift (f : filter Œ±) (g : set Œ± ‚Üí filter Œ≤) :=
‚®Ös ‚àà f, g s

variables {f f‚ÇÅ f‚ÇÇ : filter Œ±} {g g‚ÇÅ g‚ÇÇ : set Œ± ‚Üí filter Œ≤}

@[simp] lemma lift_top (g : set Œ± ‚Üí filter Œ≤) : (‚ä§ : filter Œ±).lift g = g univ :=
by simp [filter.lift]

/-- If `(p : Œπ ‚Üí Prop, s : Œπ ‚Üí set Œ±)` is a basis of a filter `f`, `g` is a monotone function
`set Œ± ‚Üí filter Œ≥`, and for each `i`, `(pg : Œ≤ i ‚Üí Prop, sg : Œ≤ i ‚Üí set Œ±)` is a basis
of the filter `g (s i)`, then `(Œª (i : Œπ) (x : Œ≤ i), p i ‚àß pg i x, Œª (i : Œπ) (x : Œ≤ i), sg i x)`
is a basis of the filter `f.lift g`.

This basis is parametrized by `i : Œπ` and `x : Œ≤ i`, so in order to formulate this fact using
`has_basis` one has to use `Œ£ i, Œ≤ i` as the index type, see `filter.has_basis.lift`.
This lemma states the corresponding `mem_iff` statement without using a sigma type. -/
lemma has_basis.mem_lift_iff {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} {f : filter Œ±}
  (hf : f.has_basis p s) {Œ≤ : Œπ ‚Üí Type*} {pg : Œ† i, Œ≤ i ‚Üí Prop} {sg : Œ† i, Œ≤ i ‚Üí set Œ≥}
  {g : set Œ± ‚Üí filter Œ≥} (hg : ‚àÄ i, (g $ s i).has_basis (pg i) (sg i)) (gm : monotone g)
  {s : set Œ≥} :
  s ‚àà f.lift g ‚Üî ‚àÉ (i : Œπ) (hi : p i) (x : Œ≤ i) (hx : pg i x), sg i x ‚äÜ s :=
begin
  refine (mem_binfi_of_directed _ ‚ü®univ, univ_sets _‚ü©).trans _,
  { intros t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ,
    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm $ inter_subset_left _ _,
      gm $ inter_subset_right _ _‚ü© },
  { simp only [‚Üê (hg _).mem_iff],
    exact hf.exists_iff (Œª t‚ÇÅ t‚ÇÇ ht H, gm ht H) }
end

/-- If `(p : Œπ ‚Üí Prop, s : Œπ ‚Üí set Œ±)` is a basis of a filter `f`, `g` is a monotone function
`set Œ± ‚Üí filter Œ≥`, and for each `i`, `(pg : Œ≤ i ‚Üí Prop, sg : Œ≤ i ‚Üí set Œ±)` is a basis
of the filter `g (s i)`, then `(Œª (i : Œπ) (x : Œ≤ i), p i ‚àß pg i x, Œª (i : Œπ) (x : Œ≤ i), sg i x)`
is a basis of the filter `f.lift g`.

This basis is parametrized by `i : Œπ` and `x : Œ≤ i`, so in order to formulate this fact using
`has_basis` one has to use `Œ£ i, Œ≤ i` as the index type. See also `filter.has_basis.mem_lift_iff`
for the corresponding `mem_iff` statement formulated without using a sigma type. -/
lemma has_basis.lift {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} {f : filter Œ±} (hf : f.has_basis p s)
  {Œ≤ : Œπ ‚Üí Type*} {pg : Œ† i, Œ≤ i ‚Üí Prop} {sg : Œ† i, Œ≤ i ‚Üí set Œ≥} {g : set Œ± ‚Üí filter Œ≥}
  (hg : ‚àÄ i, (g $ s i).has_basis (pg i) (sg i)) (gm : monotone g) :
  (f.lift g).has_basis (Œª i : Œ£ i, Œ≤ i, p i.1 ‚àß pg i.1 i.2) (Œª i : Œ£ i, Œ≤ i, sg i.1 i.2) :=
begin
  refine ‚ü®Œª t, (hf.mem_lift_iff hg gm).trans _‚ü©,
  simp [sigma.exists, and_assoc, exists_and_distrib_left]
end

lemma mem_lift_sets (hg : monotone g) {s : set Œ≤} :
  s ‚àà f.lift g ‚Üî ‚àÉt‚ààf, s ‚àà g t :=
(f.basis_sets.mem_lift_iff (Œª s, (g s).basis_sets) hg).trans $
  by simp only [id, exists_mem_subset_iff]

lemma mem_lift {s : set Œ≤} {t : set Œ±} (ht : t ‚àà f) (hs : s ‚àà g t) :
  s ‚àà f.lift g :=
le_principal_iff.mp $ show f.lift g ‚â§ ùìü s,
  from infi_le_of_le t $ infi_le_of_le ht $ le_principal_iff.mpr hs

lemma lift_le {f : filter Œ±} {g : set Œ± ‚Üí filter Œ≤} {h : filter Œ≤} {s : set Œ±}
  (hs : s ‚àà f) (hg : g s ‚â§ h) : f.lift g ‚â§ h :=
infi_le_of_le s $ infi_le_of_le hs $ hg

lemma le_lift {f : filter Œ±} {g : set Œ± ‚Üí filter Œ≤} {h : filter Œ≤}
  (hh : ‚àÄs‚ààf, h ‚â§ g s) : h ‚â§ f.lift g :=
le_infi $ assume s, le_infi $ assume hs, hh s hs

lemma lift_mono (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) : f‚ÇÅ.lift g‚ÇÅ ‚â§ f‚ÇÇ.lift g‚ÇÇ :=
infi_le_infi $ assume s, infi_le_infi2 $ assume hs, ‚ü®hf hs, hg s‚ü©

lemma lift_mono' (hg : ‚àÄs‚ààf, g‚ÇÅ s ‚â§ g‚ÇÇ s) : f.lift g‚ÇÅ ‚â§ f.lift g‚ÇÇ :=
infi_le_infi $ assume s, infi_le_infi $ assume hs, hg s hs

lemma tendsto_lift {m : Œ≥ ‚Üí Œ≤} {l : filter Œ≥} :
  tendsto m l (f.lift g) ‚Üî ‚àÄ s ‚àà f, tendsto m l (g s) :=
by simp only [filter.lift, tendsto_infi]

lemma map_lift_eq {m : Œ≤ ‚Üí Œ≥} (hg : monotone g) : map m (f.lift g) = f.lift (map m ‚àò g) :=
have monotone (map m ‚àò g),
  from map_mono.comp hg,
filter.ext $ Œª s,
  by simp only [mem_lift_sets hg, mem_lift_sets this, exists_prop, mem_map, function.comp_app]

lemma comap_lift_eq {m : Œ≥ ‚Üí Œ≤} (hg : monotone g) : comap m (f.lift g) = f.lift (comap m ‚àò g) :=
have monotone (comap m ‚àò g),
  from comap_mono.comp hg,
begin
  ext,
  simp only [mem_lift_sets hg, mem_lift_sets this, mem_comap, exists_prop, mem_lift_sets],
  exact ‚ü®Œª ‚ü®b, ‚ü®a, ha, hb‚ü©, hs‚ü©, ‚ü®a, ha, b, hb, hs‚ü©, Œª ‚ü®a, ha, b, hb, hs‚ü©, ‚ü®b, ‚ü®a, ha, hb‚ü©, hs‚ü©‚ü©
end

theorem comap_lift_eq2 {m : Œ≤ ‚Üí Œ±} {g : set Œ≤ ‚Üí filter Œ≥} (hg : monotone g) :
  (comap m f).lift g = f.lift (g ‚àò preimage m) :=
le_antisymm
  (le_infi $ assume s, le_infi $ assume hs,
    infi_le_of_le (preimage m s) $ infi_le _ ‚ü®s, hs, subset.refl _‚ü©)
  (le_infi $ assume s, le_infi $ assume ‚ü®s', hs', (h_sub : preimage m s' ‚äÜ s)‚ü©,
    infi_le_of_le s' $ infi_le_of_le hs' $ hg h_sub)

lemma map_lift_eq2 {g : set Œ≤ ‚Üí filter Œ≥} {m : Œ± ‚Üí Œ≤} (hg : monotone g) :
  (map m f).lift g = f.lift (g ‚àò image m) :=
le_antisymm
  (infi_le_infi2 $ assume s, ‚ü®image m s,
    infi_le_infi2 $ assume hs, ‚ü®
      f.sets_of_superset hs $ assume a h, mem_image_of_mem _ h,
      le_rfl‚ü©‚ü©)
  (infi_le_infi2 $ assume t, ‚ü®preimage m t,
    infi_le_infi2 $ assume ht, ‚ü®ht,
      hg $ assume x, assume h : x ‚àà m '' preimage m t,
        let ‚ü®y, hy, h_eq‚ü© := h in
        show x ‚àà t, from h_eq ‚ñ∏ hy‚ü©‚ü©)

lemma lift_comm {g : filter Œ≤} {h : set Œ± ‚Üí set Œ≤ ‚Üí filter Œ≥} :
  f.lift (Œªs, g.lift (h s)) = g.lift (Œªt, f.lift (Œªs, h s t)) :=
le_antisymm
  (le_infi $ assume i, le_infi $ assume hi, le_infi $ assume j, le_infi $ assume hj,
    infi_le_of_le j $ infi_le_of_le hj $ infi_le_of_le i $ infi_le _ hi)
  (le_infi $ assume i, le_infi $ assume hi, le_infi $ assume j, le_infi $ assume hj,
    infi_le_of_le j $ infi_le_of_le hj $ infi_le_of_le i $ infi_le _ hi)

lemma lift_assoc {h : set Œ≤ ‚Üí filter Œ≥} (hg : monotone g)  :
  (f.lift g).lift h = f.lift (Œªs, (g s).lift h) :=
le_antisymm
  (le_infi $ assume s, le_infi $ assume hs, le_infi $ assume t, le_infi $ assume ht,
    infi_le_of_le t $ infi_le _ $ (mem_lift_sets hg).mpr ‚ü®_, hs, ht‚ü©)
  (le_infi $ assume t, le_infi $ assume ht,
    let ‚ü®s, hs, h'‚ü© := (mem_lift_sets hg).mp ht in
    infi_le_of_le s $ infi_le_of_le hs $ infi_le_of_le t $ infi_le _ h')

lemma lift_lift_same_le_lift {g : set Œ± ‚Üí set Œ± ‚Üí filter Œ≤} :
  f.lift (Œªs, f.lift (g s)) ‚â§ f.lift (Œªs, g s s) :=
le_infi $ assume s, le_infi $ assume hs, infi_le_of_le s $ infi_le_of_le hs $ infi_le_of_le s $
  infi_le _ hs

lemma lift_lift_same_eq_lift {g : set Œ± ‚Üí set Œ± ‚Üí filter Œ≤}
  (hg‚ÇÅ : ‚àÄs, monotone (Œªt, g s t)) (hg‚ÇÇ : ‚àÄt, monotone (Œªs, g s t)) :
  f.lift (Œªs, f.lift (g s)) = f.lift (Œªs, g s s) :=
le_antisymm
  lift_lift_same_le_lift
  (le_infi $ assume s, le_infi $ assume hs, le_infi $ assume t, le_infi $ assume ht,
    infi_le_of_le (s ‚à© t) $
    infi_le_of_le (inter_mem hs ht) $
    calc g (s ‚à© t) (s ‚à© t) ‚â§ g s (s ‚à© t) : hg‚ÇÇ (s ‚à© t) (inter_subset_left _ _)
      ... ‚â§ g s t                        : hg‚ÇÅ s (inter_subset_right _ _))

lemma lift_principal {s : set Œ±} (hg : monotone g) :
  (ùìü s).lift g = g s :=
le_antisymm
  (infi_le_of_le s $ infi_le _ $ subset.refl _)
  (le_infi $ assume t, le_infi $ assume hi, hg hi)

theorem monotone_lift [preorder Œ≥] {f : Œ≥ ‚Üí filter Œ±} {g : Œ≥ ‚Üí set Œ± ‚Üí filter Œ≤}
  (hf : monotone f) (hg : monotone g) : monotone (Œªc, (f c).lift (g c)) :=
assume a b h, lift_mono (hf h) (hg h)

lemma lift_ne_bot_iff (hm : monotone g) : (ne_bot $ f.lift g) ‚Üî (‚àÄs‚ààf, ne_bot (g s)) :=
begin
  rw [filter.lift, infi_subtype', infi_ne_bot_iff_of_directed', subtype.forall'],
  { rintros ‚ü®s, hs‚ü© ‚ü®t, ht‚ü©,
    exact ‚ü®‚ü®s ‚à© t, inter_mem hs ht‚ü©, hm (inter_subset_left s t), hm (inter_subset_right s t)‚ü© }
end

@[simp] lemma lift_const {f : filter Œ±} {g : filter Œ≤} : f.lift (Œªx, g) = g :=
le_antisymm (lift_le univ_mem $ le_refl g) (le_lift $ assume s hs, le_refl g)

@[simp] lemma lift_inf {f : filter Œ±} {g h : set Œ± ‚Üí filter Œ≤} :
  f.lift (Œªx, g x ‚äì h x) = f.lift g ‚äì f.lift h :=
by simp only [filter.lift, infi_inf_eq, eq_self_iff_true]

@[simp] lemma lift_principal2 {f : filter Œ±} : f.lift ùìü = f :=
le_antisymm
  (assume s hs, mem_lift hs (mem_principal_self s))
  (le_infi $ assume s, le_infi $ assume hs, by simp only [hs, le_principal_iff])

lemma lift_infi {f : Œπ ‚Üí filter Œ±} {g : set Œ± ‚Üí filter Œ≤}
  [hŒπ : nonempty Œπ] (hg : ‚àÄ{s t}, g s ‚äì g t = g (s ‚à© t)) : (infi f).lift g = (‚®Öi, (f i).lift g) :=
le_antisymm
  (le_infi $ assume i, lift_mono (infi_le _ _) le_rfl)
  (assume s,
    have g_mono : monotone g,
      from assume s t h, le_of_inf_eq $ eq.trans hg $ congr_arg g $ inter_eq_self_of_subset_left h,
    have ‚àÄt‚àà(infi f), (‚®Ö (i : Œπ), filter.lift (f i) g) ‚â§ g t,
      from assume t ht, infi_sets_induct ht
        (let ‚ü®i‚ü© := hŒπ in infi_le_of_le i $ infi_le_of_le univ $ infi_le _ univ_mem)
        (assume i s‚ÇÅ s‚ÇÇ hs‚ÇÅ hs‚ÇÇ,
          @hg s‚ÇÅ s‚ÇÇ ‚ñ∏ le_inf (infi_le_of_le i $ infi_le_of_le s‚ÇÅ $ infi_le _ hs‚ÇÅ) hs‚ÇÇ),
    begin
      simp only [mem_lift_sets g_mono,  exists_imp_distrib],
      exact assume t ht hs, this t ht hs
    end)

end lift

section lift'
/-- Specialize `lift` to functions `set Œ± ‚Üí set Œ≤`. This can be viewed as a generalization of `map`.
This is essentially a push-forward along a function mapping each set to a set. -/
protected def lift' (f : filter Œ±) (h : set Œ± ‚Üí set Œ≤) :=
f.lift (ùìü ‚àò h)

variables {f f‚ÇÅ f‚ÇÇ : filter Œ±} {h h‚ÇÅ h‚ÇÇ : set Œ± ‚Üí set Œ≤}

@[simp] lemma lift'_top (h : set Œ± ‚Üí set Œ≤) : (‚ä§ : filter Œ±).lift' h = ùìü (h univ) :=
lift_top _

lemma mem_lift' {t : set Œ±} (ht : t ‚àà f) : h t ‚àà (f.lift' h) :=
le_principal_iff.mp $ show f.lift' h ‚â§ ùìü (h t),
  from infi_le_of_le t $ infi_le_of_le ht $ le_rfl

lemma tendsto_lift' {m : Œ≥ ‚Üí Œ≤} {l : filter Œ≥} :
  tendsto m l (f.lift' h) ‚Üî ‚àÄ s ‚àà f, ‚àÄ·∂† a in l, m a ‚àà h s :=
by simp only [filter.lift', tendsto_lift, tendsto_principal]

lemma has_basis.lift' {Œπ} {p : Œπ ‚Üí Prop} {s} (hf : f.has_basis p s) (hh : monotone h) :
  (f.lift' h).has_basis p (h ‚àò s) :=
begin
  refine ‚ü®Œª t, (hf.mem_lift_iff _ (monotone_principal.comp hh)).trans _‚ü©,
  show ‚àÄ i, (ùìü (h (s i))).has_basis (Œª j : unit, true) (Œª (j : unit), h (s i)),
    from Œª i, has_basis_principal _,
  simp only [exists_const]
end

lemma mem_lift'_sets (hh : monotone h) {s : set Œ≤} : s ‚àà (f.lift' h) ‚Üî (‚àÉt‚ààf, h t ‚äÜ s) :=
mem_lift_sets $ monotone_principal.comp hh

lemma eventually_lift'_iff (hh : monotone h) {p : Œ≤ ‚Üí Prop} :
  (‚àÄ·∂† y in f.lift' h, p y) ‚Üî (‚àÉ t ‚àà f, ‚àÄ y ‚àà h t, p y) :=
mem_lift'_sets hh

lemma lift'_le {f : filter Œ±} {g : set Œ± ‚Üí set Œ≤} {h : filter Œ≤} {s : set Œ±}
  (hs : s ‚àà f) (hg : ùìü (g s) ‚â§ h) : f.lift' g ‚â§ h :=
lift_le hs hg

lemma lift'_mono (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hh : h‚ÇÅ ‚â§ h‚ÇÇ) : f‚ÇÅ.lift' h‚ÇÅ ‚â§ f‚ÇÇ.lift' h‚ÇÇ :=
lift_mono hf $ assume s, principal_mono.mpr $ hh s

lemma lift'_mono' (hh : ‚àÄs‚ààf, h‚ÇÅ s ‚äÜ h‚ÇÇ s) : f.lift' h‚ÇÅ ‚â§ f.lift' h‚ÇÇ :=
infi_le_infi $ assume s, infi_le_infi $ assume hs, principal_mono.mpr $ hh s hs

lemma lift'_cong (hh : ‚àÄs‚ààf, h‚ÇÅ s = h‚ÇÇ s) : f.lift' h‚ÇÅ = f.lift' h‚ÇÇ :=
le_antisymm (lift'_mono' $ assume s hs, le_of_eq $ hh s hs)
  (lift'_mono' $ assume s hs, le_of_eq $ (hh s hs).symm)

lemma map_lift'_eq {m : Œ≤ ‚Üí Œ≥} (hh : monotone h) : map m (f.lift' h) = f.lift' (image m ‚àò h) :=
calc map m (f.lift' h) = f.lift (map m ‚àò ùìü ‚àò h) :
    map_lift_eq $ monotone_principal.comp hh
  ... = f.lift' (image m ‚àò h) : by simp only [(‚àò), filter.lift', map_principal, eq_self_iff_true]

lemma map_lift'_eq2 {g : set Œ≤ ‚Üí set Œ≥} {m : Œ± ‚Üí Œ≤} (hg : monotone g) :
  (map m f).lift' g = f.lift' (g ‚àò image m) :=
map_lift_eq2 $ monotone_principal.comp hg

theorem comap_lift'_eq {m : Œ≥ ‚Üí Œ≤} (hh : monotone h) :
  comap m (f.lift' h) = f.lift' (preimage m ‚àò h) :=
calc comap m (f.lift' h) = f.lift (comap m ‚àò ùìü ‚àò h) :
    comap_lift_eq $ monotone_principal.comp hh
  ... = f.lift' (preimage m ‚àò h) :
    by simp only [(‚àò), filter.lift', comap_principal, eq_self_iff_true]

theorem comap_lift'_eq2 {m : Œ≤ ‚Üí Œ±} {g : set Œ≤ ‚Üí set Œ≥} (hg : monotone g) :
  (comap m f).lift' g = f.lift' (g ‚àò preimage m) :=
comap_lift_eq2 $ monotone_principal.comp hg

lemma lift'_principal {s : set Œ±} (hh : monotone h) :
  (ùìü s).lift' h = ùìü (h s) :=
lift_principal $ monotone_principal.comp hh

lemma lift'_pure {a : Œ±} (hh : monotone h) :
  (pure a : filter Œ±).lift' h = ùìü (h {a}) :=
by rw [‚Üê principal_singleton, lift'_principal hh]

lemma lift'_bot (hh : monotone h) : (‚ä• : filter Œ±).lift' h = ùìü (h ‚àÖ) :=
by rw [‚Üê principal_empty, lift'_principal hh]

lemma principal_le_lift' {t : set Œ≤} (hh : ‚àÄs‚ààf, t ‚äÜ h s) :
  ùìü t ‚â§ f.lift' h :=
le_infi $ assume s, le_infi $ assume hs, principal_mono.mpr (hh s hs)

theorem monotone_lift' [preorder Œ≥] {f : Œ≥ ‚Üí filter Œ±} {g : Œ≥ ‚Üí set Œ± ‚Üí set Œ≤}
  (hf : monotone f) (hg : monotone g) : monotone (Œªc, (f c).lift' (g c)) :=
assume a b h, lift'_mono (hf h) (hg h)

lemma lift_lift'_assoc {g : set Œ± ‚Üí set Œ≤} {h : set Œ≤ ‚Üí filter Œ≥}
  (hg : monotone g) (hh : monotone h) :
  (f.lift' g).lift h = f.lift (Œªs, h (g s)) :=
calc (f.lift' g).lift h = f.lift (Œªs, (ùìü (g s)).lift h) :
    lift_assoc (monotone_principal.comp hg)
  ... = f.lift (Œªs, h (g s)) : by simp only [lift_principal, hh, eq_self_iff_true]

lemma lift'_lift'_assoc {g : set Œ± ‚Üí set Œ≤} {h : set Œ≤ ‚Üí set Œ≥}
  (hg : monotone g) (hh : monotone h) :
  (f.lift' g).lift' h = f.lift' (Œªs, h (g s)) :=
lift_lift'_assoc hg (monotone_principal.comp hh)

lemma lift'_lift_assoc {g : set Œ± ‚Üí filter Œ≤} {h : set Œ≤ ‚Üí set Œ≥}
  (hg : monotone g) : (f.lift g).lift' h = f.lift (Œªs, (g s).lift' h) :=
lift_assoc hg

lemma lift_lift'_same_le_lift' {g : set Œ± ‚Üí set Œ± ‚Üí set Œ≤} :
  f.lift (Œªs, f.lift' (g s)) ‚â§ f.lift' (Œªs, g s s) :=
lift_lift_same_le_lift

lemma lift_lift'_same_eq_lift' {g : set Œ± ‚Üí set Œ± ‚Üí set Œ≤}
  (hg‚ÇÅ : ‚àÄs, monotone (Œªt, g s t)) (hg‚ÇÇ : ‚àÄt, monotone (Œªs, g s t)) :
  f.lift (Œªs, f.lift' (g s)) = f.lift' (Œªs, g s s) :=
lift_lift_same_eq_lift
  (assume s, monotone_principal.comp (hg‚ÇÅ s))
  (assume t, monotone_principal.comp (hg‚ÇÇ t))

lemma lift'_inf_principal_eq {h : set Œ± ‚Üí set Œ≤} {s : set Œ≤} :
  f.lift' h ‚äì ùìü s = f.lift' (Œªt, h t ‚à© s) :=
by simp only [filter.lift', filter.lift, (‚àò), ‚Üê inf_principal, infi_subtype', ‚Üê infi_inf]

lemma lift'_ne_bot_iff (hh : monotone h) : (ne_bot (f.lift' h)) ‚Üî (‚àÄs‚ààf, (h s).nonempty) :=
calc (ne_bot (f.lift' h)) ‚Üî (‚àÄs‚ààf, ne_bot (ùìü (h s))) :
    lift_ne_bot_iff (monotone_principal.comp hh)
  ... ‚Üî (‚àÄs‚ààf, (h s).nonempty) : by simp only [principal_ne_bot_iff]

@[simp] lemma lift'_id {f : filter Œ±} : f.lift' id = f :=
lift_principal2

lemma le_lift' {f : filter Œ±} {h : set Œ± ‚Üí set Œ≤} {g : filter Œ≤}
  (h_le : ‚àÄs‚ààf, h s ‚àà g) : g ‚â§ f.lift' h :=
le_infi $ assume s, le_infi $ assume hs,
  by simpa only [h_le, le_principal_iff, function.comp_app] using h_le s hs

lemma lift_infi' {f : Œπ ‚Üí filter Œ±} {g : set Œ± ‚Üí filter Œ≤}
  [nonempty Œπ] (hf : directed (‚â•) f) (hg : monotone g) : (infi f).lift g = (‚®Öi, (f i).lift g) :=
le_antisymm
  (le_infi $ assume i, lift_mono (infi_le _ _) le_rfl)
  (assume s,
  begin
    rw mem_lift_sets hg,
    simp only [exists_imp_distrib, mem_infi_of_directed hf],
    exact assume t i ht hs, mem_infi_of_mem i $ mem_lift ht hs
  end)

lemma lift'_infi {f : Œπ ‚Üí filter Œ±} {g : set Œ± ‚Üí set Œ≤}
  [nonempty Œπ] (hg : ‚àÄ{s t}, g s ‚à© g t = g (s ‚à© t)) : (infi f).lift' g = (‚®Öi, (f i).lift' g) :=
lift_infi $ Œª s t, by simp only [principal_eq_iff_eq, inf_principal, (‚àò), hg]

lemma lift'_inf (f g : filter Œ±) {s : set Œ± ‚Üí set Œ≤} (hs : ‚àÄ {t‚ÇÅ t‚ÇÇ}, s t‚ÇÅ ‚à© s t‚ÇÇ = s (t‚ÇÅ ‚à© t‚ÇÇ)) :
  (f ‚äì g).lift' s = f.lift' s ‚äì g.lift' s :=
have (‚®Ö b : bool, cond b f g).lift' s = ‚®Ö b : bool, (cond b f g).lift' s :=
  lift'_infi @hs,
by simpa only [infi_bool_eq]

theorem comap_eq_lift' {f : filter Œ≤} {m : Œ± ‚Üí Œ≤} :
  comap m f = f.lift' (preimage m) :=
filter.ext $ Œª s, (mem_lift'_sets monotone_preimage).symm

lemma lift'_infi_powerset {f : Œπ ‚Üí filter Œ±} :
  (infi f).lift' powerset = (‚®Öi, (f i).lift' powerset) :=
begin
  casesI is_empty_or_nonempty Œπ,
  { rw [infi_of_empty f, infi_of_empty, lift'_top, powerset_univ, principal_univ] },
  { exact (lift'_infi $ Œª _ _, (powerset_inter _ _).symm) },
end

lemma lift'_inf_powerset (f g : filter Œ±) :
  (f ‚äì g).lift' powerset = f.lift' powerset ‚äì g.lift' powerset :=
lift'_inf f g $ Œª _ _, (powerset_inter _ _).symm

lemma eventually_lift'_powerset {f : filter Œ±} {p : set Œ± ‚Üí Prop} :
  (‚àÄ·∂† s in f.lift' powerset, p s) ‚Üî ‚àÉ s ‚àà f, ‚àÄ t ‚äÜ s, p t :=
eventually_lift'_iff monotone_powerset

lemma eventually_lift'_powerset' {f : filter Œ±} {p : set Œ± ‚Üí Prop}
  (hp : ‚àÄ ‚¶És t‚¶Ñ, s ‚äÜ t ‚Üí p t ‚Üí p s) :
  (‚àÄ·∂† s in f.lift' powerset, p s) ‚Üî ‚àÉ s ‚àà f, p s :=
eventually_lift'_powerset.trans $ exists‚ÇÇ_congr $ Œª s hsf,
  ‚ü®Œª H, H s (subset.refl s), Œª hs t ht, hp ht hs‚ü©

instance lift'_powerset_ne_bot (f : filter Œ±) : ne_bot (f.lift' powerset) :=
(lift'_ne_bot_iff monotone_powerset).2 $ Œª _ _, powerset_nonempty

lemma tendsto_lift'_powerset_mono {la : filter Œ±} {lb : filter Œ≤} {s t : Œ± ‚Üí set Œ≤}
  (ht : tendsto t la (lb.lift' powerset)) (hst : ‚àÄ·∂† x in la, s x ‚äÜ t x) :
  tendsto s la (lb.lift' powerset) :=
begin
  simp only [filter.lift', filter.lift, (‚àò), tendsto_infi, tendsto_principal] at ht ‚ä¢,
  exact Œª u hu, (ht u hu).mp (hst.mono $ Œª a hst ht, subset.trans hst ht)
end

@[simp] lemma eventually_lift'_powerset_forall {f : filter Œ±} {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂† s in f.lift' powerset, ‚àÄ x ‚àà s, p x) ‚Üî ‚àÄ·∂† x in f, p x :=
iff.trans (eventually_lift'_powerset' $ Œª s t hst ht x hx, ht x (hst hx))
  exists_mem_subset_iff

alias eventually_lift'_powerset_forall ‚Üî
  filter.eventually.of_lift'_powerset filter.eventually.lift'_powerset

@[simp] lemma eventually_lift'_powerset_eventually {f g : filter Œ±} {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂† s in f.lift' powerset, ‚àÄ·∂† x in g, x ‚àà s ‚Üí p x) ‚Üî ‚àÄ·∂† x in f ‚äì g, p x :=
calc _ ‚Üî ‚àÉ s ‚àà f, ‚àÄ·∂† x in g, x ‚àà s ‚Üí p x :
  eventually_lift'_powerset' $ Œª s t hst ht, ht.mono $ Œª x hx hs, hx (hst hs)
... ‚Üî ‚àÉ (s ‚àà f) (t ‚àà g), ‚àÄ x, x ‚àà t ‚Üí x ‚àà s ‚Üí p x :
  by simp only [eventually_iff_exists_mem]
... ‚Üî ‚àÄ·∂† x in f ‚äì g, p x : by simp only [eventually_inf, and_comm, mem_inter_iff, ‚Üêand_imp]

end lift'

section prod
variables {f : filter Œ±}

lemma prod_def {f : filter Œ±} {g : filter Œ≤} : f √ó·∂† g = (f.lift $ Œª s, g.lift' $ Œª t, s √óÀ¢ t) :=
have ‚àÄ(s:set Œ±) (t : set Œ≤),
    ùìü (s √óÀ¢ t) = (ùìü s).comap prod.fst ‚äì (ùìü t).comap prod.snd,
  by simp only [principal_eq_iff_eq, comap_principal, inf_principal]; intros; refl,
begin
  simp only [filter.lift', function.comp, this, lift_inf, lift_const, lift_inf],
  rw [‚Üê comap_lift_eq monotone_principal, ‚Üê comap_lift_eq monotone_principal],
  simp only [filter.prod, lift_principal2, eq_self_iff_true]
end

lemma prod_same_eq : f √ó·∂† f = f.lift' (Œª t : set Œ±, t √óÀ¢ t) :=
by rw [prod_def];
from lift_lift'_same_eq_lift'
  (assume s, set.monotone_prod monotone_const monotone_id)
  (assume t, set.monotone_prod monotone_id monotone_const)

lemma mem_prod_same_iff {s : set (Œ±√óŒ±)} :
  s ‚àà f √ó·∂† f ‚Üî (‚àÉt‚ààf, t √óÀ¢ t ‚äÜ s) :=
by rw [prod_same_eq, mem_lift'_sets]; exact set.monotone_prod monotone_id monotone_id

lemma tendsto_prod_self_iff {f : Œ± √ó Œ± ‚Üí Œ≤} {x : filter Œ±} {y : filter Œ≤} :
  filter.tendsto f (x √ó·∂† x) y ‚Üî
  ‚àÄ W ‚àà y, ‚àÉ U ‚àà x, ‚àÄ (x x' : Œ±), x ‚àà U ‚Üí x' ‚àà U ‚Üí f (x, x') ‚àà W :=
by simp only [tendsto_def, mem_prod_same_iff, prod_sub_preimage_iff, exists_prop, iff_self]

variables {Œ±‚ÇÅ : Type*} {Œ±‚ÇÇ : Type*} {Œ≤‚ÇÅ : Type*} {Œ≤‚ÇÇ : Type*}

lemma prod_lift_lift
  {f‚ÇÅ : filter Œ±‚ÇÅ} {f‚ÇÇ : filter Œ±‚ÇÇ} {g‚ÇÅ : set Œ±‚ÇÅ ‚Üí filter Œ≤‚ÇÅ} {g‚ÇÇ : set Œ±‚ÇÇ ‚Üí filter Œ≤‚ÇÇ}
  (hg‚ÇÅ : monotone g‚ÇÅ) (hg‚ÇÇ : monotone g‚ÇÇ) :
  (f‚ÇÅ.lift g‚ÇÅ) √ó·∂† (f‚ÇÇ.lift g‚ÇÇ) = f‚ÇÅ.lift (Œªs, f‚ÇÇ.lift (Œªt, g‚ÇÅ s √ó·∂† g‚ÇÇ t)) :=
begin
  simp only [prod_def],
  rw [lift_assoc],
  apply congr_arg, funext x,
  rw [lift_comm],
  apply congr_arg, funext y,
  rw [lift'_lift_assoc],
  exact hg‚ÇÇ,
  exact hg‚ÇÅ
end

lemma prod_lift'_lift'
  {f‚ÇÅ : filter Œ±‚ÇÅ} {f‚ÇÇ : filter Œ±‚ÇÇ} {g‚ÇÅ : set Œ±‚ÇÅ ‚Üí set Œ≤‚ÇÅ} {g‚ÇÇ : set Œ±‚ÇÇ ‚Üí set Œ≤‚ÇÇ}
  (hg‚ÇÅ : monotone g‚ÇÅ) (hg‚ÇÇ : monotone g‚ÇÇ) :
  f‚ÇÅ.lift' g‚ÇÅ √ó·∂† f‚ÇÇ.lift' g‚ÇÇ = f‚ÇÅ.lift (Œªs, f‚ÇÇ.lift' (Œªt, g‚ÇÅ s √óÀ¢ g‚ÇÇ t)) :=
begin
  rw [prod_def, lift_lift'_assoc],
  apply congr_arg, funext x,
  rw [lift'_lift'_assoc],
  exact hg‚ÇÇ,
  exact set.monotone_prod monotone_const monotone_id,
  exact hg‚ÇÅ,
  exact (monotone_lift' monotone_const $ monotone_lam $
    assume x, set.monotone_prod monotone_id monotone_const)
end

end prod

end filter
