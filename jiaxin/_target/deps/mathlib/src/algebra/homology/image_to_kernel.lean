/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import category_theory.subobject.limits

/-!
# Image-to-kernel comparison maps

Whenever `f : A ‚ü∂ B` and `g : B ‚ü∂ C` satisfy `w : f ‚â´ g = 0`,
we have `image_le_kernel f g w : image_subobject f ‚â§ kernel_subobject g`
(assuming the appropriate images and kernels exist).

`image_to_kernel f g w` is the corresponding morphism between objects in `C`.

We define `homology f g w` of such a pair as the cokernel of `image_to_kernel f g w`.
-/

universes v u

open category_theory category_theory.limits

variables {Œπ : Type*}
variables {V : Type u} [category.{v} V] [has_zero_morphisms V]

open_locale classical
noncomputable theory

section
variables {A B C : V} (f : A ‚ü∂ B) [has_image f] (g : B ‚ü∂ C) [has_kernel g]

lemma image_le_kernel (w : f ‚â´ g = 0) :
  image_subobject f ‚â§ kernel_subobject g :=
image_subobject_le_mk _ _ (kernel.lift _ _ w) (by simp)

/--
The canonical morphism `image_subobject f ‚ü∂ kernel_subobject g` when `f ‚â´ g = 0`.
-/
@[derive mono]
def image_to_kernel (w : f ‚â´ g = 0) :
  (image_subobject f : V) ‚ü∂ (kernel_subobject g : V) :=
(subobject.of_le _ _ (image_le_kernel _ _ w))

/-- Prefer `image_to_kernel`. -/
@[simp] lemma subobject_of_le_as_image_to_kernel (w : f ‚â´ g = 0) (h) :
  subobject.of_le (image_subobject f) (kernel_subobject g) h = image_to_kernel f g w :=
rfl

@[simp, reassoc]
lemma image_to_kernel_arrow (w : f ‚â´ g = 0) :
  image_to_kernel f g w ‚â´ (kernel_subobject g).arrow = (image_subobject f).arrow :=
by simp [image_to_kernel]

-- This is less useful as a `simp` lemma than it initially appears,
-- as it "loses" the information the morphism factors through the image.
lemma factor_thru_image_subobject_comp_image_to_kernel (w : f ‚â´ g = 0) :
  factor_thru_image_subobject f ‚â´ image_to_kernel f g w = factor_thru_kernel_subobject g f w :=
by { ext, simp, }

end

section
variables {A B C : V} (f : A ‚ü∂ B) (g : B ‚ü∂ C)

@[simp]
lemma image_to_kernel_zero_left [has_kernels V] [has_zero_object V] {w} :
  image_to_kernel (0 : A ‚ü∂ B) g w = 0 :=
by { ext, simp, }

lemma image_to_kernel_zero_right [has_images V] {w} :
  image_to_kernel f (0 : B ‚ü∂ C) w =
    (image_subobject f).arrow ‚â´ inv (kernel_subobject (0 : B ‚ü∂ C)).arrow :=
by { ext, simp }

section
variables [has_kernels V] [has_images V]

lemma image_to_kernel_comp_right {D : V} (h : C ‚ü∂ D) (w : f ‚â´ g = 0) :
  image_to_kernel f (g ‚â´ h) (by simp [reassoc_of w]) =
    image_to_kernel f g w ‚â´ subobject.of_le _ _ (kernel_subobject_comp_le g h) :=
by { ext, simp }

lemma image_to_kernel_comp_left {Z : V} (h : Z ‚ü∂ A) (w : f ‚â´ g = 0) :
  image_to_kernel (h ‚â´ f) g (by simp [w]) =
    subobject.of_le _ _ (image_subobject_comp_le h f) ‚â´ image_to_kernel f g w :=
by { ext, simp }

@[simp]
lemma image_to_kernel_comp_mono {D : V} (h : C ‚ü∂ D) [mono h] (w) :
  image_to_kernel f (g ‚â´ h) w =
  image_to_kernel f g ((cancel_mono h).mp (by simpa using w : (f ‚â´ g) ‚â´ h = 0 ‚â´ h)) ‚â´
    (subobject.iso_of_eq _ _ (kernel_subobject_comp_mono g h)).inv :=
by { ext, simp, }

@[simp]
lemma image_to_kernel_epi_comp {Z : V} (h : Z ‚ü∂ A) [epi h] (w) :
  image_to_kernel (h ‚â´ f) g w =
  subobject.of_le _ _ (image_subobject_comp_le h f) ‚â´
    image_to_kernel f g ((cancel_epi h).mp (by simpa using w : h ‚â´ f ‚â´ g = h ‚â´ 0)) :=
by { ext, simp, }

end

@[simp]
lemma image_to_kernel_comp_hom_inv_comp [has_equalizers V] [has_images V] {Z : V} {i : B ‚âÖ Z} (w) :
  image_to_kernel (f ‚â´ i.hom) (i.inv ‚â´ g) w =
  (image_subobject_comp_iso _ _).hom ‚â´ image_to_kernel f g (by simpa using w) ‚â´
    (kernel_subobject_iso_comp i.inv g).inv :=
by { ext, simp, }

open_locale zero_object

/--
`image_to_kernel` for `A --0--> B --g--> C`, where `g` is a mono is itself an epi
(i.e. the sequence is exact at `B`).
-/
instance image_to_kernel_epi_of_zero_of_mono [has_kernels V] [has_zero_object V] [mono g] :
  epi (image_to_kernel (0 : A ‚ü∂ B) g (by simp)) :=
epi_of_target_iso_zero _ (kernel_subobject_iso g ‚â™‚â´ kernel.of_mono g)

/--
`image_to_kernel` for `A --f--> B --0--> C`, where `g` is an epi is itself an epi
(i.e. the sequence is exact at `B`).
-/
instance image_to_kernel_epi_of_epi_of_zero [has_images V] [epi f] :
  epi (image_to_kernel f (0 : B ‚ü∂ C) (by simp)) :=
begin
  simp only [image_to_kernel_zero_right],
  haveI := epi_image_of_epi f,
  rw ‚Üêimage_subobject_arrow,
  refine @epi_comp _ _ _ _ _ _ (epi_comp _ _) _ _,
end

end

section
variables {A B C : V} (f : A ‚ü∂ B) [has_image f] (g : B ‚ü∂ C) [has_kernel g]

/--
The homology of a pair of morphisms `f : A ‚ü∂ B` and `g : B ‚ü∂ C` satisfying `f ‚â´ g = 0`
is the cokernel of the `image_to_kernel` morphism for `f` and `g`.
-/
def homology {A B C : V} (f : A ‚ü∂ B) [has_image f] (g : B ‚ü∂ C) [has_kernel g]
  (w : f ‚â´ g = 0) [has_cokernel (image_to_kernel f g w)] : V :=
cokernel (image_to_kernel f g w)

section
variables (w : f ‚â´ g = 0) [has_cokernel (image_to_kernel f g w)]

/-- The morphism from cycles to homology. -/
def homology.œÄ : (kernel_subobject g : V) ‚ü∂ homology f g w :=
cokernel.œÄ _

@[simp] lemma homology.condition : image_to_kernel f g w ‚â´ homology.œÄ f g w = 0 :=
cokernel.condition _

/--
To construct a map out of homology, it suffices to construct a map out of the cycles
which vanishes on boundaries.
-/
def homology.desc {D : V} (k : (kernel_subobject g : V) ‚ü∂ D) (p : image_to_kernel f g w ‚â´ k = 0) :
  homology f g w ‚ü∂ D :=
cokernel.desc _ k p

@[simp, reassoc]
lemma homology.œÄ_desc
  {D : V} (k : (kernel_subobject g : V) ‚ü∂ D) (p : image_to_kernel f g w ‚â´ k = 0) :
  homology.œÄ f g w ‚â´ homology.desc f g w k p = k :=
by { simp [homology.œÄ, homology.desc], }

/-- To check two morphisms out of `homology f g w` are equal, it suffices to check on cycles. -/
@[ext]
lemma homology.ext {D : V} {k k' : homology f g w ‚ü∂ D}
  (p : homology.œÄ f g w ‚â´ k = homology.œÄ f g w ‚â´ k') : k = k' :=
by { ext, exact p, }

/-- `homology 0 0 _` is just the middle object. -/
@[simps]
def homology_zero_zero [has_zero_object V]
  [has_image (0 : A ‚ü∂ B)] [has_cokernel (image_to_kernel (0 : A ‚ü∂ B) (0 : B ‚ü∂ C) (by simp))] :
  homology (0 : A ‚ü∂ B) (0 : B ‚ü∂ C) (by simp) ‚âÖ B :=
{ hom := homology.desc (0 : A ‚ü∂ B) (0 : B ‚ü∂ C) (by simp) (kernel_subobject 0).arrow (by simp),
  inv := inv (kernel_subobject 0).arrow ‚â´ homology.œÄ _ _ _, }

end

section
variables {f g} (w : f ‚â´ g = 0)
  {A' B' C' : V} {f' : A' ‚ü∂ B'} [has_image f'] {g' : B' ‚ü∂ C'} [has_kernel g'] (w' : f' ‚â´ g' = 0)
  (Œ± : arrow.mk f ‚ü∂ arrow.mk f') [has_image_map Œ±] (Œ≤ : arrow.mk g ‚ü∂ arrow.mk g')
  {A‚ÇÅ B‚ÇÅ C‚ÇÅ : V} {f‚ÇÅ : A‚ÇÅ ‚ü∂ B‚ÇÅ} [has_image f‚ÇÅ] {g‚ÇÅ : B‚ÇÅ ‚ü∂ C‚ÇÅ} [has_kernel g‚ÇÅ] (w‚ÇÅ : f‚ÇÅ ‚â´ g‚ÇÅ = 0)
  {A‚ÇÇ B‚ÇÇ C‚ÇÇ : V} {f‚ÇÇ : A‚ÇÇ ‚ü∂ B‚ÇÇ} [has_image f‚ÇÇ] {g‚ÇÇ : B‚ÇÇ ‚ü∂ C‚ÇÇ} [has_kernel g‚ÇÇ] (w‚ÇÇ : f‚ÇÇ ‚â´ g‚ÇÇ = 0)
  {A‚ÇÉ B‚ÇÉ C‚ÇÉ : V} {f‚ÇÉ : A‚ÇÉ ‚ü∂ B‚ÇÉ} [has_image f‚ÇÉ] {g‚ÇÉ : B‚ÇÉ ‚ü∂ C‚ÇÉ} [has_kernel g‚ÇÉ] (w‚ÇÉ : f‚ÇÉ ‚â´ g‚ÇÉ = 0)
  (Œ±‚ÇÅ : arrow.mk f‚ÇÅ ‚ü∂ arrow.mk f‚ÇÇ) [has_image_map Œ±‚ÇÅ] (Œ≤‚ÇÅ : arrow.mk g‚ÇÅ ‚ü∂ arrow.mk g‚ÇÇ)
  (Œ±‚ÇÇ : arrow.mk f‚ÇÇ ‚ü∂ arrow.mk f‚ÇÉ) [has_image_map Œ±‚ÇÇ] (Œ≤‚ÇÇ : arrow.mk g‚ÇÇ ‚ü∂ arrow.mk g‚ÇÉ)

/--
Given compatible commutative squares between
a pair `f g` and a pair `f' g'` satisfying `f ‚â´ g = 0` and `f' ‚â´ g' = 0`,
the `image_to_kernel` morphisms intertwine the induced map on kernels and the induced map on images.
-/
@[reassoc]
lemma image_subobject_map_comp_image_to_kernel (p : Œ±.right = Œ≤.left) :
  image_to_kernel f g w ‚â´ kernel_subobject_map Œ≤ =
    image_subobject_map Œ± ‚â´ image_to_kernel f' g' w' :=
by { ext, simp [p], }

variables [has_cokernel (image_to_kernel f g w)] [has_cokernel (image_to_kernel f' g' w')]
variables [has_cokernel (image_to_kernel f‚ÇÅ g‚ÇÅ w‚ÇÅ)]
variables [has_cokernel (image_to_kernel f‚ÇÇ g‚ÇÇ w‚ÇÇ)]
variables [has_cokernel (image_to_kernel f‚ÇÉ g‚ÇÉ w‚ÇÉ)]

/--
Given compatible commutative squares between
a pair `f g` and a pair `f' g'` satisfying `f ‚â´ g = 0` and `f' ‚â´ g' = 0`,
we get a morphism on homology.
-/
def homology.map (p : Œ±.right = Œ≤.left) :
  homology f g w ‚ü∂ homology f' g' w' :=
cokernel.desc _ (kernel_subobject_map Œ≤ ‚â´ cokernel.œÄ _)
  begin
    rw [image_subobject_map_comp_image_to_kernel_assoc w w' Œ± Œ≤ p],
    simp only [cokernel.condition, comp_zero],
  end

@[simp, reassoc]
lemma homology.œÄ_map (p : Œ±.right = Œ≤.left) :
  homology.œÄ f g w ‚â´ homology.map w w' Œ± Œ≤ p = kernel_subobject_map Œ≤ ‚â´ homology.œÄ f' g' w' :=
by simp only [homology.œÄ, homology.map, cokernel.œÄ_desc]

@[simp, reassoc]
lemma homology.map_desc (p : Œ±.right = Œ≤.left)
  {D : V} (k : (kernel_subobject g' : V) ‚ü∂ D) (z : image_to_kernel f' g' w' ‚â´ k = 0) :
  homology.map w w' Œ± Œ≤ p ‚â´ homology.desc f' g' w' k z =
    homology.desc f g w (kernel_subobject_map Œ≤ ‚â´ k)
      (by simp only [image_subobject_map_comp_image_to_kernel_assoc w w' Œ± Œ≤ p, z, comp_zero]) :=
by ext; simp only [homology.œÄ_desc, homology.œÄ_map_assoc]

@[simp]
lemma homology.map_id : homology.map w w (ùüô _) (ùüô _) rfl = ùüô _ :=
by ext; simp only [homology.œÄ_map, kernel_subobject_map_id, category.id_comp, category.comp_id]

/-- Auxiliary lemma for homology computations. -/
lemma homology.comp_right_eq_comp_left
  {V : Type*} [category V] {A‚ÇÅ B‚ÇÅ C‚ÇÅ A‚ÇÇ B‚ÇÇ C‚ÇÇ A‚ÇÉ B‚ÇÉ C‚ÇÉ : V}
  {f‚ÇÅ : A‚ÇÅ ‚ü∂ B‚ÇÅ} {g‚ÇÅ : B‚ÇÅ ‚ü∂ C‚ÇÅ} {f‚ÇÇ : A‚ÇÇ ‚ü∂ B‚ÇÇ} {g‚ÇÇ : B‚ÇÇ ‚ü∂ C‚ÇÇ} {f‚ÇÉ : A‚ÇÉ ‚ü∂ B‚ÇÉ} {g‚ÇÉ : B‚ÇÉ ‚ü∂ C‚ÇÉ}
  {Œ±‚ÇÅ : arrow.mk f‚ÇÅ ‚ü∂ arrow.mk f‚ÇÇ} {Œ≤‚ÇÅ : arrow.mk g‚ÇÅ ‚ü∂ arrow.mk g‚ÇÇ}
  {Œ±‚ÇÇ : arrow.mk f‚ÇÇ ‚ü∂ arrow.mk f‚ÇÉ} {Œ≤‚ÇÇ : arrow.mk g‚ÇÇ ‚ü∂ arrow.mk g‚ÇÉ}
  (p‚ÇÅ : Œ±‚ÇÅ.right = Œ≤‚ÇÅ.left) (p‚ÇÇ : Œ±‚ÇÇ.right = Œ≤‚ÇÇ.left) :
  (Œ±‚ÇÅ ‚â´ Œ±‚ÇÇ).right = (Œ≤‚ÇÅ ‚â´ Œ≤‚ÇÇ).left :=
by simp only [comma.comp_left, comma.comp_right, p‚ÇÅ, p‚ÇÇ]

@[reassoc]
lemma homology.map_comp (p‚ÇÅ : Œ±‚ÇÅ.right = Œ≤‚ÇÅ.left) (p‚ÇÇ : Œ±‚ÇÇ.right = Œ≤‚ÇÇ.left) :
  homology.map w‚ÇÅ w‚ÇÇ Œ±‚ÇÅ Œ≤‚ÇÅ p‚ÇÅ ‚â´ homology.map w‚ÇÇ w‚ÇÉ Œ±‚ÇÇ Œ≤‚ÇÇ p‚ÇÇ =
    homology.map w‚ÇÅ w‚ÇÉ (Œ±‚ÇÅ ‚â´ Œ±‚ÇÇ) (Œ≤‚ÇÅ ‚â´ Œ≤‚ÇÇ) (homology.comp_right_eq_comp_left p‚ÇÅ p‚ÇÇ) :=
by ext; simp only [kernel_subobject_map_comp, homology.œÄ_map_assoc, homology.œÄ_map, category.assoc]

/-- An isomorphism between two three-term complexes induces an isomorphism on homology. -/
def homology.map_iso (Œ± : arrow.mk f‚ÇÅ ‚âÖ arrow.mk f‚ÇÇ) (Œ≤ : arrow.mk g‚ÇÅ ‚âÖ arrow.mk g‚ÇÇ)
  (p : Œ±.hom.right = Œ≤.hom.left) :
  homology f‚ÇÅ g‚ÇÅ w‚ÇÅ ‚âÖ homology f‚ÇÇ g‚ÇÇ w‚ÇÇ :=
{ hom := homology.map w‚ÇÅ w‚ÇÇ Œ±.hom Œ≤.hom p,
  inv := homology.map w‚ÇÇ w‚ÇÅ Œ±.inv Œ≤.inv
  (by { rw [‚Üê cancel_mono (Œ±.hom.right), ‚Üê comma.comp_right, Œ±.inv_hom_id, comma.id_right, p,
      ‚Üê comma.comp_left, Œ≤.inv_hom_id, comma.id_left], refl }),
  hom_inv_id' := by { rw [homology.map_comp], convert homology.map_id _; rw [iso.hom_inv_id] },
  inv_hom_id' := by { rw [homology.map_comp], convert homology.map_id _; rw [iso.inv_hom_id] } }

end

end

section
variables {A B C : V} {f : A ‚ü∂ B} {g : B ‚ü∂ C} (w : f ‚â´ g = 0)
  {f' : A ‚ü∂ B} {g' : B ‚ü∂ C} (w' : f' ‚â´ g' = 0)
  [has_kernels V] [has_cokernels V] [has_images V] [has_image_maps V]

/-- Custom tactic to golf and speedup boring proofs in `homology.congr`. -/
private meta def aux_tac : tactic unit :=
`[ dsimp only [auto_param_eq], erw [category.id_comp, category.comp_id], cases pf, cases pg, refl ]

/--
`homology f g w ‚âÖ homology f' g' w'` if `f = f'` and `g = g'`.
(Note the objects are not changing here.)
-/
@[simps]
def homology.congr (pf : f = f') (pg : g = g') : homology f g w ‚âÖ homology f' g' w' :=
{ hom := homology.map w w' ‚ü®ùüô _, ùüô _, by aux_tac‚ü© ‚ü®ùüô _, ùüô _, by aux_tac‚ü© rfl,
  inv := homology.map w' w ‚ü®ùüô _, ùüô _, by aux_tac‚ü© ‚ü®ùüô _, ùüô _, by aux_tac‚ü© rfl,
  hom_inv_id' := begin
    cases pf, cases pg, rw [homology.map_comp, ‚Üê homology.map_id],
    congr' 1; exact category.comp_id _,
  end,
  inv_hom_id' := begin
    cases pf, cases pg, rw [homology.map_comp, ‚Üê homology.map_id],
    congr' 1; exact category.comp_id _,
  end, }

end

/-!
We provide a variant `image_to_kernel' : image f ‚ü∂ kernel g`,
and use this to give alternative formulas for `homology f g w`.
-/
section image_to_kernel'
variables {A B C : V} (f : A ‚ü∂ B) (g : B ‚ü∂ C) (w : f ‚â´ g = 0)
  [has_kernels V] [has_images V]

/--
While `image_to_kernel f g w` provides a morphism
`image_subobject f ‚ü∂ kernel_subobject g`
in terms of the subobject API,
this variant provides a morphism
`image f ‚ü∂ kernel g`,
which is sometimes more convenient.
-/
def image_to_kernel' (w : f ‚â´ g = 0) : image f ‚ü∂ kernel g :=
kernel.lift g (image.Œπ f) (by { ext, simpa using w, })

@[simp] lemma image_subobject_iso_image_to_kernel' (w : f ‚â´ g = 0) :
  (image_subobject_iso f).hom ‚â´ image_to_kernel' f g w =
    image_to_kernel f g w ‚â´ (kernel_subobject_iso g).hom :=
by { ext, simp [image_to_kernel'], }

@[simp] lemma image_to_kernel'_kernel_subobject_iso (w : f ‚â´ g = 0) :
  image_to_kernel' f g w ‚â´ (kernel_subobject_iso g).inv =
    (image_subobject_iso f).inv ‚â´ image_to_kernel f g w :=
by { ext, simp [image_to_kernel'], }

variables [has_cokernels V]

/--
`homology f g w` can be computed as the cokernel of `image_to_kernel' f g w`.
-/
def homology_iso_cokernel_image_to_kernel' (w : f ‚â´ g = 0) :
  homology f g w ‚âÖ cokernel (image_to_kernel' f g w) :=
{ hom := cokernel.map _ _ (image_subobject_iso f).hom (kernel_subobject_iso g).hom
    (by simp only [image_subobject_iso_image_to_kernel']),
  inv := cokernel.map _ _ (image_subobject_iso f).inv (kernel_subobject_iso g).inv
    (by simp only [image_to_kernel'_kernel_subobject_iso]),
  hom_inv_id' := begin
    apply coequalizer.hom_ext,
    simp only [iso.hom_inv_id_assoc, cokernel.œÄ_desc, cokernel.œÄ_desc_assoc, category.assoc,
      coequalizer_as_cokernel],
    exact (category.comp_id _).symm,
  end,
  inv_hom_id' := by { ext1, simp only [iso.inv_hom_id_assoc, cokernel.œÄ_desc, category.comp_id,
    cokernel.œÄ_desc_assoc, category.assoc], } }

variables [has_equalizers V]

/--
`homology f g w` can be computed as the cokernel of `kernel.lift g f w`.
-/
def homology_iso_cokernel_lift (w : f ‚â´ g = 0) :
  homology f g w ‚âÖ cokernel (kernel.lift g f w) :=
begin
  refine homology_iso_cokernel_image_to_kernel' f g w ‚â™‚â´ _,
  have p : factor_thru_image f ‚â´ image_to_kernel' f g w = kernel.lift g f w,
  { ext, simp [image_to_kernel'], },
  exact (cokernel_epi_comp _ _).symm ‚â™‚â´ cokernel_iso_of_eq p,
end

end image_to_kernel'
