/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, E. W. Ayers
-/

import order.complete_lattice
import category_theory.over
import category_theory.yoneda
import category_theory.limits.shapes.pullbacks
import data.set.lattice

/-!
# Theory of sieves

- For an object `X` of a category `C`, a `sieve X` is a set of morphisms to `X`
  which is closed under left-composition.
- The complete lattice structure on sieves is given, as well as the Galois insertion
  given by downward-closing.
- A `sieve X` (functorially) induces a presheaf on `C` together with a monomorphism to
  the yoneda embedding of `X`.

## Tags

sieve, pullback
-/

universes v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ u‚ÇÇ u‚ÇÉ
namespace category_theory

open category limits

variables {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] (F : C ‚•§ D)
variables {X Y Z : C} (f : Y ‚ü∂ X)

/-- A set of arrows all with codomain `X`. -/
@[derive complete_lattice]
def presieve (X : C) := Œ† ‚¶ÉY‚¶Ñ, set (Y ‚ü∂ X)

namespace presieve

instance : inhabited (presieve X) := ‚ü®‚ä§‚ü©

/-- Given a sieve `S` on `X : C`, its associated diagram `S.diagram` is defined to be
    the natural functor from the full subcategory of the over category `C/X` consisting
    of arrows in `S` to `C`. -/
abbreviation diagram (S : presieve X) : {f : over X // S f.hom} ‚•§ C :=
full_subcategory_inclusion _ ‚ãô over.forget X

/-- Given a sieve `S` on `X : C`, its associated cocone `S.cocone` is defined to be
    the natural cocone over the diagram defined above with cocone point `X`. -/
abbreviation cocone (S : presieve X) : cocone S.diagram :=
(over.forget_cocone X).whisker (full_subcategory_inclusion _)

/--
Given a set of arrows `S` all with codomain `X`, and a set of arrows with codomain `Y` for each
`f : Y ‚ü∂ X` in `S`, produce a set of arrows with codomain `X`:
`{ g ‚â´ f | (f : Y ‚ü∂ X) ‚àà S, (g : Z ‚ü∂ Y) ‚àà R f }`.
-/
def bind (S : presieve X) (R : Œ† ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí presieve Y) :
  presieve X :=
Œª Z h, ‚àÉ (Y : C) (g : Z ‚ü∂ Y) (f : Y ‚ü∂ X) (H : S f), R H g ‚àß g ‚â´ f = h

@[simp]
lemma bind_comp {S : presieve X}
  {R : Œ† ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí presieve Y} {g : Z ‚ü∂ Y} (h‚ÇÅ : S f) (h‚ÇÇ : R h‚ÇÅ g) :
bind S R (g ‚â´ f) :=
‚ü®_, _, _, h‚ÇÅ, h‚ÇÇ, rfl‚ü©

/-- The singleton presieve.  -/
-- Note we can't make this into `has_singleton` because of the out-param.
inductive singleton : presieve X
| mk : singleton f

@[simp] lemma singleton_eq_iff_domain (f g : Y ‚ü∂ X) : singleton f g ‚Üî f = g :=
begin
  split,
  { rintro ‚ü®a, rfl‚ü©,
    refl },
  { rintro rfl,
    apply singleton.mk, }
end

lemma singleton_self : singleton f f := singleton.mk

/--
Pullback a set of arrows with given codomain along a fixed map, by taking the pullback in the
category.
This is not the same as the arrow set of `sieve.pullback`, but there is a relation between them
in `pullback_arrows_comm`.
-/
inductive pullback_arrows [has_pullbacks C] (R : presieve X) :
  presieve Y
| mk (Z : C) (h : Z ‚ü∂ X) : R h ‚Üí pullback_arrows (pullback.snd : pullback h f ‚ü∂ Y)

lemma pullback_singleton [has_pullbacks C] (g : Z ‚ü∂ X) :
 pullback_arrows f (singleton g) = singleton (pullback.snd : pullback g f ‚ü∂ _) :=
begin
  ext W h,
  split,
  { rintro ‚ü®W, _, _, _‚ü©,
    exact singleton.mk },
  { rintro ‚ü®_‚ü©,
    exact pullback_arrows.mk Z g singleton.mk }
end

/-- Construct the presieve given by the family of arrows indexed by `Œπ`. -/
inductive of_arrows {Œπ : Type*} (Y : Œπ ‚Üí C) (f : Œ† i, Y i ‚ü∂ X) : presieve X
| mk (i : Œπ) : of_arrows (f i)

lemma of_arrows_punit :
  of_arrows _ (Œª _ : punit, f) = singleton f :=
begin
  ext Y g,
  split,
  { rintro ‚ü®_‚ü©,
    apply singleton.mk },
  { rintro ‚ü®_‚ü©,
    exact of_arrows.mk punit.star },
end

lemma of_arrows_pullback [has_pullbacks C] {Œπ : Type*}
  (Z : Œπ ‚Üí C) (g : Œ† (i : Œπ), Z i ‚ü∂ X) :
  of_arrows (Œª i, pullback (g i) f) (Œª i, pullback.snd) =
    pullback_arrows f (of_arrows Z g) :=
begin
  ext T h,
  split,
  { rintro ‚ü®hk‚ü©,
   exact pullback_arrows.mk _ _ (of_arrows.mk hk) },
  { rintro ‚ü®W, k, hk‚ÇÅ‚ü©,
    cases hk‚ÇÅ with i hi,
    apply of_arrows.mk },
end

lemma of_arrows_bind {Œπ : Type*} (Z : Œπ ‚Üí C) (g : Œ† (i : Œπ), Z i ‚ü∂ X)
  (j : Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), of_arrows Z g f ‚Üí Type*)
  (W : Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X) H, j f H ‚Üí C)
  (k : Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X) H i, W f H i ‚ü∂ Y) :
  (of_arrows Z g).bind (Œª Y f H, of_arrows (W f H) (k f H)) =
    of_arrows (Œª (i : Œ£ i, j _ (of_arrows.mk i)), W (g i.1) _ i.2)
      (Œª ij, k (g ij.1) _ ij.2 ‚â´ g ij.1) :=
begin
  ext Y f,
  split,
  { rintro ‚ü®_, _, _, ‚ü®i‚ü©, ‚ü®i'‚ü©, rfl‚ü©,
    exact of_arrows.mk (sigma.mk _ _) },
  { rintro ‚ü®i‚ü©,
    exact bind_comp _ (of_arrows.mk _) (of_arrows.mk _) }
end

/-- Given a presieve on `F(X)`, we can define a presieve on `X` by taking the preimage via `F`. -/
def functor_pullback (R : presieve (F.obj X)) : presieve X := Œª _ f, R (F.map f)

@[simp] lemma functor_pullback_mem (R : presieve (F.obj X)) {Y} (f : Y ‚ü∂ X) :
  R.functor_pullback F f ‚Üî R (F.map f) := iff.rfl

@[simp] lemma functor_pullback_id (R : presieve X) : R.functor_pullback (ùü≠ _) = R := rfl

section functor_pushforward
variables {E : Type u‚ÇÉ} [category.{v‚ÇÉ} E] (G : D ‚•§ E)

/--
Given a presieve on `X`, we can define a presieve on `F(X)` (which is actually a sieve)
by taking the sieve generated by the image via `F`.
-/
def functor_pushforward (S : presieve X) : presieve (F.obj X) :=
Œª Y f, ‚àÉ (Z : C) (g : Z ‚ü∂ X) (h : Y ‚ü∂ F.obj Z), S g ‚àß f = h ‚â´ F.map g

/--
An auxillary definition in order to fix the choice of the preimages between various definitions.
-/
@[nolint has_inhabited_instance]
structure functor_pushforward_structure (S : presieve X) {Y} (f : Y ‚ü∂ F.obj X) :=
(preobj : C) (premap : preobj ‚ü∂ X) (lift : Y ‚ü∂ F.obj preobj)
(cover : S premap) (fac : f = lift ‚â´ F.map premap)

/-- The fixed choice of a preimage. -/
noncomputable def get_functor_pushforward_structure {F : C ‚•§ D} {S : presieve X} {Y : D}
  {f : Y ‚ü∂ F.obj X} (h : S.functor_pushforward F f) : functor_pushforward_structure F S f :=
by { choose Z f' g h‚ÇÅ h using h, exact ‚ü®Z, f', g, h‚ÇÅ, h‚ü© }

lemma functor_pushforward_comp (R : presieve X) :
  R.functor_pushforward (F ‚ãô G) = (R.functor_pushforward F).functor_pushforward G :=
begin
  ext x f,
  split,
  { rintro ‚ü®X, f‚ÇÅ, g‚ÇÅ, h‚ÇÅ, rfl‚ü©, exact ‚ü®F.obj X, F.map f‚ÇÅ, g‚ÇÅ, ‚ü®X, f‚ÇÅ, ùüô _, h‚ÇÅ, by simp‚ü©, rfl‚ü© },
  { rintro ‚ü®X, f‚ÇÅ, g‚ÇÅ, ‚ü®X', f‚ÇÇ, g‚ÇÇ, h‚ÇÅ, rfl‚ü©, rfl‚ü©, use ‚ü®X', f‚ÇÇ, g‚ÇÅ ‚â´ G.map g‚ÇÇ, h‚ÇÅ, by simp‚ü© }
end

lemma image_mem_functor_pushforward (R : presieve X) {f : Y ‚ü∂ X} (h : R f) :
  R.functor_pushforward F (F.map f) := ‚ü®Y, f, ùüô _, h, by simp‚ü©

end functor_pushforward
end presieve

/--
For an object `X` of a category `C`, a `sieve X` is a set of morphisms to `X` which is closed under
left-composition.
-/
structure sieve {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] (X : C) :=
(arrows : presieve X)
(downward_closed' : ‚àÄ {Y Z f} (hf : arrows f) (g : Z ‚ü∂ Y), arrows (g ‚â´ f))

namespace sieve

instance : has_coe_to_fun (sieve X) (Œª _, presieve X) := ‚ü®sieve.arrows‚ü©

initialize_simps_projections sieve (arrows ‚Üí apply)

variables {S R : sieve X}

@[simp, priority 100] lemma downward_closed (S : sieve X) {f : Y ‚ü∂ X} (hf : S f)
  (g : Z ‚ü∂ Y) : S (g ‚â´ f) :=
S.downward_closed' hf g

lemma arrows_ext : Œ† {R S : sieve X}, R.arrows = S.arrows ‚Üí R = S
| ‚ü®Ra, _‚ü© ‚ü®Sa, _‚ü© rfl := rfl

@[ext]
protected lemma ext {R S : sieve X}
  (h : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), R f ‚Üî S f) :
  R = S :=
arrows_ext $ funext $ Œª x, funext $ Œª f, propext $ h f

protected lemma ext_iff {R S : sieve X} :
  R = S ‚Üî (‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), R f ‚Üî S f) :=
‚ü®Œª h Y f, h ‚ñ∏ iff.rfl, sieve.ext‚ü©

open lattice

/-- The supremum of a collection of sieves: the union of them all. -/
protected def Sup (ùíÆ : set (sieve X)) : (sieve X) :=
{ arrows := Œª Y, {f | ‚àÉ S ‚àà ùíÆ, sieve.arrows S f},
  downward_closed' := Œª Y Z f, by { rintro ‚ü®S, hS, hf‚ü© g, exact ‚ü®S, hS, S.downward_closed hf _‚ü© } }

/-- The infimum of a collection of sieves: the intersection of them all. -/
protected def Inf (ùíÆ : set (sieve X)) : (sieve X) :=
{ arrows := Œª Y, {f | ‚àÄ S ‚àà ùíÆ, sieve.arrows S f},
  downward_closed' := Œª Y Z f hf g S H, S.downward_closed (hf S H) g }

/-- The union of two sieves is a sieve. -/
protected def union (S R : sieve X) : sieve X :=
{ arrows := Œª Y f, S f ‚à® R f,
  downward_closed' := by { rintros Y Z f (h | h) g; simp [h] } }

/-- The intersection of two sieves is a sieve. -/
protected def inter (S R : sieve X) : sieve X :=
{ arrows := Œª Y f, S f ‚àß R f,
  downward_closed' := by { rintros Y Z f ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© g, simp [h‚ÇÅ, h‚ÇÇ] } }

/--
Sieves on an object `X` form a complete lattice.
We generate this directly rather than using the galois insertion for nicer definitional properties.
-/
instance : complete_lattice (sieve X) :=
{ le           := Œª S R, ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), S f ‚Üí R f,
  le_refl      := Œª S f q, id,
  le_trans     := Œª S‚ÇÅ S‚ÇÇ S‚ÇÉ S‚ÇÅ‚ÇÇ S‚ÇÇ‚ÇÉ Y f h, S‚ÇÇ‚ÇÉ _ (S‚ÇÅ‚ÇÇ _ h),
  le_antisymm  := Œª S R p q, sieve.ext (Œª Y f, ‚ü®p _, q _‚ü©),
  top          := { arrows := Œª _, set.univ, downward_closed' := Œª Y Z f g h, ‚ü®‚ü© },
  bot          := { arrows := Œª _, ‚àÖ, downward_closed' := Œª _ _ _ p _, false.elim p },
  sup          := sieve.union,
  inf          := sieve.inter,
  Sup          := sieve.Sup,
  Inf          := sieve.Inf,
  le_Sup       := Œª ùíÆ S hS Y f hf, ‚ü®S, hS, hf‚ü©,
  Sup_le       := Œª ‚Ñ∞ S hS Y f, by { rintro ‚ü®R, hR, hf‚ü©, apply hS R hR _ hf },
  Inf_le       := Œª _ _ hS _ _ h, h _ hS,
  le_Inf       := Œª _ _ hS _ _ hf _ hR, hS _ hR _ hf,
  le_sup_left  := Œª _ _ _ _, or.inl,
  le_sup_right := Œª _ _ _ _, or.inr,
  sup_le       := Œª _ _ _ a b _ _ hf, hf.elim (a _) (b _),
  inf_le_left  := Œª _ _ _ _, and.left,
  inf_le_right := Œª _ _ _ _, and.right,
  le_inf       := Œª _ _ _ p q _ _ z, ‚ü®p _ z, q _ z‚ü©,
  le_top       := Œª _ _ _ _, trivial,
  bot_le       := Œª _ _ _, false.elim }

/-- The maximal sieve always exists. -/
instance sieve_inhabited : inhabited (sieve X) := ‚ü®‚ä§‚ü©

@[simp]
lemma Inf_apply {Ss : set (sieve X)} {Y} (f : Y ‚ü∂ X) :
  Inf Ss f ‚Üî ‚àÄ (S : sieve X) (H : S ‚àà Ss), S f :=
iff.rfl

@[simp]
lemma Sup_apply {Ss : set (sieve X)} {Y} (f : Y ‚ü∂ X) :
  Sup Ss f ‚Üî ‚àÉ (S : sieve X) (H : S ‚àà Ss), S f :=
iff.rfl

@[simp]
lemma inter_apply {R S : sieve X} {Y} (f : Y ‚ü∂ X) :
  (R ‚äì S) f ‚Üî R f ‚àß S f :=
iff.rfl

@[simp]
lemma union_apply {R S : sieve X} {Y} (f : Y ‚ü∂ X) :
  (R ‚äî S) f ‚Üî R f ‚à® S f :=
iff.rfl

@[simp]
lemma top_apply (f : Y ‚ü∂ X) : (‚ä§ : sieve X) f := trivial

/-- Generate the smallest sieve containing the given set of arrows. -/
@[simps]
def generate (R : presieve X) : sieve X :=
{ arrows := Œª Z f, ‚àÉ Y (h : Z ‚ü∂ Y) (g : Y ‚ü∂ X), R g ‚àß h ‚â´ g = f,
  downward_closed' :=
  begin
    rintro Y Z _ ‚ü®W, g, f, hf, rfl‚ü© h,
    exact ‚ü®_, h ‚â´ g, _, hf, by simp‚ü©,
  end }

/--
Given a presieve on `X`, and a sieve on each domain of an arrow in the presieve, we can bind to
produce a sieve on `X`.
-/
@[simps]
def bind (S : presieve X) (R : Œ† ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí sieve Y) : sieve X :=
{ arrows := S.bind (Œª Y f h, R h),
  downward_closed' :=
  begin
    rintro Y Z f ‚ü®W, f, h, hh, hf, rfl‚ü© g,
    exact ‚ü®_, g ‚â´ f, _, hh, by simp [hf]‚ü©,
  end }

open order lattice

lemma sets_iff_generate (R : presieve X) (S : sieve X) :
  generate R ‚â§ S ‚Üî R ‚â§ S :=
‚ü®Œª H Y g hg, H _ ‚ü®_, ùüô _, _, hg, id_comp _‚ü©,
 Œª ss Y f,
  begin
    rintro ‚ü®Z, f, g, hg, rfl‚ü©,
    exact S.downward_closed (ss Z hg) f,
  end‚ü©

/-- Show that there is a galois insertion (generate, set_over). -/
def gi_generate : galois_insertion (generate : presieve X ‚Üí sieve X) arrows :=
{ gc := sets_iff_generate,
  choice := Œª ùí¢ _, generate ùí¢,
  choice_eq := Œª _ _, rfl,
  le_l_u := Œª S Y f hf, ‚ü®_, ùüô _, _, hf, id_comp _‚ü© }

lemma le_generate (R : presieve X) : R ‚â§ generate R :=
gi_generate.gc.le_u_l R

@[simp] lemma generate_sieve (S : sieve X) : generate S = S :=
gi_generate.l_u_eq S

/-- If the identity arrow is in a sieve, the sieve is maximal. -/
lemma id_mem_iff_eq_top : S (ùüô X) ‚Üî S = ‚ä§ :=
‚ü®Œª h, top_unique $ Œª Y f _, by simpa using downward_closed _ h f,
 Œª h, h.symm ‚ñ∏ trivial‚ü©

/-- If an arrow set contains a split epi, it generates the maximal sieve. -/
lemma generate_of_contains_split_epi {R : presieve X} (f : Y ‚ü∂ X) [split_epi f]
  (hf : R f) : generate R = ‚ä§ :=
begin
  rw ‚Üê id_mem_iff_eq_top,
  exact ‚ü®_, section_ f, f, hf, by simp‚ü©,
end

@[simp]
lemma generate_of_singleton_split_epi (f : Y ‚ü∂ X) [split_epi f] :
  generate (presieve.singleton f) = ‚ä§ :=
generate_of_contains_split_epi f (presieve.singleton_self _)

@[simp]
lemma generate_top : generate (‚ä§ : presieve X) = ‚ä§ :=
generate_of_contains_split_epi (ùüô _) ‚ü®‚ü©

/-- Given a morphism `h : Y ‚ü∂ X`, send a sieve S on X to a sieve on Y
    as the inverse image of S with `_ ‚â´ h`.
    That is, `sieve.pullback S h := (‚â´ h) '‚Åª¬π S`. -/
@[simps]
def pullback (h : Y ‚ü∂ X) (S : sieve X) : sieve Y :=
{ arrows := Œª Y sl, S (sl ‚â´ h),
  downward_closed' := Œª Z W f g h, by simp [g] }

@[simp]
lemma pullback_id : S.pullback (ùüô _) = S :=
by simp [sieve.ext_iff]

@[simp]
lemma pullback_top {f : Y ‚ü∂ X} : (‚ä§ : sieve X).pullback f = ‚ä§ :=
top_unique (Œª _ g, id)

lemma pullback_comp {f : Y ‚ü∂ X} {g : Z ‚ü∂ Y} (S : sieve X) :
  S.pullback (g ‚â´ f) = (S.pullback f).pullback g :=
by simp [sieve.ext_iff]

@[simp]
lemma pullback_inter {f : Y ‚ü∂ X} (S R : sieve X) :
 (S ‚äì R).pullback f = S.pullback f ‚äì R.pullback f :=
by simp [sieve.ext_iff]

lemma pullback_eq_top_iff_mem (f : Y ‚ü∂ X) : S f ‚Üî S.pullback f = ‚ä§ :=
by rw [‚Üê id_mem_iff_eq_top, pullback_apply, id_comp]

lemma pullback_eq_top_of_mem (S : sieve X) {f : Y ‚ü∂ X} : S f ‚Üí S.pullback f = ‚ä§ :=
(pullback_eq_top_iff_mem f).1

/--
Push a sieve `R` on `Y` forward along an arrow `f : Y ‚ü∂ X`: `gf : Z ‚ü∂ X` is in the sieve if `gf`
factors through some `g : Z ‚ü∂ Y` which is in `R`.
-/
@[simps]
def pushforward (f : Y ‚ü∂ X) (R : sieve Y) : sieve X :=
{ arrows := Œª Z gf, ‚àÉ g, g ‚â´ f = gf ‚àß R g,
  downward_closed' := Œª Z‚ÇÅ Z‚ÇÇ g ‚ü®j, k, z‚ü© h, ‚ü®h ‚â´ j, by simp [k], by simp [z]‚ü© }

lemma pushforward_apply_comp {R : sieve Y} {Z : C} {g : Z ‚ü∂ Y} (hg : R g) (f : Y ‚ü∂ X) :
  R.pushforward f (g ‚â´ f) :=
‚ü®g, rfl, hg‚ü©

lemma pushforward_comp {f : Y ‚ü∂ X} {g : Z ‚ü∂ Y} (R : sieve Z) :
  R.pushforward (g ‚â´ f) = (R.pushforward g).pushforward f :=
sieve.ext (Œª W h, ‚ü®Œª ‚ü®f‚ÇÅ, hq, hf‚ÇÅ‚ü©, ‚ü®f‚ÇÅ ‚â´ g, by simpa, f‚ÇÅ, rfl, hf‚ÇÅ‚ü©,
                   Œª ‚ü®y, hy, z, hR, hz‚ü©, ‚ü®z, by rwa reassoc_of hR, hz‚ü©‚ü©)

lemma galois_connection (f : Y ‚ü∂ X) : galois_connection (sieve.pushforward f) (sieve.pullback f) :=
Œª S R, ‚ü®Œª hR Z g hg, hR _ ‚ü®g, rfl, hg‚ü©, Œª hS Z g ‚ü®h, hg, hh‚ü©, hg ‚ñ∏ hS h hh‚ü©

lemma pullback_monotone (f : Y ‚ü∂ X) : monotone (sieve.pullback f) :=
(galois_connection f).monotone_u

lemma pushforward_monotone (f : Y ‚ü∂ X) : monotone (sieve.pushforward f) :=
(galois_connection f).monotone_l

lemma le_pushforward_pullback (f : Y ‚ü∂ X) (R : sieve Y) :
  R ‚â§ (R.pushforward f).pullback f :=
(galois_connection f).le_u_l _

lemma pullback_pushforward_le (f : Y ‚ü∂ X) (R : sieve X) :
  (R.pullback f).pushforward f ‚â§ R :=
(galois_connection f).l_u_le _

lemma pushforward_union {f : Y ‚ü∂ X} (S R : sieve Y) :
  (S ‚äî R).pushforward f = S.pushforward f ‚äî R.pushforward f :=
(galois_connection f).l_sup

lemma pushforward_le_bind_of_mem (S : presieve X)
  (R : Œ† ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí sieve Y) (f : Y ‚ü∂ X) (h : S f) :
  (R h).pushforward f ‚â§ bind S R :=
begin
  rintro Z _ ‚ü®g, rfl, hg‚ü©,
  exact ‚ü®_, g, f, h, hg, rfl‚ü©,
end

lemma le_pullback_bind (S : presieve X) (R : Œ† ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí sieve Y)
  (f : Y ‚ü∂ X) (h : S f) :
  R h ‚â§ (bind S R).pullback f :=
begin
  rw ‚Üê galois_connection f,
  apply pushforward_le_bind_of_mem,
end

/-- If `f` is a monomorphism, the pushforward-pullback adjunction on sieves is coreflective. -/
def galois_coinsertion_of_mono (f : Y ‚ü∂ X) [mono f] :
  galois_coinsertion (sieve.pushforward f) (sieve.pullback f) :=
begin
  apply (galois_connection f).to_galois_coinsertion,
  rintros S Z g ‚ü®g‚ÇÅ, hf, hg‚ÇÅ‚ü©,
  rw cancel_mono f at hf,
  rwa ‚Üê hf,
end

/-- If `f` is a split epi, the pushforward-pullback adjunction on sieves is reflective. -/
def galois_insertion_of_split_epi (f : Y ‚ü∂ X) [split_epi f] :
  galois_insertion (sieve.pushforward f) (sieve.pullback f) :=
begin
  apply (galois_connection f).to_galois_insertion,
  intros S Z g hg,
  refine ‚ü®g ‚â´ section_ f, by simpa‚ü©,
end

lemma pullback_arrows_comm [has_pullbacks C] {X Y : C} (f : Y ‚ü∂ X)
  (R : presieve X) :
  sieve.generate (R.pullback_arrows f) = (sieve.generate R).pullback f :=
begin
  ext Z g,
  split,
  { rintro ‚ü®_, h, k, hk, rfl‚ü©,
    cases hk with W g hg,
    change (sieve.generate R).pullback f (h ‚â´ pullback.snd),
    rw [sieve.pullback_apply, assoc, ‚Üê pullback.condition, ‚Üê assoc],
    exact sieve.downward_closed _ (sieve.le_generate R W hg) (h ‚â´ pullback.fst)},
  { rintro ‚ü®W, h, k, hk, comm‚ü©,
    exact ‚ü®_, _, _, presieve.pullback_arrows.mk _ _ hk, pullback.lift_snd _ _ comm‚ü© },
end

section functor
variables {E : Type u‚ÇÉ} [category.{v‚ÇÉ} E] (G : D ‚•§ E)

/--
If `R` is a sieve, then the `category_theory.presieve.functor_pullback` of `R` is actually a sieve.
-/
@[simps] def functor_pullback (R : sieve (F.obj X)) : sieve X :=
{ arrows := presieve.functor_pullback F R,
  downward_closed' := Œª _ _ f hf g,
  begin
    unfold presieve.functor_pullback,
    rw F.map_comp,
    exact R.downward_closed hf (F.map g),
  end }

@[simp] lemma functor_pullback_arrows (R : sieve (F.obj X)) :
  (R.functor_pullback F).arrows = R.arrows.functor_pullback F := rfl

@[simp] lemma functor_pullback_id (R : sieve X) : R.functor_pullback (ùü≠ _) = R :=
by { ext, refl }

lemma functor_pullback_comp (R : sieve ((F ‚ãô G).obj X)) :
  R.functor_pullback (F ‚ãô G) = (R.functor_pullback G).functor_pullback F := by { ext, refl }

lemma functor_pushforward_extend_eq {R : presieve X} :
  (generate R).arrows.functor_pushforward F = R.functor_pushforward F :=
begin
  ext Y f, split,
  { rintro ‚ü®X', g, f', ‚ü®X'', g', f'', h‚ÇÅ, rfl‚ü©, rfl‚ü©,
    exact ‚ü®X'', f'', f' ‚â´ F.map g', h‚ÇÅ, by simp‚ü© },
  { rintro ‚ü®X', g, f', h‚ÇÅ, h‚ÇÇ‚ü©, exact ‚ü®X', g, f', le_generate R _ h‚ÇÅ, h‚ÇÇ‚ü© }
end

/-- The sieve generated by the image of `R` under `F`. -/
@[simps] def functor_pushforward (R : sieve X) : sieve (F.obj X) :=
{ arrows := R.arrows.functor_pushforward F,
  downward_closed' := Œª Y Z f h g, by
  { obtain ‚ü®X, Œ±, Œ≤, hŒ±, rfl‚ü© := h,
    exact ‚ü®X, Œ±, g ‚â´ Œ≤, hŒ±, by simp‚ü© } }

@[simp] lemma functor_pushforward_id (R : sieve X) :
  R.functor_pushforward (ùü≠ _) = R :=
begin
  ext X f,
  split,
  { intro hf,
    obtain ‚ü®X, g, h, hg, rfl‚ü© := hf,
    exact R.downward_closed hg h, },
  { intro hf,
    exact ‚ü®X, f, ùüô _, hf, by simp‚ü© }
end

lemma functor_pushforward_comp (R : sieve X) :
  R.functor_pushforward (F ‚ãô G) = (R.functor_pushforward F).functor_pushforward G :=
by { ext, simpa [R.arrows.functor_pushforward_comp F G] }


lemma functor_galois_connection (X : C) :
  _root_.galois_connection
    (sieve.functor_pushforward F : sieve X ‚Üí sieve (F.obj X))
    (sieve.functor_pullback F) :=
begin
  intros R S,
  split,
  { intros hle X f hf,
    apply hle,
    refine ‚ü®X, f, ùüô _, hf, _‚ü©,
    rw id_comp, },
  { rintros hle Y f ‚ü®X, g, h, hg, rfl‚ü©,
    apply sieve.downward_closed S,
    exact hle g hg, }
end

lemma functor_pullback_monotone (X : C) :
  monotone (sieve.functor_pullback F : sieve (F.obj X) ‚Üí sieve X) :=
(functor_galois_connection F X).monotone_u

lemma functor_pushforward_monotone (X : C) :
  monotone (sieve.functor_pushforward F : sieve X ‚Üí sieve (F.obj X)) :=
(functor_galois_connection F X).monotone_l

lemma le_functor_pushforward_pullback (R : sieve X) :
  R ‚â§ (R.functor_pushforward F).functor_pullback F :=
(functor_galois_connection F X).le_u_l _

lemma functor_pullback_pushforward_le (R : sieve (F.obj X)) :
  (R.functor_pullback F).functor_pushforward F ‚â§ R :=
(functor_galois_connection F X).l_u_le _

lemma functor_pushforward_union (S R : sieve X) :
  (S ‚äî R).functor_pushforward F = S.functor_pushforward F ‚äî R.functor_pushforward F :=
(functor_galois_connection F X).l_sup

lemma functor_pullback_union (S R : sieve (F.obj X)) :
  (S ‚äî R).functor_pullback F = S.functor_pullback F ‚äî R.functor_pullback F := rfl

lemma functor_pullback_inter (S R : sieve (F.obj X)) :
  (S ‚äì R).functor_pullback F = S.functor_pullback F ‚äì R.functor_pullback F := rfl

@[simp] lemma functor_pushforward_bot (F : C ‚•§ D) (X : C) :
  (‚ä• : sieve X).functor_pushforward F = ‚ä• := (functor_galois_connection F X).l_bot

@[simp] lemma functor_pushforward_top (F : C ‚•§ D) (X : C) :
  (‚ä§ : sieve X).functor_pushforward F = ‚ä§ :=
  begin
    refine (generate_sieve _).symm.trans _,
    apply generate_of_contains_split_epi (ùüô (F.obj X)),
    refine ‚ü®X, ùüô _, ùüô _, trivial, by simp‚ü©
  end

@[simp] lemma functor_pullback_bot (F : C ‚•§ D) (X : C) :
  (‚ä• : sieve (F.obj X)).functor_pullback F = ‚ä• := rfl

@[simp] lemma functor_pullback_top (F : C ‚•§ D) (X : C) :
  (‚ä§ : sieve (F.obj X)).functor_pullback F = ‚ä§ := rfl

lemma image_mem_functor_pushforward (R : sieve X) {V} {f : V ‚ü∂ X} (h : R f) :
  R.functor_pushforward F (F.map f) := ‚ü®V, f, ùüô _, h, by simp‚ü©

/-- When `F` is essentially surjective and full, the galois connection is a galois insertion. -/
def ess_surj_full_functor_galois_insertion [ess_surj F] [full F] (X : C) :
  galois_insertion
    (sieve.functor_pushforward F : sieve X ‚Üí sieve (F.obj X))
    (sieve.functor_pullback F) :=
begin
  apply (functor_galois_connection F X).to_galois_insertion,
  intros S Y f hf,
  refine ‚ü®_, F.preimage ((F.obj_obj_preimage_iso Y).hom ‚â´ f), (F.obj_obj_preimage_iso Y).inv, _‚ü©,
  simpa using S.downward_closed hf _,
end

/-- When `F` is fully faithful, the galois connection is a galois coinsertion. -/
def fully_faithful_functor_galois_coinsertion [full F] [faithful F] (X : C) :
  galois_coinsertion
    (sieve.functor_pushforward F : sieve X ‚Üí sieve (F.obj X))
    (sieve.functor_pullback F) :=
begin
  apply (functor_galois_connection F X).to_galois_coinsertion,
  rintros S Y f ‚ü®Z, g, h, h‚ÇÅ, h‚ÇÇ‚ü©,
  rw [‚ÜêF.image_preimage h, ‚ÜêF.map_comp] at h‚ÇÇ,
  rw F.map_injective h‚ÇÇ,
  exact S.downward_closed h‚ÇÅ _,
end

end functor

/-- A sieve induces a presheaf. -/
@[simps]
def functor (S : sieve X) : C·µí·µñ ‚•§ Type v‚ÇÅ :=
{ obj := Œª Y, {g : Y.unop ‚ü∂ X // S g},
  map := Œª Y Z f g, ‚ü®f.unop ‚â´ g.1, downward_closed _ g.2 _‚ü© }

/--
If a sieve S is contained in a sieve T, then we have a morphism of presheaves on their induced
presheaves.
-/
@[simps]
def nat_trans_of_le {S T : sieve X} (h : S ‚â§ T) : S.functor ‚ü∂ T.functor :=
{ app := Œª Y f, ‚ü®f.1, h _ f.2‚ü© }.

/-- The natural inclusion from the functor induced by a sieve to the yoneda embedding. -/
@[simps]
def functor_inclusion (S : sieve X) : S.functor ‚ü∂ yoneda.obj X :=
{ app := Œª Y f, f.1 }.

lemma nat_trans_of_le_comm {S T : sieve X} (h : S ‚â§ T) :
  nat_trans_of_le h ‚â´ functor_inclusion _ = functor_inclusion _ :=
rfl

/-- The presheaf induced by a sieve is a subobject of the yoneda embedding. -/
instance functor_inclusion_is_mono : mono S.functor_inclusion :=
‚ü®Œª Z f g h, by { ext Y y, apply congr_fun (nat_trans.congr_app h Y) y }‚ü©

/--
A natural transformation to a representable functor induces a sieve. This is the left inverse of
`functor_inclusion`, shown in `sieve_of_functor_inclusion`.
-/
-- TODO: Show that when `f` is mono, this is right inverse to `functor_inclusion` up to isomorphism.
@[simps]
def sieve_of_subfunctor {R} (f : R ‚ü∂ yoneda.obj X) : sieve X :=
{ arrows := Œª Y g, ‚àÉ t, f.app (opposite.op Y) t = g,
  downward_closed' := Œª Y Z _,
  begin
    rintro ‚ü®t, rfl‚ü© g,
    refine ‚ü®R.map g.op t, _‚ü©,
    rw functor_to_types.naturality _ _ f,
    simp,
  end }

lemma sieve_of_subfunctor_functor_inclusion : sieve_of_subfunctor S.functor_inclusion = S :=
begin
  ext,
  simp only [functor_inclusion_app, sieve_of_subfunctor_apply, subtype.val_eq_coe],
  split,
  { rintro ‚ü®‚ü®f, hf‚ü©, rfl‚ü©,
    exact hf },
  { intro hf,
    exact ‚ü®‚ü®_, hf‚ü©, rfl‚ü© }
end

instance functor_inclusion_top_is_iso : is_iso ((‚ä§ : sieve X).functor_inclusion) :=
‚ü®‚ü®{ app := Œª Y a, ‚ü®a, ‚ü®‚ü©‚ü© }, by tidy‚ü©‚ü©

end sieve
end category_theory
